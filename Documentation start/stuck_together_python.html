 
<h3> bd.py </h3> <xmp>

#!/usr/env python

import math

import numpy

from utils import *

from gfrdbase import *
import _gfrd

import logging

import itertools

__all__ = [
    'calculate_bd_dt',
    'BDSimulatorCore',
    'BDSimulator',
    ]

log = logging.getLogger('ecell')

DEFAULT_DT_FACTOR = 1e-5

def calculate_bd_dt(species_list):
    D_list = []
    radius_list = []
    D_max = 0.
    radius_min = numpy.inf
    for species in species_list:
        if D_max < species.D:
            D_max = species.D
        if radius_min > species.radius:
            radius_min = species.radius
    return (radius_min * 2) ** 2 / (D_max * 2)


class BDSimulatorCore(object):
    '''
    BDSimulatorCore borrows the following from the main simulator:
    - species_list
    - reaction_types list (both 1 and 2)
    
    '''
    def __init__(self, world, rng, network_rules, dissociation_retry_moves):
        self.world = world
        self.rng = rng
        self.network_rules = network_rules
        self.dissociation_retry_moves = dissociation_retry_moves

        self.t = 0.0
        self.dt = 0.0

        self.dt_factor = DEFAULT_DT_FACTOR

        self.step_counter = 0
        self.reaction_events = 0

    def initialize(self):
        self.determine_dt()

    def get_next_time(self):
        return self.t + self.dt

    def stop(self, t):
        # dummy
        self.t = t

    def determine_dt(self):
        self.dt = self.dt_factor * \
               calculate_bd_dt(self.world.species)
        if __debug__:
            log.debug('bd dt = %g' % self.dt)

    def step(self):
        self.step_counter += 1

        def increment_reaction_events(rr):
            self.reaction_events += 1

        ppg = _gfrd.BDPropagator(self.world, self.network_rules,
                     self.rng, self.dt, self.dissociation_retry_moves,
                     increment_reaction_events, self.world.particle_ids)
        ppg.propagate_all()

        self.t += self.dt

    def check(self):
        for pp in self.tx:
            assert not self.tx.check_overlap(pp)

class BDSimulator(ParticleSimulatorBase):
    def __init__(self, world, rng, network_rules):
        ParticleSimulatorBase.__init__(self, world, rng, network_rules)
        self.is_dirty = True
        self.core = BDSimulatorCore(self.world, self.rng, self.network_rules,
                                    self.dissociation_retry_moves)

    def t(self):
        return self.core.t

    def sett(self, t):
        self.core.t = t

    t = property(t, sett)

    def get_dt(self):
        return self.core.dt

    def get_step_counter(self):
        return self.core.step_counter

    dt = property(get_dt)
    step_counter = property(get_step_counter)

    def set_dt_factor(self, dt_factor):
        self.core.dt_factor = dt_factor

    def get_dt_factor(self):
        return self.core.dt_factor

    dt_factor = property(get_dt_factor, set_dt_factor)


    def initialize(self):
        self.core.initialize()
        self.is_dirty = False

    def get_next_time(self):
        return self.core.t + self.core.dt

    def reset(self):
        # DUMMY
        self.core.t=0

    def stop(self, t):
        # dummy
        self.core.stop(t)

    def step(self):
        self.reaction_type = None

        if self.is_dirty:
            self.initialize()

        self.core.step()

        if __debug__:
            log.info('%d: t=%g dt=%g, reactions=%d, rejected_moves=%d' %
                 (self.step_counter, self.t, self.dt, self.reaction_events,
                  self.rejected_moves))

    def check(self):
        pass
 </xmp> 
<h3> constants.py </h3> <xmp>

class EventType(object):
    def __init__(self, value, symbol):
        self.value = value
        self.symbol = symbol

    def __int__(self):
        return self.value

    def __repr__(self):
        return "EventType(%s, %s)" % (repr(self.value), repr(self.symbol))

EventType.SINGLE_REACTION = EventType(10, "SINGLE_REACTION")
EventType.SINGLE_ESCAPE   = EventType(11, "SINGLE_ESCAPE")
EventType.COM_ESCAPE      = EventType(11, "COM_ESCAPE")
EventType.IV_EVENT        = EventType(12, "IV_EVENT")
EventType.IV_ESCAPE       = EventType(13, "IV_ESCAPE")
EventType.IV_REACTION     = EventType(14, "IV_REACTION")
EventType.IV_INTERACTION  = EventType(15, "IV_INTERACTION")
EventType.BURST           = EventType(16, "BURST")
EventType.MULTI_ESCAPE    = EventType(17, "MULTI_ESCAPE")
EventType.MULTI_UNIMOLECULAR_REACTION = \
        EventType(18, "MULTI_UNIMOLECULAR_REACTION")
EventType.MULTI_BIMOLECULAR_REACTION = \
        EventType(19, "MULTI_BIMOLECULAR_REACTION")
 </xmp> 
<h3> datafile.py </h3> <xmp>


def load_header(filename):
    file = open(filename)
    lines = []
    for line in file.readlines():
        if line[0:2] == '#@':
            hline = line[2:].lstrip()
            lines.append(hline)

    g = {}
    l = {}
    for line in lines:
        exec(line, g, l)

    return l
 </xmp> 
<h3> dumper.py </h3> <xmp>

from single import Single
from pair import Pair
from multi import Multi
from egfrd import EGFRDSimulator
from gillespie import GillespieSimulator
import _gfrd

# get methods return an iterator, dump methods return a string.
__all__ = [
    'get_species',
    'dump_species',
    'get_species_names',
    'dump_species_names',
    'get_particles',
    'dump_particles',
    'get_number_of_particles',
    'dump_number_of_particles',
    'get_domains',
    'dump_domains',
    'get_reaction_rules',
    'dump_reaction_rules',
    ]


def get_species(sim):
    """Return an iterator over the Species in the simulator.

    Arguments:
        - sim
            an EGFRDSimulator.

    """
    # sim.world.species returns a SpeciesRange over SpeciesInfo.
    return sim.world.model.species_types

def dump_species(sim):
    """Return a string containing the Species in the simulator.

    Arguments:
        - sim
            an EGFRDSimulator.

    """
    return '\n'.join((str(st) for st in get_species(sim)))

def get_species_names(sim):
    """Return an iterator over the names of the Species in the 
    simulator.

    Arguments:
        - sim
            an EGFRDSimulator.

    """
    return (st['name'] for st in get_species(sim))

def dump_species_names(sim):
    """Return a string containing the names of the Species in the 
    simulator.

    Arguments:
        - sim
            an EGFRDSimulator.

    """
    return ' '.join(get_species_names(sim))

def _get_species_type_by_name(sim, name):
    #Helper.
    for species_type in sim.world.model.species_types:
        if species_type['name'] == name:
            return species_type

    raise RuntimeError('SpeciesType %s does not exist.' % (name))

def _get_particles_by_sid(sim, sid):
    # Helper.
    for pid in sim.world.get_particle_ids(sid):
        particle = sim.world.get_particle(pid)[1]
        yield (pid, particle)

def get_particles(sim, identifier=None):
    """Return an iterator over the
    (particle identifier, particle)-pairs in the simulator.

    Arguments:
        - sim
            an EGFRDSimulator.
        - identifier
            a Species or the name of a Species. If none is specified, 
            all (particle identifier, particle)-pairs will be returned.

    """
    if isinstance(sim, GillespieSimulator):
        raise RuntimeError('GillespieSimulator does not keep track '
                           'of individual particles.')

    if identifier == None:
        return sim.world
    else:
        if isinstance(identifier, _gfrd.SpeciesType):
            sid = identifier
        elif isinstance(identifier, str):
            sid = _get_species_type_by_name(sim, identifier).id
        else:
            raise RuntimeError('Wrong identifier type.')
        return _get_particles_by_sid(sim, sid)

def dump_particles(sim, identifier=None):
    """Return a string containing the
    (particle identifier, particle)-pairs in the simulator.

    Arguments:
        - sim
            an EGFRDSimulator.
        - identifier
            a Species or the name of a Species. If none is specified, 
            all (particle identifier, particle)-pairs will be returned.

    """
    return '\n'.join((str(x) for x in get_particles(sim, identifier)))

def _get_number_of_particles_by_sid(sim, sid):
    # Helper.
    if isinstance(sim, EGFRDSimulator):
        return len(sim.world.get_particle_ids(sid))
    else:
        # Gillespie.
        species_index = sim.speciesDict[sid]
        return sim.stateArray[species_index]

def get_number_of_particles(sim, identifier=None):
    """Return the number of particles of a certain Species in the 
    simulator.

    Arguments:
        - sim
            either an EGFRDSimulator or a GillespieSimulator.
        - identifier
            a Species. Optional. If none is specified, a list of 
            (Species name, number of particles)-pairs will be returned.

    """
    if identifier == None:
        if isinstance(sim, EGFRDSimulator):
            return [(st["name"], _get_number_of_particles_by_sid(sim, st.id))
                    for st in sim.world.model.species_types]
        else:
            return sim.stateArray
    else:
        if isinstance(identifier, _gfrd.SpeciesType):
            sid = identifier.id
        #elif isinstance(identifier, str):
        #    sid = _get_species_type_by_name(sim, identifier).id
        else:
            raise RuntimeError('Wrong identifier type.')
        return _get_number_of_particles_by_sid(sim, sid)

def dump_number_of_particles(sim, identifier=None):
    """Return a string containing the number of particles of a certain 
    Species in the simulator.

    Arguments:
        - sim
            either an EGFRDSimulator or a GillespieSimulator.
        - identifier
            a Species. Optional. If none is specified, 
            a string of (Species name, number of particles)-pairs will 
            be returned.

    """
    return str(get_number_of_particles(sim, identifier))

def get_domains(egfrdsim):
    """Return an iterator over the protective domains in the simulator.

    """
    for did, domain in egfrdsim.domains.iteritems():
        shell_list = domain.shell_list
        pid_particle_pair_list = []

        if isinstance(domain, Single):
            pid_particle_pair_list = [domain.pid_particle_pair]
        elif isinstance(domain, Pair):
            pid_particle_pair_list = [
                domain.single1.pid_particle_pair,
                domain.single2.pid_particle_pair]
        elif isinstance(domain, Multi):
            pid_particle_pair_list = []
            for pid_particle_pair in domain.particle_container:
                pid_particle_pair_list.append(pid_particle_pair)

        yield ((did, domain), pid_particle_pair_list, shell_list) 

def dump_domains(egfrdsim):
    """Return an string containing the protective domains in the 
    simulator.

    """
    return '\n'.join((str(domain) for domain in get_domains(egfrdsim)))

def get_reaction_rules(model_or_simulator):
    """Return three lists with all the reaction rules defined in the 
    ParticleModel or EGFRDSimulator.

    The three lists are:
        - reaction rules of only one reactant.
        - reaction rules between two reactants with a reaction rate 
          larger than 0.
        - repulsive reaction rules between two reactants with a 
          reaction rate equal to 0.

    Arguments:
        - model_or_simulator
            a ParticleModel or EGFRDSimulator.

    """
    if isinstance(model_or_simulator, EGFRDSimulator):
        model = model_or_simulator.world.model
    else:
        model = model_or_simulator

    # Return 3 lists with different types of reaction rules. 
    reaction_rules_1 = []
    reaction_rules_2 = []
    repulsive_rules = []

    # Wrap the network_rules first, the iterator over the products 
    # of the unwrapped one fails when there are no products.
    network_rules = _gfrd.NetworkRulesWrapper(model.network_rules)

    for index_of_si1, si1 in enumerate(model.species_types):
        rri_vector = network_rules.query_reaction_rule(si1)
        for rr_info in rri_vector:
            reaction_rules_1.append(rr_info)
        for si2 in list(model.species_types)[index_of_si1:]:
            rri_vector = network_rules.query_reaction_rule(si1, si2)
            for rr_info in rri_vector:
                if rr_info.k > 0:
                    reaction_rules_2.append(rr_info)
                else:
                    repulsive_rules.append(rr_info)

    return reaction_rules_1, reaction_rules_2, repulsive_rules

def _dump_reaction_rule(model, reaction_rule):
    # Helper. Return ReactionRule as string.

    #ReactionRule.__str__ would be good, but we are actually getting a 
    #ReactionRuleInfo or ReactionRuleCache object.
    buf = ('k=%.3g' % reaction_rule.k + ': ').ljust(15)
    for index, sid in enumerate(reaction_rule.reactants):
        if index != 0:
            buf += ' + '
        reactant = model.get_species_type_by_id(sid)
        buf += reactant['name'].ljust(15)
    if len(reaction_rule.products) == 0:
        if reaction_rule.k != 0:
            buf += '..decays'
        else:
            buf += '..reflective'
    else:
        buf += '-> '

    for index, sid in enumerate(reaction_rule.products):
        if index != 0:
            buf += ' + '
        product = model.get_species_type_by_id(sid)
        buf += product['name'].ljust(15)

    return buf + '\n'

def dump_reaction_rules(model_or_simulator):
    """Return a formatted string containing all the reaction rules 
    defined in the ParticleModel or EGFRDSimulator.

    Arguments:
        - model_or_simulator
            a ParticleModel or EGFRDSimulator.

    """
    if isinstance(model_or_simulator, EGFRDSimulator):
        model = model_or_simulator.world.model
    else:
        model = model_or_simulator

    rr1, rr2, rrr = get_reaction_rules(model)

    reaction_rules_1 = [_dump_reaction_rule(model, rule) for rule in rr1]
    reaction_rules_2 = [_dump_reaction_rule(model, rule) for rule in rr2]
    repulsive_rules  = [_dump_reaction_rule(model, rule) for rule in rrr]

    if repulsive_rules == []:
        repulsive_rules_as_string = (
            'None.\n  '
            'An EGFRDSimulator assumes all other possible\n'
            'reaction rules to be repulsive. You can explicitly add\n'
            'these repulsive reaction rules to the model with the\n'
            'method ParticleModel.set_all_repulsive.')
    else:
        repulsive_rules_as_string = ''.join(repulsive_rules)

    return('\nMonomolecular reaction rules:\n' +
           ''.join(reaction_rules_1) +
           '\nBimolecular reaction rules:\n' +
           ''.join(reaction_rules_2) +
           '\nRepulsive bimolecular reaction rules:\n' +
           repulsive_rules_as_string
           )

 </xmp> 
<h3> egfrd.py </h3> <xmp>

#!/usr/env python


from weakref import ref
import math

import numpy

from _gfrd import (
    Event,
    EventScheduler,
    Particle,
    SphericalShell,
    SphericalShellContainer,
    CylindricalShell,
    CylindricalShellContainer,
    DomainIDGenerator,
    ShellIDGenerator,
    DomainID,
    ParticleContainer,
    CuboidalRegion,
    CylindricalSurface,
    PlanarSurface,
    _random_vector,
    Sphere,
    NetworkRulesWrapper,
    )

from gfrdbase import *
from single import *
from pair import *
from multi import *
from utils import *
from constants import *

import logging
import os

from bd import DEFAULT_DT_FACTOR

log = logging.getLogger('ecell')

if __debug__:
    PRECISION = 3
    FORMAT_DOUBLE = '%.' + str(PRECISION) + 'g'

def create_default_single(domain_id, pid_particle_pair, shell_id, rt, surface):
    if isinstance(surface, CuboidalRegion):
        return SphericalSingle(domain_id, pid_particle_pair,
                               shell_id, rt, surface)
    elif isinstance(surface, CylindricalSurface):
        return CylindricalSurfaceSingle(domain_id, pid_particle_pair, 
                                        shell_id, rt, surface)
    elif isinstance(surface, PlanarSurface):
        return PlanarSurfaceSingle(domain_id, pid_particle_pair, 
                                   shell_id, rt, surface)

def create_default_pair(domain_id, com, single1, single2, shell_id, 
                        r0, shell_size, rt, surface):
    if isinstance(surface, CuboidalRegion):
        return SphericalPair(domain_id, com, single1, single2,
                             shell_id, r0, shell_size, rt, surface)
    elif isinstance(surface, CylindricalSurface):
        return CylindricalSurfacePair(domain_id, com, single1, single2,
                                      shell_id, r0, shell_size, rt, surface)
    elif isinstance(surface, PlanarSurface):
        return PlanarSurfacePair(domain_id, com, single1, single2,
                                 shell_id, r0, shell_size, rt, surface)


class DomainEvent(Event):
    __slot__ = ['data']
    def __init__(self, time, domain):
        Event.__init__(self, time)
        self.data = domain

class Delegate(object):
    def __init__(self, obj, method, arg):
        self.ref = ref(obj)
        self.method = method
        self.arg = arg

    def __call__(self):
        return self.method(self.ref(), self.arg)


class EGFRDSimulator(ParticleSimulatorBase):
    """
    """
    def __init__(self, world, rng=myrandom.rng, network_rules=None):
        """Create a new EGFRDSimulator.

        Arguments:
            - world
                a world object created with the function 
                gfrdbase.create_world.
            - rng
                a random number generator. By default myrandom.rng is 
                used, which uses Mersenne Twister from the GSL library.
                You can set the seed of it with the function 
                myrandom.seed.
            - network_rules
                you don't need to use this, for backward compatibility only.

        """
        if network_rules == None:
            network_rules = NetworkRulesWrapper(world.model.network_rules)
        ParticleSimulatorBase.__init__(self, world, rng, network_rules)

        self.domain_id_generator = DomainIDGenerator(0)
        self.shell_id_generator = ShellIDGenerator(0)

        self.MULTI_SHELL_FACTOR = 0.05
        self.SINGLE_SHELL_FACTOR = 1.1

        self.is_dirty = True
        self.scheduler = EventScheduler()

        self.user_max_shell_size = numpy.inf

        self.domains = {}

        self.reset()

    def get_matrix_cell_size(self):
        return self.containers[0].cell_size

    def get_next_time(self):
        if self.scheduler.size == 0:
            return self.t

        return self.scheduler.top[1].time

    def set_user_max_shell_size(self, size):
        self.user_max_shell_size = size

    def get_user_max_shell_size(self):
        return self.user_max_shell_size

    def get_max_shell_size(self):
        return min(self.get_matrix_cell_size() * .5 / SAFETY,
                   self.user_max_shell_size)

    def reset(self):
        self.t = 0.0
        self.dt = 0.0
        self.step_counter = 0
        self.single_steps = {EventType.SINGLE_ESCAPE:0,
                             EventType.SINGLE_REACTION:0}
        self.interaction_steps = {EventType.IV_INTERACTION:0,
                                  EventType.IV_ESCAPE:0}
        self.pair_steps = {EventType.SINGLE_REACTION:0,
                           EventType.IV_REACTION:0,
                           EventType.IV_ESCAPE:0,
                           EventType.COM_ESCAPE:0}
        self.multi_steps = {EventType.MULTI_ESCAPE:0,
                            EventType.MULTI_UNIMOLECULAR_REACTION:0,
                            EventType.MULTI_BIMOLECULAR_REACTION:0, 3:0}
        self.zero_steps = 0
        self.rejected_moves = 0
        self.reaction_events = 0
        self.last_event = None
        self.last_reaction = None

        self.is_dirty = True

    def initialize(self):
        ParticleSimulatorBase.initialize(self)

        self.scheduler.clear()
        self.containers = [SphericalShellContainer(self.world.world_size, 
                                                   self.world.matrix_size),
                           CylindricalShellContainer(self.world.world_size, 
                                                     self.world.matrix_size)]
        self.domains = {}

        singles = []

        # Fix order of adding particles (always, or at least in debug mode).
        pid_particle_pairs = list(self.world)
        pid_particle_pairs.sort()

        for pid_particle_pair in pid_particle_pairs:
            single = self.create_single(pid_particle_pair)
            if __debug__:
                log.debug('%s as single %s' %
                          (pid_particle_pair[0], single.domain_id))
            singles.append(single)
        assert len(singles) == self.world.num_particles
        for single in singles:
            self.add_single_event(single)

        self.is_dirty = False

    def stop(self, t):
        """Synchronize all particles at time t.

        With eGFRD, particle positions are normally updated 
        asynchronously. This method bursts all protective domains and 
        assigns a position to each particle.

        Arguments:
            - t
                the time at which to synchronize the particles. Usually 
                you will want to use the current time of the simulator: 
                EGFRDSimulator.t.

        This method is called stop because it is usually called at the 
        end of a simulation. It is possible to call this method at an 
        earlier time. For example the Logger module does this, because 
        it needs to know the positions of the particles at each log 
        step.

        """
        if __debug__:
            log.info('stop at %s' % (FORMAT_DOUBLE % t))

        if self.t == t:
            return

        if t >= self.scheduler.top[1].time:
            raise RuntimeError('Stop time >= next event time.')

        if t < self.t:
            raise RuntimeError('Stop time < current time.')

        self.t = t

        non_single_list = []

        # first burst all Singles.
        for id, event in self.scheduler:
            obj = event.data
            if isinstance(obj, Pair) or isinstance(obj, Multi):
                non_single_list.append(obj)
            elif isinstance(obj, Single):
                if __debug__:
                    log.debug('burst %s, last_time= %s' % 
                              (obj, FORMAT_DOUBLE % obj.last_time))
                self.burst_single(obj)
            else:
                assert False, 'do not reach here'


        # then burst all Pairs and Multis.
        if __debug__:
            log.debug('burst %s' % non_single_list)
        self.burst_objs(non_single_list)

        self.dt = 0.0

    def step(self):
        """Execute one eGFRD step.

        """
        self.last_reaction = None

        if self.is_dirty:
            self.initialize()
            
        if __debug__:
            if int("0" + os.environ.get("ECELL_CHECK", ""), 10):
                self.check()
        
        self.step_counter += 1

        if __debug__:
            if self.scheduler.size == 0:
                raise RuntimeError('No particles in scheduler.')

        id, event = self.scheduler.pop()
        self.t, self.last_event = event.time, event

        if __debug__:
            domain_counts = self.count_domains()
            log.info('\n\n%d: t=%s dt=%s\t' %
                     (self.step_counter, FORMAT_DOUBLE % self.t,
                      FORMAT_DOUBLE % self.dt) + 
                     'Singles: %d, Pairs: %d, Multis: %d\n' % domain_counts + 
                     'event=#%d reactions=%d rejectedmoves=%d' %
                     (id, self.reaction_events, self.rejected_moves))
       
        for klass, f in self.dispatch:
            if isinstance(event.data, klass):
                f(self, event.data)

        if __debug__:
            if self.scheduler.size == 0:
                raise RuntimeError('Zero particles left.')

        next_time = self.scheduler.top[1].time
        self.dt = next_time - self.t

        # assert if not too many successive dt=0 steps occur.
        if __debug__:
            if self.dt == 0:
                self.zero_steps += 1
                if self.zero_steps >= max(self.scheduler.size * 3, 10):
                    raise RuntimeError('too many dt=zero steps. '
                                       'Simulator halted?')
            else:
                self.zero_steps = 0

    def create_single(self, pid_particle_pair):
        rts = self.network_rules.query_reaction_rule(pid_particle_pair[1].sid)
        domain_id = self.domain_id_generator()
        shell_id = self.shell_id_generator()

        # Get structure (region or surface).
        species = self.world.get_species(pid_particle_pair[1].sid)
        structure = self.world.get_structure(species.structure_id)

        # Create single. The type of the single that will be created 
        # depends on the structure (region or surface) this particle is 
        # in/on. Either SphericalSingle, PlanarSurfaceSingle, or 
        # CylindricalSurfaceSingle.
        single = create_default_single(domain_id, pid_particle_pair, 
                                       shell_id, rts, structure)

        single.initialize(self.t)
        self.move_shell(single.shell_id_shell_pair)
        self.domains[domain_id] = single

        if __debug__:
            # Used in __str__.
            single.world = self.world
        return single

    def create_pair(self, single1, single2, com, r0, shell_size):
        assert single1.dt == 0.0
        assert single2.dt == 0.0

        # Select 1 reaction type out of all possible reaction types.
        rts = self.network_rules.query_reaction_rule(
                single1.pid_particle_pair[1].sid,
                single2.pid_particle_pair[1].sid)
        k_array = numpy.add.accumulate([rt.k for rt in rts])
        k_max = k_array[-1]
        rnd = myrandom.uniform()
        i = numpy.searchsorted(k_array, rnd * k_max)
        rt = rts[i]
        # The probability for this reaction to happen is proportional to 
        # the sum of the rates of all the possible reaction types. 
        rt.ktot = k_max

        domain_id = self.domain_id_generator()
        shell_id = self.shell_id_generator()

        pos1 = single1.shell.shape.position
        pos2 = single2.shell.shape.position

        # Get structure (region or surface).
        species = self.world.get_species(single1.pid_particle_pair[1].sid)
        structure = self.world.get_structure(species.structure_id)

        # Create pair. The type of the pair that will be created depends
        # on the structure (region or surface) the particles are in/on.  
        # Either SphericalPair, PlanarSurfacePair, or 
        # CylindricalSurfacePair.
        pair = create_default_pair(domain_id, com, single1, single2, shell_id, 
                                   r0, shell_size, rt, structure)

        pair.initialize(self.t)

        self.move_shell(pair.shell_id_shell_pair)
        self.domains[domain_id] = pair

        if __debug__:
            # Used in __str__.
            pair.world = self.world

        return pair

    def create_multi(self):
        domain_id = self.domain_id_generator()
        if __debug__:
            try:
                # Option to make multis run faster for nicer visualization.
                dt_factor = DEFAULT_DT_FACTOR * self.bd_dt_factor
            except AttributeError:
                dt_factor = DEFAULT_DT_FACTOR 
        else:
            dt_factor = DEFAULT_DT_FACTOR
        multi = Multi(domain_id, self, dt_factor)
        self.domains[domain_id] = multi
        return multi

    def move_single(self, single, position, radius=None):
        self.move_single_shell(single, position, radius)
        self.move_single_particle(single, position)

    def move_single_shell(self, single, position, radius=None):
        if radius == None:
            # By default, don't change radius.
            radius = single.shell.shape.radius

        # Reuse shell_id and domain_id.
        shell_id = single.shell_id
        domain_id = single.domain_id

        # Replace shell.
        shell = single.create_new_shell(position, radius, domain_id)
        shell_id_shell_pair = (shell_id, shell) 

        single.shell_id_shell_pair = shell_id_shell_pair
        self.move_shell(shell_id_shell_pair)

    def move_single_particle(self, single, position):
        new_pid_particle_pair = (single.pid_particle_pair[0],
                          Particle(position,
                                   single.pid_particle_pair[1].radius,
                                   single.pid_particle_pair[1].D,
                                   single.pid_particle_pair[1].sid))
        single.pid_particle_pair = new_pid_particle_pair

        self.world.update_particle(new_pid_particle_pair)

    def get_container(self, shell):
        if type(shell) is SphericalShell:
            return self.containers[0]
        elif type(shell) is CylindricalShell:
            return self.containers[1]

    def remove_domain(self, obj):
        if __debug__:
            log.info("remove: %s" % obj)
        del self.domains[obj.domain_id]
        for shell_id, shell in obj.shell_list:
            container = self.get_container(shell)
            del container[shell_id]

    def move_shell(self, shell_id_shell_pair):
        shell = shell_id_shell_pair[1]
        container = self.get_container(shell)
        container.update(shell_id_shell_pair)

    def add_single_event(self, single):
        event_id = self.scheduler.add(
            DomainEvent(self.t + single.dt, single))
        if __debug__:
            log.info('add_event: %s, event=#%d, t=%s' %
                     (single.domain_id, event_id,
                      FORMAT_DOUBLE % (self.t + single.dt)))
        single.event_id = event_id

    def add_pair_event(self, pair):
        event_id = self.scheduler.add(
            DomainEvent(self.t + pair.dt, pair))
        if __debug__:
            log.info('add_event: %s, event=#%d, t=%s' %
                     (pair.domain_id, event_id,
                      FORMAT_DOUBLE % (self.t + pair.dt)))
        pair.event_id = event_id

    def add_multi_event(self, multi):
        event_id = self.scheduler.add(
            DomainEvent(self.t + multi.dt, multi))

        if __debug__:
            log.info('add_event: %s, event=#%d, t=%s' %
                     (multi.domain_id, event_id,
                      FORMAT_DOUBLE % (self.t + multi.dt)))
        multi.event_id = event_id

    def remove_event(self, event):
        if __debug__:
            log.info('remove_event: event=#%d' % event.event_id)
        del self.scheduler[event.event_id]

    def update_single_event(self, t, single):
        if __debug__:
            log.info('update_event: %s, event=#%d, t=%s' %
                     (single.domain_id, single.event_id, FORMAT_DOUBLE % t))
        self.scheduler.update((single.event_id, DomainEvent(t, single)))

    def update_multi_event(self, t, multi):
        if __debug__:
            log.info('update_event: %s, event=#%d, t=%s' %
                     (multi.domain_id, multi.event_id, FORMAT_DOUBLE % t))
        self.scheduler.update((multi.event_id, DomainEvent(t, multi)))

    def burst_obj(self, obj):
        if __debug__:
            log.info('burst_obj: %s' % obj)

        if isinstance(obj, Single):
            # TODO. Compare with gfrd.
            obj = self.burst_single(obj)
            bursted = [obj, ]
        elif isinstance(obj, Pair):  # Pair
            single1, single2 = self.burst_pair(obj)
            # Don't schedule events in burst/propagate_pair, because 
            # scheduling is different after a single reaction in 
            # fire_pair.
            self.add_single_event(single1)
            self.add_single_event(single2)
            self.remove_event(obj)
            bursted = [single1, single2]
        else:  # Multi
            bursted = self.burst_multi(obj)
            self.remove_event(obj)

        if __debug__:
            log.info('bursted = %s' % ',\n\t  '.join(str(i) for i in bursted))

        return bursted

    def burst_objs(self, objs):
        bursted = []
        for obj in objs:
            b = self.burst_obj(obj)
            bursted.extend(b)

        return bursted

    def clear_volume(self, pos, radius, ignore=[]):
        neighbors = self.get_neighbors_within_radius_no_sort(pos, radius,
                                                             ignore)
        return self.burst_objs(neighbors)

    def burst_non_multis(self, neighbors):
        bursted = []

        for obj in neighbors:
            if not isinstance(obj, Multi):
                b = self.burst_obj(obj)
                bursted.extend(b)
            else:
                bursted.append(obj)

        return bursted

    def fire_single_reaction(self, single):
        reactant_species_radius = single.pid_particle_pair[1].radius
        oldpos = single.pid_particle_pair[1].position
        current_surface = single.surface
        
        rt = single.draw_reaction_rule()

        if len(rt.products) == 0:
            
            self.world.remove_particle(single.pid_particle_pair[0])

            self.last_reaction = (rt, (single.pid_particle_pair[1], None), [])

            
        elif len(rt.products) == 1:
            
            product_species = self.world.get_species(rt.products[0])

            if reactant_species_radius < product_species.radius:
                self.clear_volume(oldpos, product_species.radius)

            if self.world.check_overlap((oldpos, product_species.radius),
                                        single.pid_particle_pair[0]):
                if __debug__:
                    log.info('no space for product particle.')
                raise NoSpace()

            self.world.remove_particle(single.pid_particle_pair[0])
            newparticle = self.world.new_particle(product_species.id, oldpos)
            newsingle = self.create_single(newparticle)
            if __debug__:
                log.info('product = %s' % newsingle)
            self.add_single_event(newsingle)

            self.last_reaction = (rt, (single.pid_particle_pair[1], None),
                                  [newparticle])


            
        elif len(rt.products) == 2:
            product_species1 = self.world.get_species(rt.products[0])
            product_species2 = self.world.get_species(rt.products[1])
            
            D1 = product_species1.D
            D2 = product_species2.D
            D12 = D1 + D2
            
            particle_radius1 = product_species1.radius
            particle_radius2 = product_species2.radius
            particle_radius12 = particle_radius1 + particle_radius2

            # clean up space.
            rad = max(particle_radius12 * (D1 / D12) + particle_radius1,
                      particle_radius12 * (D2 / D12) + particle_radius2)

            self.clear_volume(oldpos, rad)

            for _ in range(self.dissociation_retry_moves):
                vector = _random_vector(current_surface, particle_radius12 *
                                        MINIMAL_SEPARATION_FACTOR, self.rng)
            
                # place particles according to the ratio D1:D2
                # this way, species with D=0 doesn't move.
                # FIXME: what if D1 == D2 == 0?

                while 1:
                    newpos1 = oldpos + vector * (D1 / D12)
                    newpos2 = oldpos - vector * (D2 / D12)
                    newpos1 = self.world.apply_boundary(newpos1)
                    newpos2 = self.world.apply_boundary(newpos2)

                    if(self.world.distance(newpos1, newpos2) >= 
                       particle_radius12):
                        break

                    vector *= 1.0 + 1e-7


                # accept the new positions if there is enough space.
                if(not self.world.check_overlap((newpos1, particle_radius1),
                                                 single.pid_particle_pair[0])
                   and
                   not self.world.check_overlap((newpos2, particle_radius2),
                                                 single.pid_particle_pair[0])):
                    break
            else:
                if __debug__:
                    log.info('no space for product particles.')
                raise NoSpace()

            self.world.remove_particle(single.pid_particle_pair[0])

            particle1 = self.world.new_particle(product_species1.id, newpos1)
            particle2 = self.world.new_particle(product_species2.id, newpos2)
            newsingle1 = self.create_single(particle1)
            newsingle2 = self.create_single(particle2)

            if __debug__:
                log.info('product1 = %s\nproduct2 = %s' % 
                     (newsingle1, newsingle2))

            self.add_single_event(newsingle1)
            self.add_single_event(newsingle2)

            self.last_reaction = (rt, (single.pid_particle_pair[1], None),
                                  [particle1, particle2])


        else:
            raise RuntimeError('num products >= 3 not supported.')

        self.reaction_events += 1

    def propagate_single(self, single):
        # The difference between a burst and a propagate is that a burst 
        # always takes place before the actual scheduled event for the 
        # single, while propagate_single can be called for an escape event.

        # Another subtle difference is that burst_single always 
        # reschedules (update_event) the single, while just calling 
        # propagate does not.  So whoever calls propagate_single 
        # directly should reschedule the single afterwards.
        if __debug__:
            log.debug("single.dt=%s, single.last_time=%s, self.t=%s" %
                      (FORMAT_DOUBLE % single.dt,
                       FORMAT_DOUBLE % single.last_time,
                       FORMAT_DOUBLE % self.t))

        newpos = single.draw_new_position(single.dt, single.event_type) 
        newpos = self.world.apply_boundary(newpos)

        if __debug__:
            log.debug("propagate %s: %s => %s" %
                      (single, single.pid_particle_pair[1].position, newpos))

            if self.world.check_overlap((newpos,
                                        single.pid_particle_pair[1].radius),
                                        single.pid_particle_pair[0]):
                raise RuntimeError('propagate_single: check_overlap failed.')

        if(single.event_type == EventType.SINGLE_REACTION and
           single.event_type != EventType.BURST):
            # SINGLE_REACTION, and not a burst. No need to update, single is 
            # removed anyway.
            self.move_single_particle(single, newpos)
            return single
        else:
            # Todo. if isinstance(single, InteractionSingle):
            single.initialize(self.t)
            self.move_single(single, newpos,
                             single.pid_particle_pair[1].radius)

            return single

    def fire_single(self, single):
        assert abs(single.dt + single.last_time - self.t) <= 1e-18 * self.t

        # Reaction.
        if single.event_type == EventType.SINGLE_REACTION:
            if __debug__:
                log.info('%s' % single.event_type)
                log.info('reactant = %s' % single)

            self.single_steps[single.event_type] += 1


            single = self.propagate_single(single)

            try:
                self.remove_domain(single)
                self.fire_single_reaction(single)
            except NoSpace:
                self.reject_single_reaction(single)

            return

        if single.event_type == EventType.IV_EVENT:
            # Draw actual pair event for iv at very last minute.
            single.event_type = single.draw_iv_event_type()
            self.interaction_steps[single.event_type] += 1
        else:
            self.single_steps[single.event_type] += 1

        if __debug__:
            log.info('%s' % single.event_type)
            log.info('single = %s' % single)

        # Handle immobile case first.
        if single.getD() == 0:
            # no propagation, just calculate next reaction time.
            single.dt, single.event_type = single.determine_next_event() 
            single.last_time = self.t
            self.add_single_event(single)
            return
        
        if single.dt != 0.0:
            # Propagate this particle to the exit point on the shell.
            single = self.propagate_single(single)

        singlepos = single.shell.shape.position

        # (2) Clear volume.

        min_shell = single.pid_particle_pair[1].radius * \
                    self.SINGLE_SHELL_FACTOR

        intruders, closest, closest_distance = \
            self.get_intruders(singlepos, min_shell,
                               ignore=[single.domain_id, ])

        if __debug__:
            log.debug("intruders: %s, closest: %s (dist=%s)" %
                      (', '.join(str(i) for i in intruders),
                       closest, FORMAT_DOUBLE % closest_distance))

        if intruders:
            burst = self.burst_non_multis(intruders)

            obj = self.form_pair_or_multi(single, burst)

            if obj:
                return

            # if nothing was formed, recheck closest and restore shells.
            burst = uniq(burst)

            closest, closest_distance = \
                self.get_closest_obj(singlepos, ignore=[single.domain_id],
                                     ignores=[single.surface.id])
            self.update_single(single, closest, closest_distance)
            for s in burst:
                if not isinstance(s, Single):
                    continue
                assert s.is_reset()
                closest, closest_distance = self.get_closest_obj(
                    s.shell.shape.position, ignore=[s.domain_id],
                    ignores=[s.surface.id])

                self.update_single(s, closest, closest_distance)
                self.update_single_event(self.t + s.dt, s)
                if __debug__:
                    log.debug('restore shell %s radius %s dt %s\n'
                              'closest %s distance %s' %
                              (s, FORMAT_DOUBLE % s.shell.shape.radius,
                               FORMAT_DOUBLE % s.dt, closest,
                               FORMAT_DOUBLE % closest_distance))
        else:
            self.update_single(single, closest, closest_distance)
            
        if __debug__:
            log.info('updated shell: (%s,\n  Shell(%s, %s)' %
                     (single.shell_id, single.shell.did,
                      single.shell.shape.show(PRECISION)))

        self.add_single_event(single)
        return

    def reject_single_reaction(self, single):
        if __debug__:
            log.info('single reaction; placing product failed.')
        self.domains[single.domain_id] = single
        self.move_shell(single.shell_id_shell_pair)
        self.rejected_moves += 1
        single.initialize(self.t)
        self.add_single_event(single)

    def calculate_single_shell_size(self, single, closest, 
                                 distance, shell_distance):
        assert isinstance(closest, Single)

        min_radius1 = single.pid_particle_pair[1].radius
        D1 = single.getD()

        if D1 == 0:
            return min_radius1

        D2 = closest.getD()
        min_radius2 = closest.pid_particle_pair[1].radius
        min_radius12 = min_radius1 + min_radius2
        sqrtD1 = math.sqrt(D1)
            
        shell_size = min(sqrtD1 / (sqrtD1 + math.sqrt(D2))
                        * (distance - min_radius12) + min_radius1,
                        shell_distance / SAFETY)
        if shell_size < min_radius1:
            shell_size = min_radius1

        return shell_size

    def update_single(self, single, closest, distance_to_shell): 
        # Todo. assert not isinstance(single, InteractionSingle)

        singlepos = single.shell.shape.position
        if isinstance(closest, Single):
            closestpos = closest.shell.shape.position
            distance_to_closest = self.world.distance(singlepos, closestpos)
            new_shell_size = self.calculate_single_shell_size(single, closest, 
                                                      distance_to_closest,
                                                      distance_to_shell)
        else:  # Pair or Multi or Surface
            new_shell_size = distance_to_shell / SAFETY
            new_shell_size = max(new_shell_size,
                                 single.pid_particle_pair[1].radius)

        new_shell_size = min(new_shell_size, self.get_max_shell_size())

        # Resize shell, don't change position.
        # Note: this should be done before determine_next_event.
        self.move_single_shell(single, singlepos, new_shell_size)        

        single.dt, single.event_type = single.determine_next_event()
        single.last_time = self.t

    def fire_pair(self, pair):
        assert self.check_obj(pair)

        single1 = pair.single1
        single2 = pair.single2
        particle1 = single1.pid_particle_pair
        particle2 = single2.pid_particle_pair
        pos1 = particle1[1].position
        pos2 = particle2[1].position
        
        if pair.event_type == EventType.IV_EVENT:
            # Draw actual pair event for iv at very last minute.
            r0 = self.world.distance(pos1, pos2)
            pair.event_type = pair.draw_iv_event_type(r0)

        self.pair_steps[pair.event_type] += 1

        if __debug__:
            log.info('FIRE PAIR: %s' % pair.event_type)
            log.info('single1 = %s' % pair.single1)
            log.info('single2 = %s' % pair.single2)


        old_com = pair.com

        # Four cases:
        #  1. Single reaction
        #  2. Pair reaction
        #  3a. IV escape
        #  3b. com escape

        #
        # 1. Single reaction
        #
        if pair.event_type == EventType.SINGLE_REACTION:
            reactingsingle = pair.reactingsingle

            if reactingsingle == single1:
                theothersingle = single2
            else:
                theothersingle = single1

            self.burst_pair(pair)

            self.add_single_event(theothersingle)

            if __debug__:
                log.info('reactant = %s' % reactingsingle)
            try:
                self.remove_domain(reactingsingle)
                self.fire_single_reaction(reactingsingle)
            except NoSpace:
                self.reject_single_reaction(reactingsingle)

            return
        
        #
        # 2. Pair reaction
        #
        if pair.event_type == EventType.IV_REACTION:
            self.world.remove_particle(single1.pid_particle_pair[0])
            self.world.remove_particle(single2.pid_particle_pair[0])

            if len(pair.rt.products) == 1:
                species3 = self.world.get_species(pair.rt.products[0])

                # calculate new R
                event_type = pair.event_type
                new_com = pair.draw_new_com(pair.dt, event_type)

                if __debug__:
                    shell_size = pair.get_shell_size()
                    assert self.world.distance(old_com, new_com) < \
                           shell_size - species3.radius

                new_com = self.world.apply_boundary(new_com)

                particle = self.world.new_particle(species3.id, new_com)
                product = self.create_single(particle)
                self.add_single_event(product)

                self.reaction_events += 1

                self.last_reaction = (pair.rt, (particle1, particle2),
                                      [particle])
            elif len(pair.rt.products) == 0:
                product = []
            else:
                raise NotImplementedError('num products >= 2 not supported.')

            if __debug__:
                log.info('product = %s' % product)
            self.remove_domain(pair)

            return

        #
        # 3a. Escaping through a_r.
        # 3b. Escaping through a_R.
        #
        elif(pair.event_type == EventType.IV_ESCAPE or
             pair.event_type == EventType.COM_ESCAPE):
            dt = pair.dt
            event_type = pair.event_type
            single1, single2 = self.propagate_pair(pair, dt, event_type)
            self.add_single_event(single1)
            self.add_single_event(single2)
        else:
            raise SystemError('Bug: invalid event_type.')

        return

    def fire_multi(self, multi):
        self.multi_steps[3] += 1  # multi_steps[3]: total multi steps
        multi.step()

        if __debug__:
            log.info('FIRE MULTI: %s' % multi.last_event)

        if(multi.last_event == EventType.MULTI_UNIMOLECULAR_REACTION or
           multi.last_event == EventType.MULTI_BIMOLECULAR_REACTION):
            self.reaction_events += 1
            self.last_reaction = multi.last_reaction

        if multi.last_event is not None:
            self.break_up_multi(multi)
            self.multi_steps[multi.last_event] += 1
        else:
            self.add_multi_event(multi)

    def break_up_multi(self, multi):
        self.remove_domain(multi)

        singles = []
        for pid_particle_pair in multi.particles:
            single = self.create_single(pid_particle_pair)
            self.add_single_event(single)
            singles.append(single)

        return singles

    def burst_multi(self, multi):
        #multi.sim.sync()
        assert isinstance(multi, Multi)
        singles = self.break_up_multi(multi)

        return singles

    def burst_single(self, single):
        assert self.t >= single.last_time
        assert self.t <= single.last_time + single.dt

        oldpos = single.shell.shape.position
        old_shell_size = single.get_shell_size()

        particle_radius = single.pid_particle_pair[1].radius

        # Override dt, burst happens before single's scheduled event.
        single.dt = self.t - single.last_time
        # Override event_type. Always call gf.drawR on BURST.
        single.event_type = EventType.BURST
        newsingle = self.propagate_single(single)

        newpos = newsingle.pid_particle_pair[1].position
        assert self.world.distance(newpos, oldpos) <= \
               old_shell_size - particle_radius
        # Displacement check is in NonInteractionSingle.draw_new_position.

        # Todo. if isinstance(single, InteractionSingle):
        self.update_single_event(self.t, single)

        assert newsingle.shell.shape.radius == particle_radius

        # Returned single is different from original single in the case 
        # of an InteractionSingle only.
        return newsingle

    def burst_pair(self, pair):
        if __debug__:
            log.debug('burst_pair: %s', pair)

        assert self.t >= pair.last_time
        assert self.t <= pair.last_time + pair.dt

        dt = self.t - pair.last_time 
        # Override event_type. Always call sgf.drawR and pgf.drawR on BURST.
        event_type = EventType.BURST
        single1, single2 = self.propagate_pair(pair, dt, event_type)

        return single1, single2

    def propagate_pair(self, pair, dt, event_type):
        single1 = pair.single1
        single2 = pair.single2

        particle1 = single1.pid_particle_pair
        particle2 = single2.pid_particle_pair

        pos1 = particle1[1].position
        pos2 = particle2[1].position

        if dt > 0.0:
            D1 = particle1[1].D
            D2 = particle2[1].D

            pos2t = self.world.cyclic_transpose(pos2, pos1)
            old_inter_particle = pos2t - pos1
            r0 = self.world.distance(pos1, pos2)
            assert feq(r0, length(old_inter_particle))

            old_com = pair.com

            newpos1, newpos2 = pair.draw_new_positions(dt, r0, 
                                                     old_inter_particle, 
                                                     event_type)

            newpos1 = self.world.apply_boundary(newpos1)
            newpos2 = self.world.apply_boundary(newpos2)
            assert not self.world.check_overlap((newpos1, particle1[1].radius),
                                                particle1[0], particle2[0])
            assert not self.world.check_overlap((newpos2, particle2[1].radius),
                                                particle1[0], particle2[0])
            assert self.check_pair_pos(pair, newpos1, newpos2, old_com,
                                       pair.get_shell_size())
        else:
            newpos1 = particle1[1].position
            newpos2 = particle2[1].position

        if __debug__:
            log.debug("fire_pair: #1 { %s: %s => %s }" %
                      (single1, pos1, newpos1))
            log.debug("fire_pair: #2 { %s: %s => %s }" %
                      (single2, str(pos2), str(newpos2)))

        single1.initialize(self.t)
        single2.initialize(self.t)
        
        self.remove_domain(pair)
        assert single1.domain_id not in self.domains
        assert single2.domain_id not in self.domains
        self.domains[single1.domain_id] = single1
        self.domains[single2.domain_id] = single2
        self.move_single(single1, newpos1, particle1[1].radius)
        self.move_single(single2, newpos2, particle2[1].radius)

        if __debug__:
            container = self.get_container(single1.shell)
            assert container[single1.shell_id].shape.radius == \
                   single1.shell.shape.radius
            assert container[single2.shell_id].shape.radius == \
                   single2.shell.shape.radius

            if type(single1.shell) is CylindricalShell:
                assert container[single1.shell_id].shape.half_length == \
                       single1.shell.shape.half_length
                assert container[single2.shell_id].shape.half_length == \
                       single2.shell.shape.half_length

        assert single1.shell.shape.radius == particle1[1].radius
        assert single2.shell.shape.radius == particle2[1].radius

        assert self.check_obj(single1)
        assert self.check_obj(single2)

        return single1, single2

    def form_pair_or_multi(self, single, neighbors):
        assert neighbors

        singlepos = single.shell.shape.position

        # sort burst neighbors by distance
        dists = self.obj_distance_array(singlepos, neighbors)
        if len(dists) >= 2:
            n = dists.argsort()
            dists = dists.take(n)
            neighbors = numpy.take(neighbors, n)

        # First, try forming a Pair.
        if isinstance(neighbors[0], Single):
            obj = self.form_pair(single, singlepos,
                                 neighbors[0], neighbors[1:])
            if obj:
                return obj

        # If a Pair is not formed, then try forming a Multi.
        obj = self.form_multi(single, neighbors, dists)
        if obj:
            return obj


    def form_pair(self, single1, pos1, single2, burst):
        if __debug__:
           log.debug('trying to form Pair(%s, %s)' %
                     (single1.pid_particle_pair, single2.pid_particle_pair))

        assert single1.is_reset()
        assert single2.is_reset()

        # 1. Determine min shell size.
        radius1 = single1.pid_particle_pair[1].radius
        radius2 = single2.pid_particle_pair[1].radius

        sigma = radius1 + radius2

        D1 = single1.pid_particle_pair[1].D
        D2 = single2.pid_particle_pair[1].D
        D12 = D1 + D2

        assert (pos1 - single1.shell.shape.position).sum() == 0
        pos2 = single2.shell.shape.position
        r0 = self.world.distance(pos1, pos2)
        distance_from_sigma = r0 - sigma
        assert distance_from_sigma >= 0, \
            'distance_from_sigma (pair gap) between %s and %s = %s < 0' % \
            (single1, single2, FORMAT_DOUBLE % distance_from_sigma)

        shell_size1 = r0 * D1 / D12 + radius1
        shell_size2 = r0 * D2 / D12 + radius2
        shell_size_margin1 = radius1 * 2
        shell_size_margin2 = radius2 * 2
        shell_size_with_margin1 = shell_size1 + shell_size_margin1
        shell_size_with_margin2 = shell_size2 + shell_size_margin2
        if shell_size_with_margin1  >= shell_size_with_margin2:
            min_shell_size = shell_size1
            shell_size_margin = shell_size_margin1
        else:
            min_shell_size = shell_size2
            shell_size_margin = shell_size_margin2

        # 2. Check if min shell size not larger than max shell size or 
        # sim cell size.
        com = self.world.calculate_pair_CoM(pos1, pos2, D1, D2)
        com = self.world.apply_boundary(com)
        min_shell_size_with_margin = min_shell_size + shell_size_margin
        max_shell_size = min(self.get_max_shell_size(),
                             distance_from_sigma * 100 +
                             sigma + shell_size_margin)

        if min_shell_size_with_margin >= max_shell_size:
            if __debug__:
                log.debug('%s not formed: min_shell_size %s >='
                          'max_shell_size %s' %
                          ('Pair(%s, %s)' % (single1.pid_particle_pair[0], 
                                             single2.pid_particle_pair[0]),
                           FORMAT_DOUBLE % min_shell_size_with_margin,
                           FORMAT_DOUBLE % max_shell_size))
            return None

        # 3. Check if bursted Singles not too close.
        # The simple check for closest below could miss
        # some of them, because sizes of these Singles for this
        # distance check has to include SINGLE_SHELL_FACTOR, while
        # these burst objects have zero mobility radii.  This is not
        # beautiful, a cleaner framework may be possible.

        closest, closest_shell_distance = None, numpy.inf
        for b in burst:
            if isinstance(b, Single):
                bpos = b.shell.shape.position
                d = self.world.distance(com, bpos) - \
                    b.pid_particle_pair[1].radius * self.SINGLE_SHELL_FACTOR
                if d < closest_shell_distance:
                    closest, closest_shell_distance = b, d

        if closest_shell_distance <= min_shell_size_with_margin:
            if __debug__:
                log.debug('%s not formed: squeezed by burst neighbor %s' %
                          ('Pair(%s, %s)' % (single1.pid_particle_pair[0], 
                                             single2.pid_particle_pair[0]),
                           closest))
            return None

        assert closest_shell_distance > 0

        # 4. Determine shell size and check if closest object not too 
        # close (squeezing).
        c, d = self.get_closest_obj(com, ignore=[single1.domain_id,
                                                 single2.domain_id],
                                    ignores=[single1.surface.id])
        if d < closest_shell_distance:
            closest, closest_shell_distance = c, d

        if __debug__:
            log.debug('Pair closest neighbor: %s %s, '
                      'min_shell_with_margin %s' %
                      (closest, FORMAT_DOUBLE % closest_shell_distance,
                       FORMAT_DOUBLE % min_shell_size_with_margin))

        assert closest_shell_distance > 0

        if isinstance(closest, Single):

            D_closest = closest.pid_particle_pair[1].D
            D_tot = D_closest + D12
            closest_particle_distance = self.world.distance(
                    com, closest.pid_particle_pair[1].position)

            closest_min_radius = closest.pid_particle_pair[1].radius
            closest_min_shell = closest_min_radius * self.SINGLE_SHELL_FACTOR

            # options for shell size:
            # a. ideal shell size
            # b. closest shell is from a bursted single
            # c. closest shell is closer than ideal shell size 
            shell_size = min((D12 / D_tot) *
                            (closest_particle_distance - min_shell_size 
                             - closest_min_radius) + min_shell_size,
                            closest_particle_distance - closest_min_shell,
                            closest_shell_distance)

            shell_size /= SAFETY
            assert shell_size < closest_shell_distance

        else:
            assert isinstance(closest, (Pair, Multi, None.__class__))

            shell_size = closest_shell_distance / SAFETY

        if shell_size <= min_shell_size_with_margin:
            if __debug__:
                log.debug('%s not formed: squeezed by %s' %
                          ('Pair(%s, %s)' % (single1.pid_particle_pair[0], 
                                             single2.pid_particle_pair[0]),
                           closest))
            return None


        # 5. Check if singles would not be better.
        d1 = self.world.distance(com, pos1)
        d2 = self.world.distance(com, pos2)

        if shell_size < max(d1 + single1.pid_particle_pair[1].radius *
                            self.SINGLE_SHELL_FACTOR, \
                            d2 + single2.pid_particle_pair[1].radius * \
                            self.SINGLE_SHELL_FACTOR) * 1.3:
            if __debug__:
                log.debug('%s not formed: singles are better' %
                          'Pair(%s, %s)' % (single1.pid_particle_pair[0], 
                                            single2.pid_particle_pair[0]))
            return None

        # 6. Ok, Pair makes sense. Create one.
        shell_size = min(shell_size, max_shell_size)

        pair = self.create_pair(single1, single2, com, r0, shell_size)

        pair.dt, pair.event_type, pair.reactingsingle = \
            pair.determine_next_event(r0)

        assert pair.dt >= 0

        self.last_time = self.t

        self.remove_domain(single1)
        self.remove_domain(single2)

        # single1 will be removed by the scheduler.
        self.remove_event(single2)

        assert closest_shell_distance == numpy.inf or \
               shell_size < closest_shell_distance
        assert shell_size >= min_shell_size_with_margin
        assert shell_size <= max_shell_size

        if __debug__:
            log.info('%s,\ndt=%s, r0=%s, shell_size=%s, '
                     'closest_shell_distance=%s,\nclosest = %s' %
                     (pair, FORMAT_DOUBLE % pair.dt, FORMAT_DOUBLE % r0, 
                      FORMAT_DOUBLE % shell_size, 
                      FORMAT_DOUBLE % closest_shell_distance, closest))

        assert self.check_obj(pair)
        self.add_pair_event(pair)

        return pair
    

    def form_multi(self, single, neighbors, dists):

        min_shell = single.pid_particle_pair[1].radius * \
                    (1.0 + self.MULTI_SHELL_FACTOR)
        # Multis shells need to be contiguous.
        if dists[0] > min_shell:
            return None

        neighbors = [neighbors[i] for i in (dists <= min_shell).nonzero()[0]]

        closest = neighbors[0]

        # if the closest to this Single is a Single, create a new Multi
        if isinstance(closest, Single):

            multi = self.create_multi()
            self.add_to_multi(single, multi)
            self.remove_domain(single)
            for neighbor in neighbors:
                self.add_to_multi_recursive(neighbor, multi)

            multi.initialize(self.t)
            
            self.add_multi_event(multi)

            return multi

        # if the closest to this Single is a Multi, reuse the Multi.
        elif isinstance(closest, Multi):

            multi = closest
            self.add_to_multi(single, multi)
            self.remove_domain(single)
            for neighbor in neighbors[1:]:
                self.add_to_multi_recursive(neighbor, multi)

            multi.initialize(self.t)

            self.update_multi_event(self.t + multi.dt, multi)

            return multi


        assert False, 'do not reach here'


    def add_to_multi_recursive(self, obj, multi):
        if isinstance(obj, Single):
            if multi.has_particle(obj.pid_particle_pair[0]):
                # Already in the Multi.
                return
            assert obj.is_reset()
            objpos = obj.shell.shape.position
            
            self.add_to_multi(obj, multi)
            self.remove_domain(obj)
            self.remove_event(obj)

            radius = obj.pid_particle_pair[1].radius * \
                (1.0 + self.MULTI_SHELL_FACTOR)
            neighbors = self.get_neighbors_within_radius_no_sort(
                    objpos, radius, ignore=[obj.domain_id])

            burst = self.burst_non_multis(neighbors)
            neighbor_dists = self.obj_distance_array(objpos, burst)
            neighbors = [burst[i] for i
                                  in (neighbor_dists <= radius).nonzero()[0]]

            for obj in neighbors:
                self.add_to_multi_recursive(obj, multi)

        elif isinstance(obj, Multi):
            for pp in multi.particles:
                if obj.has_particle(pp[0]):
                    if __debug__:
                        log.debug('%s already added. skipping.' % obj)
                    break
            else:
                self.merge_multis(obj, multi)
        else:
            assert False, 'do not reach here.'  # Pairs are burst

    def new_spherical_shell(self, domain_id, pos, size):
        shell_id_shell_pair = (
            self.shell_id_generator(),
            SphericalShell(domain_id, Sphere(pos, size)))
        self.move_shell(shell_id_shell_pair)
        return shell_id_shell_pair

    def add_to_multi(self, single, multi):
        if __debug__:
            log.info('add to multi:\n  %s\n  %s' % (single, multi))

        sid_shell_pair = self.new_spherical_shell(
            multi.domain_id,
            single.pid_particle_pair[1].position,
            single.pid_particle_pair[1].radius * \
                (1.0 + self.MULTI_SHELL_FACTOR))
        multi.add_shell(sid_shell_pair)
        multi.add_particle(single.pid_particle_pair)

    def merge_multis(self, multi1, multi2):
        # merge multi1 into multi2. multi1 will be removed.
        if __debug__:
            log.info('merging %s to %s' % (multi1.domain_id, multi2.domain_id))
            log.info('  %s' % multi1)
            log.info('  %s' % multi2)

            try:
                particle_of_multi1 = iter(multi1.particle_container).next()
                assert particle_of_multi1[0] not in \
                        multi2.particle_container
            except:
                pass

        for sid_shell_pair in multi1.shell_list:
            sid_shell_pair[1].did = multi2.domain_id
            self.move_shell(sid_shell_pair)
            multi2.add_shell(sid_shell_pair)

        for pid_particle_pair in multi1.particles:
            multi2.add_particle(pid_particle_pair)

        del self.domains[multi1.domain_id]
        self.remove_event(multi1)

    def get_neighbors_within_radius_no_sort(self, pos, radius, ignore=[]):
        # Get neighbor domains within given radius.
        #
        # ignore: domain ids.
        #
        # Only returns neighbors, not the distances towards their 
        # shells. Can for example be used to try to clear all objects 
        # from a certain volume.

        for container in self.containers:
            result = container.get_neighbors_within_radius(pos, radius)
            # result = [((shell_id_shell_pair), distance), ]
            # Since a domain can have more than 1 shell (multis for 
            # example), and for each shell there is an entry in the 
            # shell container, we make sure each domain occurs only once 
            # in the returned list here.
            for did in uniq(s[0][1].did for s in result):
                if did not in ignore:
                    yield self.domains[did]

    def get_intruders(self, position, radius, ignore):
        intruders = []   # intruders are domains within radius
        closest_domain = None   # closest domain, excluding intruders.
        closest_distance = numpy.inf # distance to the shell of the closest.

        seen = set(ignore)
        for container in self.containers:
            neighbors = container.get_neighbors(position)
            for n in neighbors:
                domain_id = n[0][1].did
                distance = n[1]
                if distance > radius:
                    if distance < closest_distance:
                        # This is domain (the first one for this 
                        # container) that has a shell that is more than 
                        # radius away from pos.  If it is closer than 
                        # the closest such one we found so far: store 
                        # it. Always break out of the inner for loop and 
                        # check the other containers.
                        closest_domain = self.domains[domain_id]
                        closest_distance = distance
                        break
                    else:
                        break
                elif domain_id not in seen:
                    # Since a domain can have more than 1 shell (multis 
                    # for example), and for each shell there is an entry 
                    # in the shell container, we make sure each domain 
                    # occurs only once in the returned list here.
                    seen.add(domain_id)
                    intruders.append(self.domains[domain_id])

        return intruders, closest_domain, closest_distance

    def get_closest_obj(self, pos, ignore=[], ignores=[]):
        # ignore: domain ids.
        closest_domain = None
        closest_distance = numpy.inf

        for container in self.containers:
            result = container.get_neighbors(pos)

            for shell_id_shell_pair, distance in result:
                domain_id = shell_id_shell_pair[1].did 

                if domain_id not in ignore and distance < closest_distance:
                    domain = self.domains[domain_id]
                    closest_domain, closest_distance = domain, distance
                    # Found yet a closer domain. Break out of inner for 
                    # loop and check other containers.
                    break   

        surface, distance = get_closest_surface(self.world, pos, ignores)

        if distance < closest_distance:
            return surface, distance
        else:
            return closest_domain, closest_distance

    def obj_distance(self, pos, obj):
        return min(self.world.distance(shell.shape, pos)
                   for i, (_, shell) in enumerate(obj.shell_list))

    def obj_distance_array(self, pos, objs):
        dists = numpy.array([self.obj_distance(pos, obj) for obj in objs])
        return dists
            

    #
    # statistics reporter
    #

    def print_report(self, out=None):
        """Print various statistics about the simulation.
        
        Arguments:
            - None

        """
        report = '''
t = %g
steps = %d 
\tSingle:\t%d\t(escape: %d, reaction: %d)
\tInteraction: %d\t(escape: %d, interaction: %d)
\tPair:\t%d\t(escape r: %d, R: %d, reaction pair: %d, single: %d)
\tMulti:\t%d\t(escape: %d, reaction pair: %d, single: %d)
total reactions = %d
rejected moves = %d
''' \
            % (self.t, self.step_counter,
               numpy.array(self.single_steps.values()).sum(),
               self.single_steps[EventType.SINGLE_ESCAPE],
               self.single_steps[EventType.SINGLE_REACTION],
               numpy.array(self.interaction_steps.values()).sum(),
               self.interaction_steps[EventType.IV_ESCAPE],
               self.interaction_steps[EventType.IV_INTERACTION],
               numpy.array(self.pair_steps.values()).sum(),
               self.pair_steps[EventType.IV_ESCAPE],
               self.pair_steps[EventType.COM_ESCAPE],
               self.pair_steps[EventType.IV_REACTION],
               self.pair_steps[EventType.SINGLE_REACTION],
               self.multi_steps[3], # total multi steps
               self.multi_steps[EventType.MULTI_ESCAPE],
               self.multi_steps[EventType.MULTI_BIMOLECULAR_REACTION],
               self.multi_steps[EventType.MULTI_UNIMOLECULAR_REACTION],
               self.reaction_events,
               self.rejected_moves
               )

        print >> out, report

    #
    # consistency checkers
    #

    def check_obj(self, obj):
        obj.check()

        for shell_id, shell in obj.shell_list:
            if not isinstance(obj, Multi):
                ignores = [obj.surface.id]
            else:
                ignores = []
            closest, distance = self.get_closest_obj(shell.shape.position,
                                                     ignore=[obj.domain_id],
                                                     ignores=ignores)
            if(type(obj) is CylindricalSurfaceSingle or
               type(obj) is CylindricalSurfacePair):
                shell_size = shell.shape.half_length
            else:
                shell_size = shell.shape.radius

            assert shell_size <= self.get_user_max_shell_size(), \
                '%s shell size larger than user-set max shell size' % \
                str(shell_id)

            assert shell_size <= self.get_max_shell_size(), \
                '%s shell size larger than simulator cell size / 2' % \
                str(shell_id)

            assert distance - shell_size >= 0.0, \
                '%s overlaps with %s. (shell: %s, dist: %s, diff: %s.' % \
                (str(obj), str(closest), FORMAT_DOUBLE % shell_size,
                 FORMAT_DOUBLE % distance,
                 FORMAT_DOUBLE % (distance - shell_size))

        return True

    def check_obj_for_all(self):
        for id, event in self.scheduler:
            self.check_obj(event.data)

    def check_event_stoichiometry(self):
        event_population = 0
        for id, event in self.scheduler:
            event_population += event.data.multiplicity

        if self.world.num_particles != event_population:
            raise RuntimeError('population %d != event_population %d' %
                               (population, event_population))

    def check_shell_matrix(self):
        did_map = {}
        shell_map = {}
        for container in self.containers:
            if self.world.world_size != container.world_size:
                raise RuntimeError('self.world.world_size != '
                                   'container.world_size')
            for shell_id, shell in container:
                did_map.setdefault(shell.did, []).append(shell_id)
                shell_map[shell_id] = shell

        shell_population = 0
        for id, event in self.scheduler:
            shell_population += event.data.num_shells
            shell_ids = did_map[event.data.domain_id]
            if len(shell_ids) != event.data.num_shells:
                diff = set(sid for (sid, _)
                               in event.data.shell_list).difference(shell_ids)
                for sid in diff:
                    print shell_map.get(sid, None)

                raise RuntimeError('number of shells are inconsistent '
                                   '(%d != %d; %s) - %s' %
                                   (len(shell_ids), event.data.num_shells, 
                                    event.data.domain_id, diff))

        matrix_population = sum(len(container)
                                for container in self.containers)
        if shell_population != matrix_population:
            raise RuntimeError('num shells (%d) != matrix population (%d)' %
                               (shell_population, matrix_population))

    def check_domains(self):
        event_ids = set(domain.event_id
                        for domain in self.domains.itervalues())
        for id, event in self.scheduler:
            if id not in event_ids:
                raise RuntimeError('%s in EventScheduler not in self.domains' %
                                   event.data)
            event_ids.remove(id)

        # self.domains always include a None  --> this can change in future
        if event_ids:
            raise RuntimeError('following domains in self.domains not in '
                               'Event Scheduler: %s' % str(tuple(event_ids)))

    def check_pair_pos(self, pair, pos1, pos2, com, radius):
        particle1 = pair.single1.pid_particle_pair[1]
        particle2 = pair.single2.pid_particle_pair[1]

        old_com = com
        
        # debug: check if the new positions are valid:
        new_distance = self.world.distance(pos1, pos2)
        particle_radius12 = particle1.radius + particle2.radius

        # check 1: particles don't overlap.
        if new_distance <= particle_radius12:
            if __debug__:
                log.info('rejected move: radii %s, particle distance %s',
                         (FORMAT_DOUBLE % particle1.radius + particle2.radius,
                          FORMAT_DOUBLE % new_distance))
            if __debug__:
                log.debug('DEBUG: pair.dt %s, pos1 %s, pos2 %s' %
                          (FORMAT_DOUBLE % pair.dt, FORMAT_DOUBLE % pos1,
                           FORMAT_DOUBLE % pos2))
            raise RuntimeError('New particles overlap')

        # check 2: particles within mobility radius.
        d1 = self.world.distance(old_com, pos1) + particle1.radius
        d2 = self.world.distance(old_com, pos2) + particle2.radius
        if d1 > radius or d2 > radius:
            raise RuntimeError('New particle(s) out of protective sphere. ' 
                               'radius = %s, d1 = %s, d2 = %s ' %
                               (FORMAT_DOUBLE % radius, FORMAT_DOUBLE % d1,
                                FORMAT_DOUBLE % d2))

        return True




    def check(self):
        ParticleSimulatorBase.check(self)

        assert self.scheduler.check()

        assert self.t >= 0.0
        assert self.dt >= 0.0

        self.check_shell_matrix()
        self.check_domains()
        self.check_event_stoichiometry()
        
        self.check_obj_for_all()

    #
    # methods for debugging.
    #

    def dump_scheduler(self):
        """Dump scheduler information.

        """
        for id, event in self.scheduler:
            print id, event

    def dump(self):
        """Dump scheduler and event information.

        """
        for id, event in self.scheduler:
            print id, event, event.data

    def count_domains(self):
        # Returns a tuple (# Singles, # Pairs, # Multis).

        num_singles = 0
        num_pairs = 0
        num_multis = 0
        for d in self.domains.itervalues():
            if isinstance(d, Single):
                num_singles += 1
            elif isinstance(d, Pair):
                num_pairs += 1
            elif isinstance(d, Multi):
                num_multis += 1
            else:
                raise RuntimeError('DO NOT GET HERE')

        return (num_singles, num_pairs, num_multis)

    dispatch = [
        (Single, fire_single),
        (Pair, fire_pair),
        (Multi, fire_multi)
        ]


 </xmp> 
<h3> gfrdbase.py </h3> <xmp>

#!/usr/env python

import math
import sys

import numpy
import scipy


import _gfrd
from utils import *

import os
import logging
import logging.handlers

import myrandom

import model

__all__ = [
    'log',
    'setup_logging',
    'p_free',
    'throw_in_particles',
    'place_particle',
    'NoSpace',
    'create_world',
    'ParticleSimulatorBase',
    'get_closest_surface',
    'get_closest_surface_within_radius'
    ]

World = _gfrd.World

log = None

def setup_logging():
    global log 
    log = logging.getLogger('ecell')

    if 'LOGFILE' in os.environ:
        if 'LOGSIZE' in os.environ and int(os.environ['LOGSIZE']) != 0:
            handler = logging.handlers.\
                RotatingFileHandler(os.environ['LOGFILE'], mode='w',
                                    maxBytes=int(os.environ['LOGSIZE']))
        else:
            handler = logging.FileHandler(os.environ['LOGFILE'], 'w', )
            
        if 'LOGLEVEL' in os.environ:
            handler.setLevel(getattr(logging, os.environ['LOGLEVEL']))
        else:
            handler.setLevel(logging.INFO)
    else:
        handler = _gfrd.CppLoggerHandler(_gfrd.Logger.get_logger("ecell"))
        if 'LOGLEVEL' in os.environ:
            levelvalue = getattr(logging, os.environ['LOGLEVEL'])
            handler.logger.manager.level = _gfrd.CppLoggerHandler.translateLevelValue(levelvalue)
            log.setLevel(levelvalue)

    formatter = logging.Formatter('%(message)s')
    handler.setFormatter(formatter)

    log.addHandler(handler)

setup_logging()


def p_free(r, t, D):
    Dt4 = D * t * 4.0
    Pi4Dt = numpy.pi * Dt4
    rsq = r * r
    
    p = math.exp(- rsq / Dt4) / math.sqrt(Pi4Dt * Pi4Dt * Pi4Dt)

    jacobian = 4.0 * numpy.pi * rsq

    return p * jacobian
    
class NoSpace(Exception):
    pass

def get_closest_surface(world, pos, ignore):
    # Return
    #   - closest surface
    #   - distance to closest surface
    #
    # We can not use matrix_space, it would miss a surface if the 
    # origin of the surface would not be in the same or neighboring 
    # cells as pos.

    surfaces_and_distances_to_surfaces = []

    for surface in world.structures:
        if isinstance(surface, _gfrd.Surface) and surface.id not in ignore:
            pos_transposed = \
                world.cyclic_transpose(pos, surface.shape.position)
            distance = world.distance(surface.shape, pos_transposed)
            surfaces_and_distances_to_surfaces.append((surface, distance))

    if surfaces_and_distances_to_surfaces:
        return min(surfaces_and_distances_to_surfaces)
    else:
        return None, numpy.inf

def get_closest_surface_within_radius(world, pos, radius, ignore):
    # Return:
    #   - surface within radius or None
    #   - closest surface (regardless of radius)
    #   - distance to closest surface

    surface, distance = get_closest_surface(world, pos, ignore) 
    if distance < radius:
        return surface, surface, distance
    else:
        return None, surface, distance

def create_world(m, matrix_size=10):
    """Create a world object.
    
    The world object keeps track of the positions of the particles
    and the protective domains during an eGFRD simulation.

    Arguments:
        - m
            a ParticleModel previously created with model.ParticleModel.
        - matrix_size
            the number of cells in the MatrixSpace along the x, y and z 
            axis. Leave it to the default number if you don't know what 
            to put here.

    The simulation cube "world" is divided into (matrix_size x matrix_size 
    x matrix_size) cells. Together these cells form a MatrixSpace. The 
    MatrixSpace keeps track in which cell every particle and protective 
    domain is at a certain point in time. To find the neigherest 
    neighbours of particle, only objects in the same cell and the 26 
    (3x3x3 - 1) neighbouring cells (the simulation cube has periodic
    boundary conditions) have to be taken into account.

    The matrix_size limits the size of the protective domains. If you 
    have fewer particles, you want a smaller matrix_size, such that the 
    protective domains and thus the eGFRD timesteps can be larger. If 
    you have more particles, you want a larger matrix_size, such that 
    finding the neigherest neighbours is faster.
    
    Example. In samples/dimer/dimer.py a matrix_size of
    (N * 6) ** (1. / 3.) is used, where N is the average number of 
    particles in the world.

    """
    m.set_all_repulsive()
    world_region = m.get_structure("world")
    if not isinstance(world_region, _gfrd.CuboidalRegion):
        raise TypeError("the world should be a CuboidalRegion")

    if not numpy.all(world_region.shape.half_extent ==
                     world_region.shape.half_extent[0]):
        raise NotImplementedError("non-cuboidal world is not supported")

    world_size = world_region.shape.half_extent[0] * 2

    world = _gfrd.World(world_size, matrix_size)

    for st in m.species_types:
        try:
            structure = st["structure"]
        except _gfrd.NotFound:
            structure = "world"
        world.add_species(
            _gfrd.SpeciesInfo(st.id, 
                              float(st["D"]), 
                              float(st["radius"]), 
                              structure,
                              float(st["v"])))

    for r in m.structures.itervalues():
        world.add_structure(r)

    world.model = m
    return world

def create_network_rules_wrapper(model):
    return _gfrd.NetworkRulesWrapper(model.network_rules)

def throw_in_particles(world, sid, n):
    """Add n particles of a certain Species to the specified world.

    Arguments:
        - sid
            a Species previously created with the function 
            model.Species.
        - n
            the number of particles to add.

    Make sure to first add the Species to the model with the method
    model.ParticleModel.add_species_type.

    """
    species = world.get_species(sid)
    structure = world.get_structure(species.structure_id)

    if __debug__:
        name = world.model.get_species_type_by_id(sid)["name"]
        if name[0] != '(':
            name = '(' + name + ')'
        log.info('\n\tthrowing in %s particles of type %s to %s' %
                 (n, name, structure.id))

    # This is a bit messy, but it works.
    i = 0
    while i < int(n):
        position = structure.random_position(myrandom.rng)
        position = apply_boundary(position, world.world_size)

        # Check overlap.
        if not world.check_overlap((position, species.radius)):
            create = True
            # Check if not too close to a neighbouring structures for 
            # particles added to the world, or added to a self-defined 
            # box.
            if isinstance(structure, _gfrd.CuboidalRegion):
                surface, distance = get_closest_surface(world, position, [])
                if(surface and
                   distance < surface.minimal_distance(species.radius)):
                    if __debug__:
                        log.info('\t%d-th particle rejected. Too close to '
                                 'surface. I will keep trying.' % i)
                    create = False
            if create:
                # All checks passed. Create particle.
                p = world.new_particle(sid, position)
                i += 1
                if __debug__:
                    log.info('(%s,\n %s' % (p[0], p[1]))
        elif __debug__:
            log.info('\t%d-th particle rejected. I will keep trying.' % i)

def place_particle(world, sid, position):
    """Place a particle of a certain Species at a specific position in 
    the specified world.

    Arguments:
        - sid
            a Species previously created with the function 
            model.Species.
        - position
            a position vector [x, y, z]. Units: [meters, meters, meters].

    Make sure to first add the Species to the model with the method 
    model.ParticleModel.add_species_type.

    """
    species = world.get_species(sid)
    structure = world.get_structure(species.structure_id)
    radius = species.radius

    if world.check_overlap((position, radius)):
        raise NoSpace, 'overlap check failed'

    # Check if not too close to a neighbouring structures for particles 
    # added to the world, or added to a self-defined box.
    if isinstance(structure, _gfrd.CuboidalRegion):
        surface, distance = get_closest_surface(world, position, [])
        if(surface and
           distance < surface.minimal_distance(species.radius)):
            raise RuntimeError('Placing particle failed: %s %s. '
                               'Too close to surface: %s.' %
                               (sid, position, distance))

    if __debug__:
        species = world.get_species(sid)
        structure = world.get_structure(species.structure_id)
        name = world.model.get_species_type_by_id(sid)["name"]
        if name[0] != '(':
            name = '(' + name + ')'
        log.info('\n\tplacing particle of type %s to %s at position %s' %
                 (name, structure.id, position))

    particle = world.new_particle(sid, position)
    return particle

class ParticleSimulatorBase(object):
    def __init__(self, world, rng, network_rules):
        self.world = world
        self.rng = rng
        self.network_rules = network_rules

        #self.dt = 1e-7
        #self.t = 0.0

        self.H = 3.0

        self.dissociation_retry_moves = 1
        
        self.dt_limit = 1e-3
        self.dt_max = self.dt_limit

        # counters
        self.rejected_moves = 0
        self.reaction_events = 0

        self.max_matrix_size = 0

        self._distance_sq = None
        self._disatnce_sq_array = None

        self.last_reaction = None

    def initialize(self):
        pass

    def get_species(self):
        return self.world.species

    def get_first_pid(self, sid):
        return iter(self.world.get_particle_ids(sid)).next()

    def get_position(self, object):
        if type(object) is tuple and type(object[0]) is _gfrd.ParticleID:
            pid = object[0]
        elif type(object) is _gfrd.ParticleID:
            pid = object
        elif type(object) is _gfrd.Particle:
            pid = self.get_first_pid(object.sid)
        elif type(object) is _gfrd.SpeciesID:
            pid = self.get_first_pid(object)

        return self.world.get_particle(pid)[1].position


    def clear(self):
        self.dt_max = self.dt_limit
        self.dt = self.dt_limit

    def check_particle_matrix(self):
        total = sum(len(self.world.get_particle_ids(s.id))
                    for s in self.world.species)

        if total != self.world.num_particles:
            raise RuntimeError('total number of particles %d != '
                               'self.world.num_particles %d' %
                               (total, self.world.num_particles))

    def check_particles(self):
        for pid_particle_pair in self.world:
            pid = pid_particle_pair[0]
            pos = pid_particle_pair[1].position
            if (pos >= self.world.world_size).any() or (pos < 0.0).any():
                raise RuntimeError('%s at position %s out of the world '
                                   '(world size=%g).' %
                                   (pid, pos, self.world.world_size))


    def check(self):
        self.check_particle_matrix()
        self.check_particles()

    def print_report(self):
        pass

 </xmp> 
<h3> gillespie.py </h3> <xmp>

#!/usr/env python

import numpy
import weakref
import logging
import os

from _gfrd import * # FIX ME
from constants import EventType # FIX ME
import utils
import logger
import myrandom

log = logging.getLogger('gillespie')

def rng_uniform():
    '''Returns a positive random number
    '''
    while True:
        rng = myrandom.uniform(0.0, 1.0)
        if rng > 0.0: return rng

class Logger(logger.Logger):

    def __init__(self, logname='log', directory='data', comment=''):
        logger.Logger.__init__(self, logname, directory, comment)

    def prepare_timecourse_file(self, simulator):
        if not os.path.exists(self.directory):
            os.mkdir(self.directory)
        timecourse_filename = '%s_tc.dat' % self.logname
        self.timecourse_file = open(
            os.path.join(self.directory, timecourse_filename), 'w')
        self.write_timecourse_comment(self.comment)

        species_name_list = '\'' + \
            "\', \'".join(str(id) for id in simulator.get_species_id()) + '\''
        columns = '[\'t\', ' + species_name_list + ']'
        self.write_timecourse_comment('@ columns= ' + columns)

    def write_timecourse(self, simulator):
        data = []
        self.timecourse_file.write('%g\t' % simulator.t)
        self.timecourse_file.write('\t'.join(
                str(simulator.get_pool_size(id))
                for id in simulator.get_species_id()) + '\n')
        self.timecourse_file.flush()

    def write_particles(self, simulator):
        # dummy
        pass

class Delegate(object):

    def __init__(self, obj, method):
        self.ref = weakref.ref(obj)
        self.method = method

    def __call__(self, *arg):
        return self.method(self.ref(), *arg)

class GillespieEvent(Event):
    __slot__ = ['func', 'rr']
    def __init__(self, time, func, rr):
        Event.__init__(self, time)
        self.func = func
        self.rr = rr

class ReactionRuleCache(object):

    def __init__(self, rr, reactants, products, k):
        self.rr = rr

        self.reactants = reactants
        self.products = products
        self.k = k

        self.eventID = None
        self.eventType = None

    def accessors(self):
        if self.eventType == EventType.SINGLE_REACTION: # FIX ME
            return self.reactants
        else:
            return []

    def mutators(self):
        if self.eventType == EventType.SINGLE_REACTION: # FIX ME
            return self.reactants + self.products
        else:
            return []

    def is_dependent_on(self, rr):
        for id1 in self.accessors():
            if id1 in rr.mutators():
                return True

        return False

class GillespieSimulatorBase(object):

    def __init__(self):
        self.model = None
        self.speciesDict = {}
        self.stateArray = numpy.array([])

        self.set_volume(utils.INF)

    def set_model(self, model):
        self.model = model
        self.network_rules = NetworkRulesWrapper(model.network_rules)

    def initialize(self):
        pass

    def reset(self):
        pass

    def set_world_size(self, size):
        if size == utils.INF:
            self.set_volume(utils.INF)
        else:
            volume = size * size * size
            self.set_volume(volume)

    def get_world_size(self):
        return self.volume ** (1.0 / 3.0)

    def set_volume(self, volume):
        self.volume = volume

    def get_volume(self):
        return self.volume

    def create_reaction_rule_cache(self, rr):
        reactants = [id for id in rr.reactants]
        products = [id for id in rr.products]

        k = float(rr.k)

        if self.convert_rates == False:
            # Don't do the conversion below.
            return ReactionRuleCache(rr, reactants, products, k)

        if len(reactants) == 1:
            if len(products) == 2:
                st1 = self.model.get_species_type_by_id(products[0])
                st2 = self.model.get_species_type_by_id(products[1])

                # Lookup kon for reverse reaction rule.
                for rr_possible_reverse in self.get_reaction_rule2(st1, st2):
                    if rr_possible_reverse.products == reactants: 
                        rr_reverse = rr_possible_reverse
                        kon = float(rr_reverse.k)

                        # Compute kD for reverse reaction.
                        D = float(st1['D']) + float(st2['D'])
                        sigma = float(st1['radius']) + float(st2['radius'])
                        kD = utils.k_D(D, sigma)

                        # Use overall rate internally.
                        k = utils.k_off(k, kon, kD)

        elif len(reactants) == 2:
            st1 = self.model.get_species_type_by_id(reactants[0])
            st2 = self.model.get_species_type_by_id(reactants[1])
            D = float(st1['D']) + float(st2['D'])
            sigma = float(st1['radius']) + float(st2['radius'])
            kD = utils.k_D(D, sigma)
            if kD == 0.0:
                k = 0.0
            elif k != 0.0:
                # Use overall rate kon internally.
                k = utils.k_on(k, kD)

        return ReactionRuleCache(rr, reactants, products, k)

    def get_reaction_rule1(self, st):
        return self.__get_reaction_rule(st)

    def get_reaction_rule2(self, st1, st2):
        return self.__get_reaction_rule(st1, st2)

    def __get_reaction_rule(self, *args):
        gen = self.network_rules.query_reaction_rule(*args)
        if gen == None:
            return []

        retval = []
        for rr in gen:
            if rr.k == 0:
                continue
            retval.append(self.create_reaction_rule_cache(rr))
        return retval

    def clear(self):
        pass

    def get_pool_size(self, id):
        if id in self.speciesDict.keys():
            return self.stateArray[self.speciesDict[id]]
        else:
            return 0.0

    def remove_particles(self, st, n):
        if __debug__:
            log.info('removing in %s %s particles' % (n, st.id))

        if st.id not in self.speciesDict.keys():
            raise RuntimeError, '%s species doesn\'t exist.' % (st.id)

        self.stateArray[self.speciesDict[st.id]] -= n

    def throw_in_particles(self, st, n):
        if __debug__:
            log.info('throwing in %s %s particles' % (n, st.id))

        if not st.id in self.speciesDict.keys():
            raise RuntimeError, '%s species doesn\'t exist.' % (st.id)

        self.stateArray[self.speciesDict[st.id]] += n

    def add_species(self, id):
        i = len(self.stateArray)
        self.stateArray = numpy.resize(self.stateArray, i + 1)
        self.stateArray[i] = 0.0

        self.speciesDict[id] = i

    def check(self):
        pass

    def dump_population(self):
        buf = ''
#         for id, i in self.speciesDict.items():
#             st = self.model.get_species_type_by_id(id)
#             buf += st['id'] + ':' + str(self.stateArray[i]) + '\t'

        for id, i in self.speciesDict.items():
            buf += str(self.stateArray[i]) + ' '

        return buf

    def get_step_interval(self, rr):
        return self.get_propensity_R(rr) * (- numpy.log(rng_uniform()))

    def get_propensity(self, rr):
        if len(rr.reactants) == 1:
            propensity = self.get_propensity_first_order(rr)

        elif len(rr.reactants) == 2:
            if rr.reactants[0] == rr.reactants[1]:
                propensity \
                    = self.get_propensity_second_order_one_substrate(rr)
            else:
                propensity \
                    = self.get_propensity_second_order_two_substrates(rr)
        
        if propensity < 0.0:
            raise RuntimeError, 'Population size <= -1.0'
            return 0.0

        else:
            return propensity

    def get_propensity_R(self, rr):
        propensity = self.get_propensity(rr)
        if propensity > 0.0:
            return 1.0 / propensity
        else:
            return utils.INF

    def get_propensity_first_order(self, rr):
        value = self.get_pool_size(rr.reactants[0])

        if value > 0.0:
            return rr.k * value
        else:
            return 0.0

    def get_propensity_second_order_two_substrates(self, rr):
        value = self.get_pool_size(rr.reactants[0]) \
            * self.get_pool_size(rr.reactants[1])

        if value > 0.0:
            return rr.k * value / self.volume
        else:
            return 0.0

    def get_propensity_second_order_one_substrate(self, rr):
        value = self.get_pool_size(rr.reactants[0])

        if value > 1.0: # there must be two or more molecules
            return rr.k * 0.5 * value * (value - 1.0) / self.volume
        else:
            return 0.0

class GillespieSimulator(GillespieSimulatorBase):

    def __init__(self, model, convert_rates=True):
        self.scheduler = EventScheduler()
        GillespieSimulatorBase.__init__(self)

        self.dependencies = {}
        self.last_event = None
        self.last_reaction = None

        self.t = 0.0
        self.dt = 0.0

        self.scheduler.clear()

        volume = model.world_size ** 3
        self.set_volume(volume)
        self.set_model(model)
        self.convert_rates = convert_rates

    def initialize(self):
        GillespieSimulatorBase.initialize(self)

        self.scheduler.clear()

        for id1, i in self.speciesDict.items():
            st1 = self.model.get_species_type_by_id(id1)
            rules = self.get_reaction_rule1(st1)
            for rr in rules:
                self.add_update_event(rr)

            for id2, j in self.speciesDict.items():
                if i > j:
                    continue

                st2 = self.model.get_species_type_by_id(id2)
                rules = self.get_reaction_rule2(st1, st2)
                for rr in rules:
                    self.add_update_event(rr)

    def reset(self):
        GillespieSimulatorBase.reset(self)

    def get_next_time(self):
        if self.scheduler.size == 0:
            return self.t

        return self.scheduler.top[1].time

    def govern(self, id):
        return id in self.speciesDict.keys()

    def stop(self, t):
        if __debug__:
            log.info('stop at %g' % t)

        if self.t == t:
            return

        if t >= self.scheduler.getTopEvent().getTime():
            raise RuntimeError, 'Stop time >= next event time.'

        if t < self.t:
            raise RuntimeError, 'Stop time >= next event time.'

        self.t = t

    def step(self):
        if self.scheduler.size == 0:
            self.t = utils.INF
            self.dt = utils.INF
            self.last_event = None
            self.last_reaction = None
            return

        id, event = self.scheduler.pop()
        self.t, self.last_event = event.time, event

        if self.last_event.rr.eventType == EventType.SINGLE_REACTION: # FIX ME
            self.last_reaction = self.last_event
        else:
            self.last_reaction = None

        if __debug__:
#             log.info('\n%d: t=%g dt=%g\nevent=%s reactions=%d rejectedmoves=%d' % (self.stepCount, self.t, self.dt, self.last_event, self.reactionEvents, self.rejectedMoves))
            pass

        
        # Execute event.
        event.func(event.rr)

        if self.t != utils.INF: # and self.scheduler.getTopTime() == utils.INF
            nextTime = self.get_next_time()
            self.dt = nextTime - self.t
        else:
            self.dt = 0.0 # inf - inf == nan

    def fire(self, rr):
        for id in rr.reactants:
            st = self.model.get_species_type_by_id(id)
            self.remove_particles(st, 1)

        for id in rr.products:
            st = self.model.get_species_type_by_id(id)
            self.throw_in_particles(st, 1)

        for rr2 in self.dependencies[rr]:
            event = self.scheduler[rr2.eventID]
            dt = self.get_step_interval(rr2)
            self.update_event_time(self.t + dt, event)

        self.add_reaction_event(rr)

    def update(self, rr):
        self.dependencies.pop(rr)
        self.add_reaction_event(rr)

#     def remove_particles(self, st, n):
#         GillespieSimulatorBase.remove_particles(self, st.id, n)

    def throw_in_particles(self, st, n, surface=None):
        if not self.speciesDict.has_key(st.id):
            self.add_species(st.id)

        GillespieSimulatorBase.throw_in_particles(self, st, n)

    def get_species_id(self):
        return self.speciesDict.keys()

    def get_species(self):
        return []

    def add_species(self, id):
        GillespieSimulatorBase.add_species(self, id)

        st1 = self.model.get_species_type_by_id(id)
        rules = self.get_reaction_rule1(st1)
        for rr in rules:
            self.add_update_event(rr)

        for id2 in self.speciesDict.keys():
            st2 = self.model.get_species_type_by_id(id2)
            rules = self.get_reaction_rule2(st1, st2)
            for rr in rules:
                self.add_update_event(rr)
        
    def add_event(self, t, func, arg):
        return self.scheduler.add(GillespieEvent(t, func, arg))

    def add_reaction_event(self, rr):
        rr.eventType = EventType.SINGLE_REACTION # FIX ME

        dt = self.get_step_interval(rr)
        eventID = self.add_event(self.t + dt,
                                 Delegate(self, GillespieSimulator.fire),
                                 rr)
        if __debug__:
            log.info('addReactionEvent: #%d (t=%g)' % (eventID, self.t + dt))

        rr.eventID = eventID

        self.update_event_dependency(rr)

        for id, event in self.scheduler:
            rr2 = event.rr
            if rr == rr2:
                continue

            if rr.is_dependent_on(rr2):
                self.dependencies[rr2].append(rr)

    def add_update_event(self, rr):
        rr.eventType = EventType.SINGLE_ESCAPE # FIX ME

        eventID = self.add_event(self.t,
                                 Delegate(self, GillespieSimulator.update),
                                 rr)
        if __debug__:
            log.info('addUpdateEvent: #%d (t=%g)' % (eventID, self.t))

        rr.eventID = eventID
        self.dependencies[rr] = []

    def remove_event(self, rr):
        if __debug__:
            log.info('removeEvent: #%d' % rr.eventID)

        self.scheduler.removeEvent(rr.eventID)
        rr.eventID = None
        rr.eventType = None

    def update_event_time(self, t, event):
        if __debug__:
            log.info('updateEventTime: #%d (t=%g)' % (event.rr.eventID, t))

        self.scheduler.update((event.rr.eventID,
                               GillespieEvent(t, event.func, event.rr)))

#     def update_all_event_time(self):
#         for i in range(self.scheduler.size):
#             event = self.scheduler.getEventByIndex(i)
#             rr = event.getArg()

#             if rr.eventType == EventType.SINGLE_REACTION: # FIX ME
#                 dt = self.get_step_interval(rr)
#                 self.update_event_time(self.t + dt, rr)
#             else:
#                 assert self.t == event.getTime()
#                 self.update_event_time(self.t, rr)

    def update_event_dependency(self, rr1):
        self.dependencies[rr1] = []

        for id, event in self.scheduler:
            rr2 = event.rr
            if rr1 == rr2:
                continue

            if rr2.is_dependent_on(rr1):
                self.dependencies[rr1].append(rr2)

        self.dependencies[rr1].sort()

    def update_all_event_dependency(self):
        self.dependencies = {}

        for i in range(self.scheduler.size):
            rr = self.scheduler.getEventByIndex(i).getArg()
            self.update_event_dependency(rr)

    def interrupted(self, rr):
        '''return bool for efficiency.
        '''
        if float(rr.k) == 0.0:
            return False

        interrupt = False

        for id in rr.reactants:
            if self.govern(id):
                st = self.model.get_species_type_by_id(id)
                self.remove_particles(st, 1)
                interrupt = True

        for id in rr.products:
            if self.govern(id):
                st = self.model.get_species_type_by_id(id)
                self.throw_in_particles(st, 1)
                interrupt = True

        if not interrupt:
            return False

        rr1 = self.create_reaction_rule_cache(rr)
        for i in range(self.scheduler.size):
            event = self.scheduler.getEventByIndex(i)
            rr2 = event.getArg()
            if rr2.is_dependent_on(rr1):
                dt = self.get_step_interval(rr2)
                self.update_event_time(self.t + dt, event)

        dt = self.get_next_time() - self.t
        self.dt = dt

        return True

    def check(self):
        GillespieSimulatorBase.check()

        assert self.scheduler.check()
        assert self.t >= 0.0

    def dump_scheduler(self):
        for i in range(self.scheduler.size):
            event = self.scheduler.getEventByIndex(i)
            print i, event.getTime(), event.getArg()

    def dump(self):
        self.dump_scheduler()

    def print_report(self):
        pass

if __name__ == '__main__':

    def main():
        pass


    main()

 </xmp> 
<h3> greens_function_wrapper.py </h3> <xmp>

import numpy
import myrandom
from _greens_functions import PairEventKind
from constants import EventType
from utils import *

import logging
log = logging.getLogger('ecell')


def draw_time_wrapper(gf):
    rnd = myrandom.uniform()

    if __debug__:
        log.debug('        *drawTime. ' + gf.__class__.__name__)
    try:
        dt = gf.drawTime(rnd)
    except Exception, e:
        raise Exception('gf.drawTime() failed, '
                        '%s, rnd = %g, %s' %
                        (str(e), rnd, gf.dump()))
    return dt

def draw_event_type_wrapper(gf, dt):
    rnd = myrandom.uniform()

    if __debug__:
        log.debug('        *drawEventType. ' + gf.__class__.__name__)
    try:
        event_type = gf.drawEventType(rnd, dt)
    except Exception, e:
        raise Exception('gf.drawEventType() failed, '
                        '%s, rnd = %g, dt = %g, %s' %
                        (str(e), rnd, dt, gf.dump()))
    return event_type

def draw_r_wrapper(gf, dt, a, sigma=None):
    rnd = myrandom.uniform()

    if __debug__:
        log.debug('        *drawR. ' + gf.__class__.__name__)
    try:
        r = gf.drawR(rnd, dt)
        while r > a or r <= sigma: # redraw; shouldn't happen often
            if __debug__:
                log.debug('        *drawR: redraw')
            rnd = myrandom.uniform()
            r = gf.drawR(rnd, dt)
    except Exception, e:
        raise Exception('gf.drawR() failed, '
                        '%s, rnd = %g, dt = %g, %s' %
                        (str(e), rnd, dt, gf.dump()))

    return r

def draw_theta_wrapper(gf, r, dt):
    """Draw theta for the inter-particle vector.

    """
    rnd = myrandom.uniform()

    if __debug__:
        log.debug('        *drawTheta. ' + gf.__class__.__name__)
    try:
        theta = gf.drawTheta(rnd, r, dt)
    except Exception, e:
        raise Exception('gf.drawTheta() failed, '
                        '%s, rnd = %g, r = %g, dt = %g' %
                        (str(e), rnd, r, dt))#, gf.dump()))

    # Heads up. For cylinders theta should be between [-pi, pi]. For 
    # spheres it doesn't matter.
    return myrandom.choice(-1, 1) * theta

 </xmp> 
<h3> __init__.py </h3> <xmp>

 </xmp> 
<h3> legacy.py </h3> <xmp>

import _gfrd

class MultiParticleContainer(_gfrd._ParticleContainer):
    def __init__(self, world):
        _gfrd._ParticleContainer.__init__(self)
        self.world = world
        self.particles = {}

    def num_particles(self):
        return len(self.particles)
    num_particles = property(num_particles)

    def get_structure(self, id):
        return self.world.get_structure(id)

    def get_species(self, id):
        return self.world.get_species(id)

    def species(self):
        return self.world.species
    species = property(species)

    def new_particle(self, species_id, position):
        retval = self.world.new_particle(species_id, position)
        self.particles[retval[0]] = retval[1]
        return retval

    def update_particle(self, pid_particle_pair):
        self.particles[pid_particle_pair[0]] = pid_particle_pair[1]
        return self.world.update_particle(pid_particle_pair)

    def remove_particle(self, pid):
        del self.particles[pid]
        self.world.remove_particle(pid)

    def get_particle(self, pid):
        p = self.particles.get(pid, None)
        if p is None:
            raise NotFound
        return pid, p

    def check_overlap(self, sphere, *arg):
        if len(arg) == 0:
            ignores = ()
        elif len(arg) == 1:
            if isinstance(arg[0], _gfrd.ParticleID):
                ignores = (arg[0],)
            else:
                ignores = arg[0]
        elif len(arg) == 2:
            assert all(isinstance(a, _gfrd.ParticleID) for a in arg)
            ignores = arg

        retval = []
        for pp in self.particles.iteritems():
            if pp[0] in ignores:
                continue
            dist = _gfrd.distance(pp[1].position, sphere[0]) - pp[1].radius
            if dist < sphere[1]:
                retval.append((pp, dist))
        retval.sort(lambda a, b: cmp(a[1], b[1]))
        return retval

    def distance(self, x, y):
        return self.world.distance(x, y)

    def apply_boundary(self, x):
        return self.world.apply_boundary(x)

    def cyclic_transpose(self, x, y):
        return self.world.cyclic_transpose(x, y)

    def __iter__(self):
        return self.particles.iteritems()

    def create_transaction(self):
        return _gfrd.TransactionImpl(self)


class BDPropagator(object):
    def __init__(self, tx, network_rules, rng, dt, dissociation_retry_moves, particle_ids):
        self.tx = tx
        self.nr = network_rules
        self.rng = rng
        self.dt = dt
        self.dissociation_retry_moves = dissociation_retry_moves
        self.reactions = []
        particles_to_step = list(particle_ids)
        for i in reversed(range(0, len(particles_to_step))):
            j = rng.uniform_int(0, i)
            particles_to_step[i], particles_to_step[j] = \
                particles_to_step[j], particles_to_step[i]
        self.particles_to_step = particles_to_step

    def getP_acct(self, rt, D, sigma):
        I = _gfrd.I_bd(sigma, self.dt, D)
        p = rt.k * self.dt / (I * 4.0 * numpy.pi)
        if not 0.0 <= p < 1.0:
            raise RuntimeError,\
                'Invalid acceptance ratio (%s) for reaction %s.' \
                % (p, rt)
        return p

    def __call__(self):
        if not self.particles_to_step:
            return False

        pid = self.particles_to_step.pop() # take the last one
        pid_particle_pair = self.tx.get_particle(pid)
        sid = pid_particle_pair[1].sid

        rt1 = self.attempt_single_reactions(sid)
        if rt1:
            try:
                self.fire_reaction1(pid_particle_pair, rt1)
            except NoSpace:
                if __debug__:
                    log.info('fire_reaction1 rejected.')
            return True

        D = pid_particle_pair[1].D
        if D == 0.0:
            return True

        species = self.tx.get_species(sid)
        surface = self.tx.get_structure(species.structure_id)
        displacement = surface.bd_displacement(math.sqrt(2.0 * D * self.dt), self.rng)
        newpos = self.tx.apply_boundary(pid_particle_pair[1].position + displacement)
        neighbors = self.tx.check_overlap(
            (newpos, pid_particle_pair[1].radius), pid_particle_pair[0])

        if neighbors:
            if len(neighbors) >= 2:
                if __debug__:
                    log.info('collision two or more particles; move rejected')
                return True

            closest = neighbors[0][0]
            reactions = list(self.nr.query_reaction_rule(sid, closest[1].sid))
            if len(reactions) == 0:
                return True
            else:
                assert len(reactions) == 1

            rt = reactions[0]

            if rt.k != 0.0:
                radius12 = pid_particle_pair[1].radius + closest[1].radius
                D12 = D + closest[1].D
                p = self.getP_acct(rt, D12, radius12)
                rnd = self.rng.uniform(0, 1.)

                if p > rnd:
                    try:
                        self.fire_reaction2(pid_particle_pair, closest, rt)
                    except NoSpace:
                        if __debug__:
                            log.info('fire_reaction2 move rejected')
                    return True

            else:
                if __debug__:
                    log.info('collision move rejected')

            return True
    
        try:
            self.tx.update_particle(
                (pid_particle_pair[0],
                 _gfrd.Particle(newpos,
                                pid_particle_pair[1].radius,
                                pid_particle_pair[1].D,
                                pid_particle_pair[1].sid)))
        except NoSpace:
            if __debug__:
                log.info('propagation move rejected.')
        return True

    def attempt_single_reactions(self, sid):
        reaction_types = self.nr.query_reaction_rule(sid)
        if not reaction_types:
            return None  # no reaction

        rnd = self.rng.uniform() / self.dt

        # handle the most common case efficiently.
        if len(reaction_types) == 1:  
            if reaction_types[0].k >= rnd:
                return reaction_types[0]
            else:
                return None

        # if there are more than one possible reaction types..
        k_array = numpy.add.accumulate([rt.k for rt in reaction_types])

        if k_array[-1] < rnd:
            return None

        i = numpy.searchsorted(k_array, rnd)

        return reaction_types[i]

    def fire_reaction1(self, pid_particle_pair, rt):
        if __debug__:
            log.info('fire_reaction1')
        oldpos = pid_particle_pair[1].position

        if len(rt.products) == 0:
            self.tx.remove_particle(pid_particle_pair[0])
            self.reactions.append((rt, (pid_particle_pair, None), []))
        elif len(rt.products) == 1:
            product_species = rt.products[0]
            radius = product_species.radius

            if self.tx.check_overlap((oldpos, radius),
                                        pid_particle_pair[0]):
                if __debug__:
                    log.info('no space for product particle.')
                raise NoSpace()

            self.tx.remove_particle(pid_particle_pair[0])
            newparticle = self.create_particle(product_species.id, oldpos)

            self.reactions.append((rt, (pid_particle_pair, None), [newparticle]))
        elif len(rt.products) == 2:
            product_species1 = rt.products[0]
            product_species2 = rt.products[1]
            
            D1 = product_species1.D
            D2 = product_species2.D
            D12 = D1 + D2
            
            radius1 = product_species1.radius
            radius2 = product_species2.radius
            radius12 = radius1 + radius2

            for i in xrange(self.dissociation_retry_moves):
                rnd = self.rng.uniform()
                pair_distance = _gfrd.drawR_gbd(rnd, radius12, self.dt, D12)

                unit_vector = random_unit_vector()
                vector = unit_vector * pair_distance # * (1.0 + 1e-10) # safety
            
                # place particles according to the ratio D1:D2
                # this way, species with D=0 doesn't move.
                # FIXME: what if D1 == D2 == 0?
                newpos1 = oldpos + vector * (D1 / D12)
                newpos2 = oldpos - vector * (D2 / D12)
            
                newpos1 = self.tx.apply_boundary(newpos1)
                newpos2 = self.tx.apply_boundary(newpos2)

                # accept the new positions if there is enough space.
                if (not self.tx.check_overlap(
                        (newpos1, radius1), pid_particle_pair[0])) and \
                   (not self.tx.check_overlap(
                        (newpos2, radius2), pid_particle_pair[0])):
                    break
            else:
                if __debug__:
                    log.info('no space for product particles.')
                raise NoSpace()

            # move accepted
            self.tx.remove_particle(pid_particle_pair[0])

            newparticle1 = self.create_particle(product_species1.id, newpos1)
            newparticle2 = self.create_particle(product_species2.id, newpos2)

            self.reactions.append((rt, (pid_particle_pair, None), 
                                         [newparticle1, newparticle2]))

        else:
            raise RuntimeError, 'num products >= 3 not supported.'

    def fire_reaction2(self, pid_particle_pair1, pid_particle_pair2, rt):
        if __debug__:
            log.info('fire_reaction2')
        if len(rt.products) == 1:
            product_species = self.tx.get_species(rt.products[0])

            D1 = pid_particle_pair1[1].D
            D2 = pid_particle_pair2[1].D

            pos2t = self.tx.cyclic_transpose(pid_particle_pair2[1].position,
                                                pid_particle_pair1[1].position)
            new_pos = self.tx.apply_boundary(
                (D2 * pid_particle_pair1[1].position + D1 * pos2t) / (D1 + D2))

            if self.tx.check_overlap((new_pos, product_species.radius),
                                        pid_particle_pair1[0],
                                        pid_particle_pair2[0]):
                raise NoSpace()

            self.tx.remove_particle(pid_particle_pair1[0])
            self.tx.remove_particle(pid_particle_pair2[0])
            newparticle = self.tx.new_particle(product_species.id, new_pos)

            try:
                self.particles_to_step.remove(pid_particle_pair2[0])
            except ValueError:  
                pass     # particle2 already stepped, which is fine.

            self.reactions.append(
                (rt, (pid_particle_pair1, pid_particle_pair2), 
                [newparticle]))
        
        else:
            raise NotImplementedError,\
                'num products >= 2 not supported.'

    def propagate_all(self):
        while self():
            pass


 </xmp> 
<h3> logger.py </h3> <xmp>


import os
import re
#import logging
import numpy

import logging
import h5py # added by sakurai@advancesoft.jp
from egfrd import Single, Pair, Multi # added by sakurai@advancesoft.jp

__all__ = [
    'FixedIntervalInterrupter',
    'Logger',
    'HDF5Logger',
    ]

INF = numpy.inf

log = logging.getLogger('ecell')

PARTICLES_SCHEMA = \
    [
        ('id', 'u8', ),
        ('species_id', 'u8', ),
        ('position', 'f8', (3, ))
        ]

SHELLS_SCHEMA = \
    [
        ('id', 'u8', ),
        ('radius', 'f8'),
        ('position', 'f8', (3, )),
        ]

SPECIES_SCHEMA = \
    [
        ('id', 'u8', ),
        ('name', 'S32', ),
        ('radius', 'f8', ),
        ('D', 'f8'), # diffusion coefficient
        ]

SHELL_PARTICLE_ASSOCIATION_SCHEMA = \
    [
        ('shell_id', 'u8'),
        ('particle_id', 'u8'),
        ]

DOMAINS_SCHEMA = \
    [
        ('id', 'u8', ),
        ('kind', 'u4', ),
        ]

DOMAIN_SHELL_ASSOCIATION_SCHEMA = \
    [
        ('shell_id', 'u8', ),
        ('domain_id', 'u8', ),
        ]

class FixedIntervalInterrupter(object):
    def __init__(self, sim, interval, callback):
        self.sim = sim
        self.interval = interval
        self.callback = callback
        self.last_time = 0.
        self.next_time = interval

    def step(self):
        self.sim.step()
        if self.next_time <= self.sim.t + self.sim.dt:
            self.sim.stop(self.next_time)
            self.callback(self.sim, self.next_time)
            self.last_time = self.sim.t
            self.next_time += self.interval


class HDF5Logger(object):
    def __init__(self, logname, directory='data', split=False):
        self.logname = logname
        self.directory = directory
        self.split = split
        self.file_counter = 0
        self.hdf5_file = None

    def new_hdf5_file(self, sim):
        if self.split:
            if self.hdf5_file is not None:
                self.hdf5_file.close()

            if not os.path.exists(self.directory):
                os.mkdir(self.directory)

            hdf5_filename = '%s_%04d.hdf5' % (self.logname, self.file_counter)
            self.file_counter += 1
        else:
            if self.hdf5_file is not None:
                return
            hdf5_filename = '%s.hdf5' % self.logname
        hdf5_path = os.path.join(self.directory, hdf5_filename)
        # HDF5 file must be removed before log_particles
        if os.path.exists(hdf5_path):
            os.remove(hdf5_path)
        self.hdf5_file = h5py.File(hdf5_path)

        self.create_data_group(sim)
        self.write_species(sim)

    def create_data_group(self, sim):
        data_group = self.hdf5_file.create_group('data')
        data_group.attrs['world_size'] = sim.world.world_size
        return data_group

    def write_species(self, sim):
        num_species = len(sim.world.species)

        species_dset = self.hdf5_file.create_dataset('species', (num_species, ), SPECIES_SCHEMA)
        count = 0
        for species in sim.world.species:
            species_dset[count] = (species.id.serial,
                                   str(species.id),
                                   species.radius,
                                   species.D)
            count += 1

    def write_particles(self, sim):
        "This function was created by sakurai@advancesoft.jp"
        data_group = self.hdf5_file['data']

        time_group = data_group.require_group(unicode(sim.t))
        time_group.attrs['t'] = sim.t

        # Create particles dataset on the time group

        num_particles = 0
        for species in sim.world.species:
            pid_list = sim.particle_pool[species.id]
            num_particles += len(pid_list)

        x = numpy.zeros((num_particles, ),
                        dtype = numpy.dtype(PARTICLES_SCHEMA))

        count = 0
        for sid, pid_set in sim.particle_pool.iteritems():
            for pid in pid_set:
                pid, particle = sim.world.get_particle(pid)
                species = sim.world.get_species(sid)
                x['id'][count] = pid.serial
                x['species_id'][count] = sid.serial
                x['position'][count] = particle.position
                count += 1

        dummy = time_group.create_dataset('particles', data = x)

    def write_domains(self, sim):
        if self.hdf5_file is None:
            return

        data_group = self.hdf5_file['data']        

        # Require time group
        time_group = data_group.require_group(unicode(sim.t))
        time_group.attrs['t'] = sim.t

        # Create shell dataset on the time group

        num_shells = 0
        for domain in sim.domains.itervalues():
            num_shells += len(domain.shell_list)

        x = numpy.zeros((num_shells, ), dtype = numpy.dtype(SHELLS_SCHEMA))

        count = 0
        for did, domain in sim.domains.iteritems():
            shell_list = domain.shell_list
            for shell_id, shell in shell_list:
                x['id'][count] = shell_id.serial
                x['radius'][count] = shell.shape.radius
                x['position'][count] = shell.shape.position
                count += 1

        if len(x) == 0:
            return

        dummy = time_group.create_dataset('shells', data = x)

        # Create shell particle association dataset on the time group

        num_assocs = 0
        for domain in sim.domains.itervalues():
            if isinstance(domain, Single):
                num_assocs += len(domain.shell_list)
            elif isinstance(domain, Pair):
                num_assocs += 2 * len(domain.shell_list)
            elif isinstance(domain, Multi):
                assert getattr(domain, 'pid_shell_id_map', None), 'Cannot access pid_shell_id_map'
                num_assocs += len(domain.pid_shell_id_map)

        dtype_obj = numpy.dtype(SHELL_PARTICLE_ASSOCIATION_SCHEMA)
        x = numpy.zeros((num_assocs, ), dtype = dtype_obj)

        count = 0
        for did, domain in sim.domains.iteritems():

            if(isinstance(domain, Single) or
               isinstance(domain, Pair)):

                pid_particle_pair_list = []
                if isinstance(domain, Single):
                    pid_particle_pair_list = [domain.pid_particle_pair]
                elif isinstance(domain, Pair):
                    pid_particle_pair_list = [domain.single1.pid_particle_pair,
                                              domain.single2.pid_particle_pair]

                for pid, particle in pid_particle_pair_list:
                    for shell_id, shell in domain.shell_list:
                        x['shell_id'][count] = shell_id.serial
                        x['particle_id'][count] = pid.serial
                        count += 1

            else: # for Multi
                assert getattr(domain, 'pid_shell_id_map', None), 'Cannot access pid_shell_id_map'
                for pid, shell_id in domain.pid_shell_id_map.iteritems():
                    x['shell_id'][count] = shell_id.serial
                    x['particle_id'][count] = pid.serial
                    count += 1

        dummy = time_group.create_dataset('shell_particle_association', data = x)

        # Create domain_shell_association dataset on the time group
        dtype_obj = numpy.dtype(DOMAIN_SHELL_ASSOCIATION_SCHEMA)
        x = numpy.zeros((num_shells, ), dtype = dtype_obj)

        count = 0
        for did, domain in sim.domains.iteritems():
            shell_list = domain.shell_list
            for shell_id, shell in shell_list:
                x['shell_id'][count] = shell_id.serial
                x['domain_id'][count] = did.serial
                count += 1

        dummy = time_group.create_dataset('domain_shell_association', data = x)

        # Create domain dataset on the time group
        num_domains = len(sim.domains)

        dtype_obj = numpy.dtype(DOMAINS_SCHEMA)
        x = numpy.zeros((num_domains, ), dtype = dtype_obj)

        count = 0
        for did, domain in sim.domains.iteritems():
            x['id'][count] = did.serial
            if isinstance(domain, Single):
                x['kind'][count] = 1
            elif isinstance(domain, Pair):
                x['kind'][count] = 2
            else: # must be Multi
                x['kind'][count] = 3
            count += 1

        dummy = time_group.create_dataset('domains', data = x)

    def log(self, sim, time):
        self.new_hdf5_file(sim)
        self.write_domains(sim)
        self.write_particles(sim)

    def start(self, sim):
        self.new_hdf5_file(sim)
        self.write_domains(sim)
        self.write_particles(sim)


class Logger(object):
    def __init__(self, logname='log', directory='data', comment=''):
        self.logname = logname
        self.file_counter = 0
        self.directory = directory
        self.comment = comment
        self.timecourse_file = None

    def prepare_timecourse_file(self, sim):
        if not os.path.exists(self.directory):
            os.mkdir(self.directory)
        timecourse_filename = '%s_tc.dat' % self.logname
        self.timecourse_file = open(
            os.path.join(self.directory, timecourse_filename), 'w')
        self.write_timecourse_comment(self.comment)

        species_name_list = '\'' + \
            "\', \'".join(sim.world.model.get_species_type_by_id(i.id)['name']
                          for i in sim.world.species) + '\''
        columns = '[\'t\', ' + species_name_list + ']'
        self.write_timecourse_comment('@ columns= ' + columns)

    def write_timecourse_comment(self, s):
        self.timecourse_file.write('#' + s + '\n')

    def write_timecourse(self, sim):
        data = []
        self.timecourse_file.write('%g' % sim.t + '\t')
        self.timecourse_file.write('\t'.join(
            str(len(sim.world.get_particle_ids(i.id))) \
            for i in sim.get_species()) + '\n')
        self.timecourse_file.flush()

    def write_particles(self, sim):
        if not os.path.exists(self.directory):
            os.mkdir(self.directory)
        filename = '%s_%04d.dat' % (self.logname, self.file_counter)
        file = open(os.path.join(self.directory, filename), 'w')

        file.write('#@ name = \'%s\'\n' % str(self.logname))
        file.write('#@ count = %d\n' % int(self.file_counter))
        file.write('#@ t = %s\n' % '%g' % sim.t)
        file.write('#@ world_size = %f\n' % float(sim.world.world_size))
        file.write('#--------\n')

        for species in sim.world.species:
            pid_list = sim.world.get_particle_ids(species.id)
            for pid in pid_list:
                pid, particle = sim.world.get_particle(pid)
                st = sim.world.model.get_species_type_by_id(species.id)
                file.write('%s\t%20.14g %20.14g %20.14g %.15g\n' %
                           (st['name'], particle.position[0], 
                            particle.position[1], particle.position[2],
                            species.radius))

            file.write('#\n')

        file.close()

        self.file_counter += 1

    def log(self, sim, time):
        if sim.last_reaction:
            self.write_timecourse(sim)
        self.write_particles(sim)

    def start(self, sim):
        self.prepare_timecourse_file(sim)
        self.write_timecourse(sim)
        self.write_particles(sim)
 </xmp> 
<h3> make_cjy_table.py </h3> <xmp>

#!/usr/bin/python


import math
import numpy
import scipy.special as special

import string



def minz_j(n):
    
    # there is no singularity in besselJ at z=0
    return 0

def minz_y(n):
    # from GSL 1.12 bessel_Yn.c:
    # if(x < 5.0) {
    #   int status = bessel_Yn_small_x(n, x, result);
    return 5.

def maxz_j(n):

    # from GSL 1.12 bessel_Jn.c
    # else if(GSL_ROOT4_DBL_EPSILON * x > (n*n+1.0)) {
    #  int status = gsl_sf_bessel_Jnu_asympx_e((double)n, x, result);
    #  ...

    z = (n * n + 1) / 1.221e-4

    # but z can be too large..
    if z >= 1000:
        z = max(1000, n * n)

    return z


def maxz_y(n):

    # from GSL 1.12 bessel_Yn.c
    #  else if(GSL_ROOT3_DBL_EPSILON * x > (l*l + l + 1.0)) {
    #     int status = gsl_sf_bessel_Ynu_asympx_e(l + 0.5, x, result);
      #     ...
    z = (n * n + n + 1) / 6.06e-6

    # ... but this is usually too big.
    if z >= 2000:
        z = max(2000, n * n)

    return z


def JnYn(maxn, resolution):

    delta = numpy.pi / resolution
    z_table = numpy.mgrid[min(minz_j(maxn),minz_y(maxn)):
                              max(maxz_j(maxn), maxz_y(maxn)):delta]

    J_table = []
    Jdot_table = []
    Y_table = []
    Ydot_table = []
    for n in range(maxn+1):
        J_table.append(special.jn(n, z_table)) 
        Jdot_table.append(special.jvp(n, z_table))
        Y_table.append(special.yn(n, z_table))
        Ydot_table.append(special.yvp(n, z_table))

    return z_table, J_table, Jdot_table, Y_table, Ydot_table

def write_header(file):

    template = '''#ifndef CYLINDRICAL_BESSEL_TABLE_HPP
#define CYLINDRICAL_BESSEL_TABLE_HPP

/* Auto-generated by a script.  Do not edit. */

namespace cb_table
{

struct Table
{
    const unsigned int N;
    const double x_start;
    const double delta_x;
    const double* const y;
};
'''

    file.write(template)

def write_footer(file):

    template = '''
}  // namespace cbjy_table

#endif /* CYLINDRICAL_BESSEL_TABLE_HPP */
'''

    file.write(template)

def write_table_array(file, name, minn, maxn):

    file.write('static unsigned int %s_min(%d);\n' % (name, minn)) 
    file.write('static unsigned int %s_max(%d);\n' % (name, maxn)) 
    file.write('static const Table* %s[%d + 1] =\n{\n' % (name, maxn)) 

    for n in range(minn):
        file.write('    0,\n')

    for n in range(minn, maxn+1):
        file.write('    &%s%d,\n' % (name, n))

    file.write('};\n\n')


def write_array(file, name, table):

    head_template = '''
static const double %s[%d + 1] =
{\n'''

    number_template = '''    %.18f'''
    foot_template = '''};\n'''

    N = len(table)

    file.write(head_template % (name, N))
    file.write(',\n'.join([number_template % n for n in table]))
    file.write(foot_template)

def write_arrays(file, name, table1, table2):

    head_template = '''
static const double %s[%d + 1] =
{\n'''

    number_template = '''    %.18e, %.18e'''
    foot_template = '''};\n'''

    # check if len(table1) == len(table2)
    N = len(table1)

    file.write(head_template % (name, N * 2))

    file.write(',\n'.join([number_template % (value, table2[i]) for i, value in enumerate(table1)]))

    file.write(foot_template)


def write_table(file, name, N, x_start, delta_x):

    struct_template = '''
static const Table %s = { %d, %.18f, %.18f, %s_f };

'''

    file.write(struct_template % (name, N, x_start, delta_x, name))



if __name__ == '__main__':

    import sys

    filename = sys.argv[1]

    file = open(filename, 'w')

    minn_j = 0
    # this should be larger (than maxn_y), but the table bloats.
    maxn_j = 50

    minn_y = 0

    maxn_y = 50


    resolution = 35

    write_header(file)

    z_table, j_table, jdot_table, y_table, ydot_table \
        = JnYn(max(maxn_j, maxn_y), resolution)

    delta_z = z_table[1]-z_table[0]

    # j
    for n in range(minn_j, maxn_j + 1):

        start = numpy.searchsorted(z_table, minz_j(n))
        end = numpy.searchsorted(z_table, maxz_j(n))
        z_start = z_table[start]
        j = j_table[n][start:end]
        jdot = jdot_table[n][start:end]
        write_arrays(file, 'cj_table%d_f' % n, j, jdot)
        write_table(file, 'cj_table%d' % n, end-start, z_start, delta_z)
    print 'j', len(j)

    # y
    for n in range(minn_y, maxn_y + 1):

        start = numpy.searchsorted(z_table, minz_y(n))
        end = numpy.searchsorted(z_table, maxz_y(n))
        z_start = z_table[start]
        y = y_table[n][start:end]
        ydot = ydot_table[n][start:end]
        write_arrays(file, 'cy_table%d_f' % n, y, ydot)
        write_table(file, 'cy_table%d' % n, end-start, z_start, delta_z)

    print 'y', len(y)

    write_table_array(file, 'cj_table', minn_j, maxn_j)
    write_table_array(file, 'cy_table', minn_y, maxn_y)

    write_footer(file)

    file.write('\n')

    file.close()

 </xmp> 
<h3> make_sjy_table.py </h3> <xmp>

#!/usr/bin/python


import math
import numpy
import scipy.special as special

import string



def minz_j(n):
    
    # We can start table interpolation from zero because there is
    # no singularity in bessel_j for z>=0.
    return 0

def minz_y(n):

    #return max(3., n)
    return .5


def maxz_j(n):

    z = (n * n + n + 1) / 1.221e-4

    if z >= 1000:
        z = max(1000, n * n)

    return z


def maxz_y(n):

    # from gsl/special/bessel_y.c:
    #  else if(GSL_ROOT3_DBL_EPSILON * x > (l*l + l + 1.0)) {
    #     int status = gsl_sf_bessel_Ynu_asympx_e(l + 0.5, x, result);
    #     ...
    z = (n * n + n + 1) / 6.06e-6

    # ... but this is usually too big.
    if z >= 2000:
        z = max(2000, n * n)

    return z


def jnyn(n, resolution):

    delta = numpy.pi / resolution
    z_table = numpy.mgrid[min(minz_j(n),minz_y(n)):max(maxz_j(n), maxz_y(n)):delta]

    j_table = numpy.zeros((len(z_table), n+1))
    jdot_table = numpy.zeros((len(z_table), n+1))
    y_table = numpy.zeros((len(z_table), n+1))
    ydot_table = numpy.zeros((len(z_table), n+1))

    for i, z in enumerate(z_table):
        j_table[i], jdot_table[i], y_table[i], ydot_table[i] \
            = special.sph_jnyn(n, z)

    j_table = j_table.transpose()
    jdot_table = jdot_table.transpose()
    y_table = y_table.transpose()
    ydot_table = ydot_table.transpose()
    return z_table, j_table, jdot_table, y_table, ydot_table

def make_table(func, n, z0, z1, tol):

    z = z0

    dz = numpy.pi / 100

    j, jp = func(n, z)
    j_prev = j[n]
    jp_prev = jp[n]
    jpp_prev = 0

    z_table = numpy.array([z, ])
    y_table = numpy.array([j[n], ])

    while z < z1:
        j, jp = func(n, z + dz)
        abs_jpp_norm = abs((jp[n] - jp_prev) * dz)

        if abs_jpp_norm > tol:# or abs(j[n] - j_prev) > tol:
            dz *= .5
            continue 

        z += dz

        z_table = numpy.append(z_table, z)
        y_table = numpy.append(y_table, j[n])

        if abs_jpp_norm < tol * .5:
            dz *= 2

        jpp_prev = abs_jpp_norm
        jp_prev = jp[n]

    assert len(z_table) == len(y_table)

    return z_table, y_table


def write_header(file):

    template = '''#ifndef SPHERICAL_BESSEL_TABLE_HPP
#define SPHERICLA_BESSEL_TABLE_HPP

/* Auto-generated by a script.  Do not edit. */

namespace sb_table
{

struct Table
{
    const unsigned int N;
    const double x_start;
    const double delta_x;
    const double* const y;
};
'''

    file.write(template)

def write_footer(file):

    template = '''
}  // namespace sbjy_table

#endif /* SPHERICAL_BESSEL_TABLE_HPP */
'''

    file.write(template)

def write_table_array(file, name, minn, maxn):

    file.write('static unsigned int %s_min(%d);\n' % (name, minn)) 
    file.write('static unsigned int %s_max(%d);\n' % (name, maxn)) 
    file.write('static const Table* %s[%d + 1] =\n{\n' % (name, maxn)) 

    for n in range(minn):
        file.write('    0,\n')

    for n in range(minn, maxn+1):
        file.write('    &%s%d,\n' % (name, n))

    file.write('};\n\n')


def write_array(file, name, table):

    head_template = '''
static const double %s[%d + 1] =
{\n'''

    number_template = '''    %.18f'''
    foot_template = '''};\n'''

    N = len(table)

    file.write(head_template % (name, N))
    file.write(',\n'.join([number_template % n for n in table]))
    file.write(foot_template)

def write_arrays(file, name, table1, table2):

    head_template = '''
static const double %s[%d + 1] =
{\n'''

    number_template = '''    %.18e, %.18e'''
    foot_template = '''};\n'''

    # check if len(table1) == len(table2)
    N = len(table1)

    file.write(head_template % (name, N * 2))

    file.write(',\n'.join([number_template % (value, table2[i]) for i, value in enumerate(table1)]))

    file.write(foot_template)


def write_table(file, name, N, x_start, delta_x):

    struct_template = '''
static const Table %s = { %d, %.18f, %.18f, %s_f };

'''

    file.write(struct_template % (name, N, x_start, delta_x, name))



if __name__ == '__main__':

    import sys

    filename = sys.argv[1]

    file = open(filename, 'w')

    minn_j = 4
    # this should be larger (than maxn_y), but the table bloats.
    maxn_j = 51

    minn_y = 3
    # GSL always uses Olver asymptotic form for n > 40
    maxn_y = 40


    resolution = 35

    write_header(file)

    z_table, j_table, jdot_table, y_table, ydot_table \
        = jnyn(max(maxn_j, maxn_y), resolution)

    delta_z = z_table[1]-z_table[0]

    # j
    for n in range(minn_j, maxn_j + 1):

        start = numpy.searchsorted(z_table, minz_j(n))
        end = numpy.searchsorted(z_table, maxz_j(n))
        z_start = z_table[start]
        j = j_table[n][start:end]
        jdot = jdot_table[n][start:end]
        write_arrays(file, 'sj_table%d_f' % n, j, jdot)
        write_table(file, 'sj_table%d' % n, end-start, z_start, delta_z)
    print 'j', len(j)

    # y
    for n in range(minn_y, maxn_y + 1):

        start = numpy.searchsorted(z_table, minz_y(n))
        end = numpy.searchsorted(z_table, maxz_y(n))
        z_start = z_table[start]
        y = y_table[n][start:end]
        ydot = ydot_table[n][start:end]
        write_arrays(file, 'sy_table%d_f' % n, y, ydot)
        write_table(file, 'sy_table%d' % n, end-start, z_start, delta_z)

    print 'y', len(y)

    write_table_array(file, 'sj_table', minn_j, maxn_j)
    write_table_array(file, 'sy_table', minn_y, maxn_y)

    write_footer(file)

    file.write('\n')

    file.close()

 </xmp> 
<h3> model.py </h3> <xmp>

import _gfrd
from _gfrd import create_cuboidal_region, create_cylindrical_surface, \
        create_planar_surface
import numpy

__all__ = [
    'Species',
    'ParticleModel',
    'create_unimolecular_reaction_rule',
    'create_decay_reaction_rule',
    'create_annihilation_reaction_rule',
    'create_binding_reaction_rule',
    'create_unbinding_reaction_rule',

    # From _gfrd. Should be part of the model class.
    'create_cuboidal_region',
    'create_cylindrical_surface',
    'create_planar_surface',
    ]


# Define _gfrd docstrigns here, much easier to format than in C++.
_gfrd.create_cuboidal_region.__doc__ = \
"""create_cuboidal_region(id, corner, diagonal)

Create and return a new cuboidal Region.

Arguments:
    - id
        a descriptive name.
    - corner
        the point [x, y, z] of the cuboidal Region closest to
        [0, 0, 0]. Units: [meters, meters, meters]
    - diagonal
        the vector [x, y, z] from the corner closest to [0, 0, 0], to 
        the corner furthest away from [0, 0, 0]. Units:
        [meters, meters, meters]

"""

_gfrd.create_cylindrical_surface.__doc__ = \
"""create_cylindrical_surface(id, corner, radius, orientation, length)

Create and return a new cylindrical Surface.

Arguments:
    - id
        a descriptive name.
    - corner
        the point [x, y, z] on the axis of the cylinder closest to 
        [0, 0, 0]. Units: [meters, meters, meters]
    - radius
        the radius of the cylinder. Units: meters.
    - orientation
        the unit vector [1, 0, 0], [0, 1, 0] or [0, 0, 1] along the 
        axis of the cylinder.
    - length
        the length of the cylinder. Should be equal to the world_size. 
        Units: meters.

Surfaces are not allowed to touch or overlap.

"""

_gfrd.create_planar_surface.__doc__ = \
"""create_planar_surface(id, corner, unit_x, unit_y, length_x, length_y)

Create and return a new planar Surface.

Arguments:
    - id
        a descriptive name.
    - corner
        the point [x, y, z] on the plane closest to [0, 0, 0]. Units: 
        [meters, meters, meters]
    - unit_x
        a unit vector [1, 0, 0], [0, 1, 0] or [0, 0, 1] along the 
        plane.
    - unit_y
        a unit vector [1, 0, 0], [0, 1, 0] or [0, 0, 1] along the plane 
        and perpendicular to unit_x.
    - length_x
        the length of the plane along the unit vector unit_x. Should be 
        equal to the world_size. Units: meters.
    - length_y
        the length of the plane along the unit vector unit_y. Should be 
        equal to the world_size. Units: meters.

Surfaces are not allowed to touch or overlap.

"""

_gfrd.Model.add_species_type.im_func.__doc__ = \
"""add_species_type(self, species)

Add a Species to the ParticleModel.

Arguments:
    - species
        a Species created with the function model.Species.

"""


def Species(name, D, radius=0, structure="world", drift=0):
    """Define a new Species (in/on a specific Region or Surface).

    Arguments:
        - name
            the name of this Species.
        - D
            the diffusion constant for this Species in/on this 
            Region or Surface. Units: meters^2/second.
        - radius
            the radius for this Species in/on this Region or Surface. 
            Units: meters.
        - structure
            the Region or Surface in/on which this Species can exist.  
            Optional. If you do not specify a Structure the Species is 
            added to the "world".
        - drift
            the drift term for this ParticleType on a 
            CylindricalSurface (1D drift). Units: meters/second. 
            Optional.

    If a certain Species should be able to exist in the "world" as 
    well as in/on one of the previously created Regions or Surfaces, 
    then two distinct Species should be created. One with and one 
    without an explicit Structure argument.

    """
    st = _gfrd.SpeciesType()
    st["name"] = str(name)
    st["D"] = str(D)
    st["v"] = str(drift)
    st["radius"] = str(radius)
    st["structure"] = structure
    return st


class ParticleModel(_gfrd.Model):
    """
    """
    def __init__(self, world_size):
        """Create a new ParticleModel.

        Arguments:
            - world_size
                the size of one side of the simulation "world". Units: 
                meters.

        The simulation "world" is always assumed to be a cube with 
        *periodic boundary conditions*, with 1 corner at [0, 0, 0] and 
        the corner furthest away from [0, 0, 0] being at
        [world_size, world_size, world_size].

        """
        _gfrd.Model.__init__(self)
        self.world_size = world_size
        self.structures = {}

        # Particles of a Species whose Surface is not specified will be 
        # added to the "world". Dimensions don't matter, except for 
        # visualization.
        x = numpy.repeat(world_size / 2, 3)
        region = _gfrd.CuboidalRegion('world', _gfrd.Box(x, x))
        self.add_structure(region)

    def add_structure(self, structure):
        """Add a Structure (Region or Surface) to the ParticleModel.

        Arguments:
            - structure
              a Region or Surface created with one of the functions
              model.create_<>_region or model.create_<>_surface.

        """
        assert isinstance(structure, _gfrd.Structure)
        self.structures[structure.id] = structure
        return structure

    def add_reaction_rule(self, reaction_rule):
        """Add a ReactionRule to the ParticleModel.

        Argument:
            - reaction rule
                a ReactionRule created by one of the functions
                model.create_<>_reaction_rule.

        """
        self.network_rules.add_reaction_rule(reaction_rule)

    def get_structure(self, id): 
        return self.structures[id]

    def set_all_repulsive(self):
        """Set all 'other' possible ReactionRules to be repulsive.

        By default an EGFRDSimulator will assume:
            - a repulsive bimolecular reaction rule (k=0) for each 
              possible combination of reactants for which no 
              bimolecular reaction rule is specified. 
          
        This method explicitly adds these ReactionRules to the 
        ParticleModel.

        """
        nr = self.network_rules
        # Maybe the user has defined a reaction rule for any 2 species since a 
        # previous call to this method, so remove *all* repulsive reaction 
        # rules first.
        for species1 in self.species_types:
            for species2 in self.species_types:
                gen = nr.query_reaction_rule(species1, species2)
                if gen is not None:
                    for reaction_rule in gen:
                        if float(reaction_rule['k']) == 0.0:
                            nr.remove_reaction_rule(reaction_rule)

        for species1 in self.species_types:
            for species2 in self.species_types:
                gen = nr.query_reaction_rule(species1, species2)
                if gen is None or len(set(gen)) == 0:
                    rr = _gfrd.ReactionRule([species1, species2], [])
                    rr['k'] = '0.0'
                    nr.add_reaction_rule(rr)

def create_unimolecular_reaction_rule(reactant, product, k):
    """Example: A -> B.

    Arguments:
        - reactant
            a Species.
        - product 
            a Species.
        - k
            reaction rate. Units: per second. (Rough order of magnitude: 
            1e-2 /s to 1e2 /s).

    The reactant and the product should be in/on the same 
    Region or Surface.

    There is no distinction between an intrinsic and an overall reaction 
    rate for a unimolecular ReactionRule.

    A unimolecular reaction rule defines a Poissonian process.

    """
    rr = _gfrd.ReactionRule([reactant], [product])
    rr['k'] = '%.16g' % k
    return rr

def create_decay_reaction_rule(reactant, k):
    """Example: A -> 0.

    Arguments:
        - reactant
            a Species.
        - k
            reaction rate. Units: per second. (Rough order of magnitude: 
            1e-2 /s to 1e2 /s).

    There is no distinction between an intrinsic and an overall reaction 
    rate for a decay ReactionRule.

    A decay reaction rule defines a Poissonian process.

    """
    rr = _gfrd.ReactionRule([reactant], [])
    rr['k'] = '%.16g' % k
    return rr

def create_annihilation_reaction_rule(reactant1, reactant2, ka):
    """Example: A + B -> 0.

    Arguments:
        - reactant1
            a Species.
        - reactant2
            a Species.
        - ka
            intrinsic reaction rate. Units: meters^3 per second. (Rough 
            order of magnitude: 1e-16 m^3/s to 1e-20 m^3/s).

    The reactants should be in/on the same Region or Surface.

    ka should be an *intrinsic* reaction rate. You can convert an 
    overall reaction rate (kon) to an intrinsic reaction rate (ka) with 
    the function utils.k_a(kon, kD), but only for reaction rules in 3D.

    By default an EGFRDSimulator will assume a repulsive 
    bimolecular reaction rule (ka=0) for each possible combination of 
    reactants for which no bimolecular reaction rule is specified. 
    You can explicitly add these reaction rules to the model with the 
    method model.ParticleModel.set_all_repulsive.

    """
    rr = _gfrd.ReactionRule([reactant1, reactant2], [])
    rr['k'] = '%.16g' % ka
    return rr

def create_binding_reaction_rule(reactant1, reactant2, product, ka):
    """Example: A + B -> C.

    Arguments:
        - reactant1
            a Species.
        - reactant2
            a Species.
        - product
            a Species.
        - ka
            intrinsic reaction rate. Units: meters^3 per second. (Rough 
            order of magnitude: 1e-16 m^3/s to 1e-20 m^3/s)

    The reactants and the product should be in/on the same 
    Region or Surface.

    A binding reaction rule always has exactly one product.

    ka should be an *intrinsic* reaction rate. You can convert an 
    overall reaction rate (kon) to an intrinsic reaction rate (ka) with 
    the function utils.k_a(kon, kD), but only for reaction rules in 3D.

    By default an EGFRDSimulator will assume a repulsive 
    bimolecular reaction rule (ka=0) for each possible combination of 
    reactants for which no bimolecular reaction rule is specified. 
    You can explicitly add these reaction rules to the model with the 
    method model.ParticleModel.set_all_repulsive.

    """
    rr = _gfrd.ReactionRule([reactant1, reactant2], [product])
    rr['k'] = '%.16g' % ka
    return rr

def create_unbinding_reaction_rule(reactant, product1, product2, kd):
    """Example: A -> B + C.

    Arguments:
        - reactant
            a Species.
        - product1
            a Species.
        - product2
            a Species.
        - kd
            intrinsic reaction rate. Units: per second. (Rough order of 
            magnitude: 1e-2 /s to 1e2 /s).

    The reactant and the products should be in/on the same 
    Region or Surface.

    An unbinding reaction rule always has exactly two products.

    kd should be an *intrinsic* reaction rate. You can convert an 
    overall reaction rate (koff) for this reaction rule to an intrinsic 
    reaction rate (kd) with the function utils.k_d(koff, kon, kD) or 
    utils.k_d_using_ka(koff, ka, kD).

    An unbinding reaction rule defines a Poissonian process.

    """
    rr = _gfrd.ReactionRule([reactant], [product1, product2])
    rr['k'] = '%.16g' % kd
    return rr

 </xmp> 
<h3> multi.py </h3> <xmp>

import bd
from weakref import ref

from gfrdbase import *
from utils import *
import itertools

import _gfrd
from constants import EventType

import os

class Multi(object):
    def __init__(self, domain_id, main, dt_factor):
        self.main = ref(main)
        self.domain_id = domain_id
        self.event_id = None
        self.last_event = None
        self.sphere_container = _gfrd.SphericalShellContainer(main.world.world_size, 3)
        self.particle_container = _gfrd.MultiParticleContainer(main.world)
        self.escaped = False
        self.dt_factor = dt_factor
        self.last_reaction = None

    def initialize(self, t):
        self.last_time = t
        self.start_time = t
        main = self.main()
        self.dt = self.dt_factor * bd.calculate_bd_dt(main.world.get_species(sid) for sid in main.world.species)

    def get_multiplicity(self):
        return self.particle_container.num_particles
    multiplicity = property(get_multiplicity)

    def within_shell(self, pp):
        return bool(self.sphere_container.get_neighbors_within_radius(pp[1].position, -pp[1].radius))

    def add_shell(self, shell_id_shell_pair):
        if __debug__:
            log.info("add shell to multi:\n  (%s,\n   %s)" %
                     (shell_id_shell_pair[0], shell_id_shell_pair[1]))
        self.sphere_container.update(shell_id_shell_pair)

    def add_particle(self, pid_particle_pair):
        if __debug__:
            log.info("add particle to multi:\n  (%s,\n   %s)" % 
                     (pid_particle_pair[0], pid_particle_pair[1]))
        self.particle_container.update_particle(pid_particle_pair)

    def step(self):
        self.escaped = False
        tx = self.particle_container.create_transaction()
        main = self.main()

        class check_reaction(object):
            def __init__(self):
                self.reactions = []

            def __call__(self, ri):
                self.reactions.append(ri)

        cr = check_reaction()

        ppg = _gfrd.BDPropagator(tx, main.network_rules,
                     myrandom.rng, self.dt, main.dissociation_retry_moves,
                     cr, [pid for pid, _ in self.particle_container])

        self.last_event = None
        while ppg():
            if cr.reactions:
                self.last_reaction = cr.reactions[-1]
                if len(self.last_reaction.reactants) == 1:
                    self.last_event = EventType.MULTI_UNIMOLECULAR_REACTION
                else:
                    self.last_event = EventType.MULTI_BIMOLECULAR_REACTION
                break

        for pid_particle_pair in itertools.chain(
                tx.modified_particles, tx.added_particles):
            overlapped = main.world.check_overlap(pid_particle_pair[1].shape, pid_particle_pair[0])
            if overlapped:
                if __debug__:
                    log.info("collision occurred between particles of a multi and the outside: %s - %s.  moves will be rolled back." % (pid_particle_pair, list(overlapped)))
                tx.rollback()
                return

            if not self.within_shell(pid_particle_pair):
                if self.last_event == None:
                    self.last_event = EventType.MULTI_ESCAPE
                main.clear_volume(
                    pid_particle_pair[1].position,
                    pid_particle_pair[1].radius, ignore=[self.domain_id, ])

    def check(self):
        # shells are contiguous
        # FIXME: this code cannot detect a pair of shells that are isolated
        #        from others.
        for _, shell in self.shell_list:
            result = self.sphere_container.get_neighbors(shell.shape.position)
            # Check contiguity with nearest neighbor only (get_neighbors 
            # returns a sorted list).
            nearest = result[1]
            distance = nearest[1]
            assert distance - shell.shape.radius < 0.0,\
                'shells of %s are not contiguous.' % str(self)

        # all particles within the shell.
        for pid_particle_pair in self.particle_container:
            assert self.within_shell(pid_particle_pair),\
                'not all particles within the shell.'

        main = self.main()
        for shell_id, shell in self.shell_list:
            container = main.get_container(shell)
            if not container.contains(shell_id):
                raise RuntimeError,\
                    'self.sim.main.sphere_container does not contain %s'\
                    % str(shell_id)
        for shell_id, shell in main.containers[0]:
            if shell.did == self.domain_id:
                if not self.sphere_container.contains(shell_id):
                    raise RuntimeError,\
                        'self.sphere_container does not contain %s'\
                        % str(shell_id)

    def __repr__(self):
        return 'Multi[domain_id=%s, event_id=%s,\n    %s,\n    %s]' % (
            self.domain_id, self.event_id,
            ',\n    '.join('(%s,\n     %s)' % (p[0], repr(p[1])) for p in self.particle_container),
            ',\n    '.join('(%s,\n     %s)' % (s[0], repr(s[1])) for s in self.sphere_container)
            )

    def has_particle(self, pid):
        try:
            self.particle_container.get_particle(pid)
            return True
        except:
            return False

    def particles(self):
        return iter(self.particle_container)
    particles = property(particles)

    def num_shells(self):
        return len(self.sphere_container)
    num_shells = property(num_shells)    

    def shell_list(self):
        return iter(self.sphere_container)
    shell_list = property(shell_list)
 </xmp> 
<h3> myrandom.py </h3> <xmp>

from _gfrd import RandomNumberGenerator, create_gsl_rng, create_static_gsl_rng
import numpy
import os

__all__ = (
    'shuffle',
    'uniform',
    'normal',
    'seed',
    'get_raw'
    )

rng_number_file = os.environ.get('ECELL_STATIC_RNG', None)
if rng_number_file is not None:
    rng = create_static_gsl_rng([int(l.strip()) for l in file(rng_number_file)])
else:
    rng = create_gsl_rng()

def uniform(min=0.0, max=1.0, size=None):
     global rng
     return rng.uniform(min, max)

get_raw = rng.get_raw
random = rng
normal = rng.normal
seed = rng.seed

# By default seed is 0.
myseed = 0

# Choose seed at random.
#import random
#myseed = int(1e3 * random.random())

# Set seed.
seed(myseed)

def shuffle(seq):
    for i in reversed(range(0, len(seq))):
        j = rng.uniform_int(0, i)
        seq[i], seq[j] = seq[j], seq[i]

def choice(a, b):
    '''Return a or b with 50% probability each.

    '''
    return uniform() > 0.5 and a or b
 </xmp> 
<h3> pair.py </h3> <xmp>

from _gfrd import *
from constants import EventType
from _greens_functions import *
from greens_function_wrapper import *

__all__ = [
    'CylindricalSurfacePair',
    'PlanarSurfacePair',
    'SphericalPair',
    'Pair',
    ]

class Pair(object):
    """There are 3 types of pairs:
        * SphericalPair
        * PlanarSurfacePair
        * CylindricalSurfacePair

    """
    # CUTOFF_FACTOR is a threshold to choose between the real and 
    # approximate Green's functions.
    # H = 4.0: ~3e-5, 4.26: ~1e-6, 5.0: ~3e-7, 5.2: ~1e-7,
    # 5.6: ~1e-8, 6.0: ~1e-9
    CUTOFF_FACTOR = 5.6

    def __init__(self, domain_id, com, single1, single2, shell_id, r0, 
                 shell_size, rt, surface):
        self.multiplicity = 2
        self.num_shells = 1

        self.single1 = single1
        self.single2 = single2 

        self.a_R, self.a_r = self.determine_radii(r0, shell_size)

        self.rt = rt

        self.event_id = None

        self.last_time = 0.0
        self.dt = 0.0
        self.event_type = None

        self.surface = surface

        # Create shell.
        shell = self.create_new_shell(com, shell_size, domain_id)

        self.shell_list = [(shell_id, shell), ]
        self.domain_id = domain_id

    def __del__(self):
        if __debug__:
            log.debug('del %s' % str(self))

    def get_com(self):
        return self.shell_list[0][1].shape.position
    com = property(get_com)

    def get_shell_id(self):
        return self.shell_list[0][0]
    shell_id = property(get_shell_id)

    def get_shell(self):
        return self.shell_list[0][1]
    shell = property(get_shell)

    def get_shell_id_shell_pair(self):
        return self.shell_list[0]
    def set_shell_id_shell_pair(self, value):
        self.shell_list[0] = value
    shell_id_shell_pair = property(get_shell_id_shell_pair, 
                                   set_shell_id_shell_pair)

    def get_shell_size(self):
        return self.shell_list[0][1].shape.radius

    def get_D_tot(self):
        return self.single1.pid_particle_pair[1].D + \
               self.single2.pid_particle_pair[1].D
    D_tot = property(get_D_tot)

    def get_D_R(self):
        return (self.single1.pid_particle_pair[1].D *
                self.single2.pid_particle_pair[1].D) / self.D_tot
    D_R = property(get_D_R)

    def get_v_tot(self):
        return self.single2.pid_particle_pair[1].v - \
               self.single1.pid_particle_pair[1].v
    v_tot = property(get_v_tot)

    v_r = 0 # Todo.

    def get_v_R(self):
        return 0 # Todo.
        return (self.single1.pid_particle_pair[1].v * 
                self.single2.pid_particle_pair[1].D +
                self.single2.pid_particle_pair[1].v *
                self.single1.pid_particle_pair[1].D) / self.D_tot
    v_R = property(get_v_R)

    def getSigma(self):
        return self.single1.pid_particle_pair[1].radius + \
               self.single2.pid_particle_pair[1].radius
    sigma = property(getSigma)

    def initialize(self, t):
        self.last_time = t
        self.dt = 0
        self.event_type = None

    def determine_radii(self, r0, shell_size):
        """Determine a_r and a_R.

        Todo. Make dimension (1D/2D/3D) specific someday. Optimization only.

        """
        single1 = self.single1
        single2 = self.single2
        radius1 = single1.pid_particle_pair[1].radius
        radius2 = single2.pid_particle_pair[1].radius

        D1 = single1.pid_particle_pair[1].D
        D2 = single2.pid_particle_pair[1].D

        # Make sure that D1 != 0 to avoid division by zero in the followings.
        if D1 == 0:
            D1, D2 = D2, D1

        shell_size /= SAFETY

        D_tot = D1 + D2
        D_geom = math.sqrt(D1 * D2)

        assert r0 >= self.sigma, \
            '%s;  r0 %g < sigma %g' % (self, r0, self.sigma)

        # equalize expected mean t_r and t_R.
        if ((D_geom - D2) * r0) / D_tot + shell_size +\
                math.sqrt(D2 / D1) * (radius1 - shell_size) - radius2 >= 0:
            Da = D1
            Db = D2
            radiusa = radius1
            radiusb = radius2
        else:
            Da = D2
            Db = D1
            radiusa = radius2
            radiusb = radius1


        #aR
        a_R = (D_geom * (Db * (shell_size - radiusa) + \
                         Da * (shell_size - r0 - radiusa))) /\
              (Da * Da + Da * Db + D_geom * D_tot)

        #ar
        a_r = (D_geom * r0 + D_tot * (shell_size - radiusa)) / (Da + D_geom)

        assert a_R + a_r * Da / D_tot + radius1 >= \
               a_R + a_r * Db / D_tot + radius2

        assert abs(a_R + a_r * Da / D_tot + radiusa - shell_size) \
            < 1e-12 * shell_size


        if __debug__:
          log.debug('a %g, r %g, R %g r0 %g' % 
                 (shell_size, a_r, a_R, r0))
        if __debug__:
            tr = ((a_r - r0) / math.sqrt(6 * self.D_tot))**2
            if self.D_R == 0:
                tR = numpy.inf 
            else:
                tR = (a_R / math.sqrt(6*self.D_R))**2
            log.debug('tr %g, tR %g' % (tr, tR))


        assert a_r > 0
        assert a_r > r0, '%g %g' % (a_r, r0)
        assert a_R > 0 or (a_R == 0 and (D1 == 0 or D2 == 0))

        return a_R, a_r

    def draw_com_escape_or_iv_event_time_tuple(self, r0):
        """Returns a (event time, event type, reactingsingle=None) tuple.
        
        """
        dt_com = draw_time_wrapper(self.com_greens_function())
        dt_iv = draw_time_wrapper(self.iv_greens_function(r0))
        if dt_com < dt_iv:
            return dt_com, EventType.COM_ESCAPE, None
        else:
            # Note: we are not calling pair.draw_iv_event_type yet, but 
            # postpone it to the very last minute (when this event is 
            # executed in fire_pair). So IV_EVENT can still be an iv 
            # escape or an iv reaction.
            return dt_iv, EventType.IV_EVENT, None

    def draw_single_reaction_time_tuple(self):
        """Return a (reaction time, event type, reactingsingle)-tuple.

        """
        dt_reaction1, event_type1 = self.single1.draw_reaction_time_tuple()
        dt_reaction2, event_type2 = self.single2.draw_reaction_time_tuple()
        if dt_reaction1 < dt_reaction2:
            return dt_reaction1, event_type1, self.single1
        else:
            return dt_reaction2, event_type2, self.single2

    def determine_next_event(self, r0):
        """Return a (event time, event type, reactingsingle)-tuple.

        """
        return min(self.draw_com_escape_or_iv_event_time_tuple(r0), 
                   self.draw_single_reaction_time_tuple()) 

    def draw_iv_event_type(self, r0):
        gf = self.iv_greens_function(r0)
        event_kind = draw_event_type_wrapper(gf, self.dt)
        if event_kind == PairEventKind.IV_REACTION:
            return EventType.IV_REACTION
        elif event_kind == PairEventKind.IV_ESCAPE:
            return EventType.IV_ESCAPE
        raise NotImplemented()

    def draw_new_positions(self, dt, r0, old_iv, event_type):
        """Calculate new positions of the pair particles using a new 
        center-of-mass, a new inter-particle vector, and an old 
        inter-particle vector.

        """
        new_com = self.draw_new_com(dt, event_type)
        new_iv = self.draw_new_iv(dt, r0, old_iv, event_type)

        D1 = self.single1.pid_particle_pair[1].D
        D2 = self.single2.pid_particle_pair[1].D

        newpos1 = new_com - new_iv * (D1 / self.D_tot)
        newpos2 = new_com + new_iv * (D2 / self.D_tot)
        return newpos1, newpos2

    def draw_new_com(self, dt, event_type):
        if event_type == EventType.COM_ESCAPE:
            r = self.a_R
        else:
            gf = self.com_greens_function()
            r = draw_r_wrapper(gf, dt, self.a_R)

        displacement = self.create_com_vector(r)

        # Add displacement to old CoM. This assumes (correctly) that 
        # r0=0 for the CoM. Compare this to 1D singles, where r0 is not  
        # necesseraly 0.
        return self.com + displacement

    def draw_new_iv(self, dt, r0, old_iv, event_type):
        gf = self.choose_pair_greens_function(r0, dt)
        if event_type == EventType.IV_ESCAPE:
            r = self.a_r
        elif event_type == EventType.IV_REACTION:
            r = self.sigma
        else:
            r = draw_r_wrapper(gf, dt, self.a_r, self.sigma)

        return self.create_interparticle_vector(gf, r, dt, r0, old_iv)

    def check(self):
        pass

    def __str__(self):
        sid = self.single1.pid_particle_pair[1].sid
        sid2 = self.single2.pid_particle_pair[1].sid
        name = self.world.model.get_species_type_by_id(sid)["name"]
        name2 = self.world.model.get_species_type_by_id(sid2)["name"]
        return 'Pair[%s: %s, %s, (%s, %s)]' % (
            self.domain_id,
            self.single1.pid_particle_pair[0],
            self.single2.pid_particle_pair[0],
            name, name2)

class SphericalPair(Pair):
    """2 Particles inside a (spherical) shell not on any surface.

    """
    def __init__(self, domain_id, com, single1, single2, shell_id,
                 r0, shell_size, rt, surface):
        Pair.__init__(self, domain_id, com, single1, single2, shell_id,
                      r0, shell_size, rt, surface)

    def com_greens_function(self):
        # Green's function for centre of mass inside absorbing sphere.
        return GreensFunction3DAbsSym(self.D_R, self.a_R)

    def iv_greens_function(self, r0):
        # Green's function for interparticle vector inside absorbing 
        # sphere.  This exact solution is used for drawing times.
        return GreensFunction3DRadAbs(self.D_tot, self.rt.ktot, r0,
                                              self.sigma, self.a_r)

    def create_new_shell(self, position, radius, domain_id):
        return SphericalShell(domain_id, Sphere(position, radius))

    def choose_pair_greens_function(self, r0, t):
        distance_from_sigma = r0 - self.sigma
        distance_from_shell = self.a_r - r0

        threshold_distance = Pair.CUTOFF_FACTOR * \
            math.sqrt(6.0 * self.D_tot * t)

        if distance_from_sigma < threshold_distance:
        
            if distance_from_shell < threshold_distance:
                # near both a and sigma;
                # use GreensFunction3DRadAbs
                if __debug__:
                    log.debug('GF: normal')
                return self.iv_greens_function(r0)
            else:
                # near sigma; use GreensFunction3DRadInf
                if __debug__:
                    log.debug('GF: only sigma')
                return GreensFunction3DRadInf(self.D_tot, self.rt.ktot, r0,
                                               self.sigma)
        else:
            if distance_from_shell < threshold_distance:
                # near a;
                if __debug__:
                    log.debug('GF: only a')
                return GreensFunction3DAbs(self.D_tot,
                                                                 r0, self.a_r)
                
            else:
                # distant from both a and sigma; 
                if __debug__:
                    log.debug('GF: free')
                return GreensFunction3D(self.D_tot, r0)

    def create_com_vector(self, r):
        return random_vector(r)

    def create_interparticle_vector(self, gf, r, dt, r0, old_iv): 
        if __debug__:
            log.debug("create_interparticle_vector: r=%g, dt=%g", r, dt)
        theta = draw_theta_wrapper(gf, r, dt)

        new_inter_particle_s = numpy.array([r, theta, 
                                         myrandom.uniform() * 2 * Pi])
        new_iv = spherical_to_cartesian(new_inter_particle_s)

        #FIXME: need better handling of angles near zero and pi.

        # I rotate the new interparticle vector along the
        # rotation axis that is perpendicular to both the
        # z-axis and the original interparticle vector for
        # the angle between these.
        
        # the rotation axis is a normalized cross product of
        # the z-axis and the original vector.
        # rotation_axis = crossproduct([0,0,1], inter_particle)
        angle = vector_angle_against_z_axis(old_iv)
        if angle % numpy.pi != 0.0:
            rotation_axis = crossproduct_against_z_axis(old_iv)
            rotation_axis = normalize(rotation_axis)
            rotated = rotate_vector(new_iv, rotation_axis, angle)
        elif angle == 0.0:
            rotated = new_iv
        else:
            rotated = numpy.array([new_iv[0], new_iv[1], - new_iv[2]])
        return rotated

    def __str__(self):
        return 'Spherical' + Pair.__str__(self)


class PlanarSurfacePair(Pair):
    """2 Particles inside a (cylindrical) shell on a PlanarSurface. 
    (Hockey pucks).

    """
    def __init__(self, domain_id, com, single1, single2, shell_id,
                 r0, shell_size, rt, surface):
        Pair.__init__(self, domain_id, com, single1, single2, shell_id,
                      r0, shell_size, rt, surface)

    def com_greens_function(self):
        # Todo. 2D gf Abs Sym.
        return GreensFunction3DAbsSym(self.D_R, self.a_R)

    def iv_greens_function(self, r0):
        # Todo. 2D gf Rad Abs.
        # This exact solution is used for drawing times.
        return GreensFunction3DRadAbs(self.D_tot, self.rt.ktot, r0,
                                              self.sigma, self.a_r)

    def create_new_shell(self, position, radius, domain_id):
        # The half_length (thickness/2) of a hockey puck is not more 
        # than it has to be (namely the radius of the particle), so if 
        # the particle undergoes an unbinding reaction we still have to 
        # clear the target volume and the move may be rejected (NoSpace 
        # error).
        orientation = crossproduct(self.surface.shape.unit_x,
                                   self.surface.shape.unit_y)
        half_length = max(self.single1.pid_particle_pair[1].radius,
                          self.single2.pid_particle_pair[1].radius)
        return CylindricalShell(domain_id, Cylinder(position, radius, 
                                                    orientation, half_length))

        a_R, a_r = self.determine_radii()

    def choose_pair_greens_function(self, r0, t):
        # Todo
        return self.iv_greens_function(r0)

    def create_com_vector(self, r):
        x, y = random_vector2D(r)
        return x * self.surface.shape.unit_x + y * self.surface.shape.unit_y

    def create_interparticle_vector(self, gf, r, dt, r0, old_iv): 
        if __debug__:
            log.debug("create_interparticle_vector: r=%g, dt=%g", r, dt)
        theta = draw_theta_wrapper(gf, r, dt)

        #FIXME: need better handling of angles near zero and pi?
        unit_x = self.surface.shape.unit_x
        unit_y = self.surface.shape.unit_y
        angle = vector_angle(unit_x, old_iv)
        # Todo. Test if nothing changes when theta == 0.
        new_angle = angle + theta

        new_iv = r * math.cos(new_angle) * unit_x + \
                 r * math.sin(new_angle) * unit_y

        return new_iv

    def __str__(self):
        return 'PlanarSurface' + Pair.__str__(self)


class CylindricalSurfacePair(Pair):
    """2 Particles inside a (cylindrical) shell on a CylindricalSurface.  
    (Rods).

    """
    def __init__(self, domain_id, com, single1, single2, shell_id,
                 r0, shell_size, rt, surface):
        Pair.__init__(self, domain_id, com, single1, single2, shell_id,
                      r0, shell_size, rt, surface)

    def com_greens_function(self):
        # The domain is created around r0, so r0 corresponds to r=0 within the domain
        return GreensFunction1DAbsAbs(self.D_R, self.v_R, 0.0, -self.a_R, self.a_R)

    def iv_greens_function(self, r0):
        return GreensFunction1DRadAbs(self.D_tot, self.v_r, self.rt.ktot, r0, self.sigma, self.a_r)

    def create_new_shell(self, position, half_length, domain_id):
        # The radius of a rod is not more than it has to be (namely the 
        # radius of the biggest particle), so if the particle undergoes 
        # an unbinding reaction we still have to clear the target volume 
        # and the move may be rejected (NoSpace error).
        radius = max(self.single1.pid_particle_pair[1].radius,
                     self.single2.pid_particle_pair[1].radius)
        orientation = self.surface.shape.unit_z
        return CylindricalShell(domain_id, Cylinder(position, radius, 
                                                    orientation, half_length))

    def choose_pair_greens_function(self, r0, t):
        # Todo
        return self.iv_greens_function(r0)

    def create_com_vector(self, r):
        return r * self.surface.shape.unit_z

    def create_interparticle_vector(self, gf, r, dt, r0, old_iv): 
        if __debug__:
            log.debug("create_interparticle_vector: r=%g, dt=%g", r, dt)
        # Note: using self.surface.shape.unit_z here might accidently 
        # interchange the particles.
        return r * normalize(old_iv)

    def get_shell_size(self):
        # Heads up.
        return self.shell_list[0][1].shape.half_length

    def __str__(self):
        return 'CylindricalSurface' + Pair.__str__(self)




 </xmp> 
<h3> single.py </h3> <xmp>

from _gfrd import *
from _greens_functions import *
from greens_function_wrapper import *
from constants import EventType
import utils

__all__ = [
    'CylindricalSurfaceSingle',
    'PlanarSurfaceSingle',
    'SphericalSingle',
    'Single',
    ]

class Single(object):
    """There are 2 main types of Singles:
        * NonInteractionSingle
        * InteractionSingle (when the particle is nearby a surface)

    Each type of Single defines a list of coordinates, see 
    coordinate.py. For each coordinate the Green's function is 
    specified.

    """
    def __init__(self, domain_id, pid_particle_pair, shell_id, reactiontypes, 
                 surface):
        self.multiplicity = 1
        self.num_shells = 1

        self.pid_particle_pair = pid_particle_pair
        self.reactiontypes = reactiontypes

        self.k_tot = 0

        self.last_time = 0.0
        self.dt = 0.0
        self.event_type = None

        self.surface = surface

        # Create shell.
        shell = self.create_new_shell(pid_particle_pair[1].position,
                                      pid_particle_pair[1].radius, domain_id)

        self.shell_list = [(shell_id, shell), ]

        self.event_id = None

        self.domain_id = domain_id

        self.updatek_tot()

    def getD(self):
        return self.pid_particle_pair[1].D
    D = property(getD)

    def getv(self):
        return 0 # TODO.
        return self.pid_particle_pair[1].v
    v = property(getv)

    def get_shell_id(self):
        return self.shell_list[0][0]
    shell_id = property(get_shell_id)

    def get_shell(self):
        return self.shell_list[0][1]
    shell = property(get_shell)

    def get_shell_id_shell_pair(self):
        return self.shell_list[0]
    def set_shell_id_shell_pair(self, value):
        self.shell_list[0] = value
    shell_id_shell_pair = property(get_shell_id_shell_pair, 
                                   set_shell_id_shell_pair)

    def initialize(self, t):
        '''
        Reset the Single.

        Radius (shell size) is shrunken to the actual radius of the 
        particle.  self.dt is reset to 0.0.  Do not forget to reschedule 
        this Single after calling this method.
        '''
        self.dt = 0.0
        self.last_time = t
        self.event_type = EventType.SINGLE_ESCAPE

    def is_reset(self):
        return self.dt == 0.0 and self.event_type == EventType.SINGLE_ESCAPE

    def draw_reaction_time_tuple(self):
        """Return a (reaction time, event type)-tuple.

        """
        if self.k_tot == 0:
            dt = numpy.inf
        elif self.k_tot == numpy.inf:
            dt = 0.0
        else:
            dt = (1.0 / self.k_tot) * math.log(1.0 / myrandom.uniform())
        return dt, EventType.SINGLE_REACTION

    def draw_interaction_time(self):
        """Todo.
        
        Note: we are not calling single.drawEventType() just yet, but 
        postpone it to the very last minute (when this event is executed 
        in fire_single). So IV_EVENT can still be an iv escape or an iv 
        interaction.

        """
        pass

    def draw_escape_or_interaction_time_tuple(self):
        """Return an (escape or interaction time, event type)-tuple.

        Handles also all interaction events.
        
        """
        if self.getD() == 0:
            dt = numpy.inf
        else:
            dt = draw_time_wrapper(self.greens_function())

        event_type = EventType.SINGLE_ESCAPE
        return dt, event_type

    def determine_next_event(self):
        """Return an (event time, event type)-tuple.

        """
        return min(self.draw_escape_or_interaction_time_tuple(),
                   self.draw_reaction_time_tuple())

    def updatek_tot(self):
        self.k_tot = 0

        if not self.reactiontypes:
            return

        for rt in self.reactiontypes:
            self.k_tot += rt.k

    def draw_reaction_rule(self):
        k_array = [rt.k for rt in self.reactiontypes]
        k_array = numpy.add.accumulate(k_array)
        k_max = k_array[-1]

        rnd = myrandom.uniform()
        i = numpy.searchsorted(k_array, rnd * k_max)

        return self.reactiontypes[i]

    def check(self):
        pass

    def __str__(self):
        pid = self.pid_particle_pair[0]
        sid = self.pid_particle_pair[1].sid
        name = self.world.model.get_species_type_by_id(sid)["name"]
        if name[0] != '(':
            name = '(' + name + ')'
        return 'Single[%s: %s, ST%s]' % (self.domain_id, pid, name)


class NonInteractionSingle(Single):
    """1 Particle inside a shell, no other particles around. 

    There are 3 types of NonInteractionSingles:
        * SphericalSingle: spherical shell, 3D movement.
        * PlanarSurfaceSingle: cylindrical shell, 2D movement.
        * CylindricalSurfaceSingle: cylindrical shell, 1D movement.

    """
    def __init__(self, domain_id, pid_particle_pair, shell_id, reactiontypes, 
                 surface):
        Single.__init__(self, domain_id, pid_particle_pair, shell_id,
                        reactiontypes, surface)

    def get_mobility_radius(self):
        return self.get_shell_size() - self.pid_particle_pair[1].radius

    def get_shell_size(self):
        return self.shell_list[0][1].shape.radius

    def draw_new_position(self, dt, event_type):
        if event_type == EventType.SINGLE_ESCAPE:
            # Moving this checks to the Green's functions is not a good 
            # idea, because then you'd draw an unused random number.  
            # The same yields for the draw_new_com and draw_new_iv.  
            r = self.get_mobility_radius()
        else:
            gf = self.greens_function()
            r = draw_r_wrapper(gf, dt, self.get_mobility_radius())

        displacement = self.create_position_vector(r)

        if __debug__:
            scale = self.pid_particle_pair[1].radius
            if feq(length(displacement), abs(r), typical=scale) == False:
                raise AssertionError('displacement != abs(r): %g != %g.' % 
                                     (length(displacement), abs(r)))

        # Add displacement to shape.position, not to particle.position.  
        # This distinction is important only in the case of an 
        # asymmetric 1D domain (r0 != 0, or drift), since draw_r always 
        # returns a position relative to the centre of the shell (r=0), 
        # not relative to r0.
        return self.shell.shape.position + displacement


class SphericalSingle(NonInteractionSingle):
    """1 Particle inside a (spherical) shell not on any surface.

        * Particle coordinate inside shell: r, theta, phi.
        * Coordinate: radial r.
        * Initial position: r = 0.
        * Selected randomly when drawing displacement vector:
          theta, phi.

    """
    def __init__(self, domain_id, pid_particle_pair, shell_id, reactiontypes, 
                 surface):
        NonInteractionSingle.__init__(self, domain_id, pid_particle_pair, 
                                      shell_id, reactiontypes, surface)

    def greens_function(self):
        return GreensFunction3DAbsSym(self.getD(),
                                          self.get_mobility_radius())

    def create_new_shell(self, position, radius, domain_id):
        return SphericalShell(domain_id, Sphere(position, radius))

    def create_position_vector(self, r):
        return random_vector(r)

    def __str__(self):
        return 'Spherical' + Single.__str__(self)


class PlanarSurfaceSingle(NonInteractionSingle):
    """1 Particle inside a (cylindrical) shell on a PlanarSurface. (Hockey 
    pucks).

        * Particle coordinates on surface: x, y.
        * Domain: radial r. (determines x and y together with theta).
        * Initial position: r = 0.
        * Selected randomly when drawing displacement vector: theta.

    """
    def __init__(self, domain_id, pid_particle_pair, shell_id, reactiontypes, 
                 surface):
        NonInteractionSingle.__init__(self, domain_id, pid_particle_pair, 
                                      shell_id, reactiontypes, surface)

    def greens_function(self):
        # Todo. 2D gf Abs Sym.
        #gf = GreensFunction2DAbsSym(self.getD())
        return GreensFunction3DAbsSym(self.getD(),
                                          self.get_mobility_radius())

    def create_new_shell(self, position, radius, domain_id):
        # The half_length (thickness) of a hockey puck is not more than 
        # it has to be (namely the radius of the particle), so if the 
        # particle undergoes an unbinding reaction we still have to 
        # clear the target volume and the move may be rejected (NoSpace 
        # error).
        orientation = normalize(
            utils.crossproduct(self.surface.shape.unit_x,
                               self.surface.shape.unit_y))
        half_length = self.pid_particle_pair[1].radius
        return CylindricalShell(domain_id, Cylinder(position, radius, 
                                                    orientation, half_length))

    def create_position_vector(self, r):
        x, y = random_vector2D(r)
        return x * self.surface.shape.unit_x + y * self.surface.shape.unit_y

    def __str__(self):
        return 'PlanarSurface' + Single.__str__(self)


class CylindricalSurfaceSingle(NonInteractionSingle):
    """1 Particle inside a (cylindrical) shell on a CylindricalSurface. 
    (Rods).

        * Particle coordinates on surface: z.
        * Domain: cartesian z.
        * Initial position: z = 0.
        * Selected randomly when drawing displacement vector: none.

    """
    def __init__(self, domain_id, pid_particle_pair, shell_id, reactiontypes, 
                 surface):
        NonInteractionSingle.__init__(self, domain_id, pid_particle_pair, 
                                      shell_id, reactiontypes, surface)

    def greens_function(self):
        # The domain is created around r0, so r0 corresponds to r=0 within the domain
        return GreensFunction1DAbsAbs(self.getD(), self.getv(), 0.0, -self.get_mobility_radius(), self.get_mobility_radius())

    def create_new_shell(self, position, half_length, domain_id):
        # The radius of a rod is not more than it has to be (namely the 
        # radius of the particle), so if the particle undergoes an 
        # unbinding reaction we still have to clear the target volume 
        # and the move may be rejected (NoSpace error).
        radius = self.pid_particle_pair[1].radius
        orientation = self.surface.shape.unit_z
        return CylindricalShell(domain_id, Cylinder(position, radius, 
                                                    orientation, half_length))

    def create_position_vector(self, z):
        if utils.feq(z, self.get_mobility_radius()):
            # Escape, can be either to the left or to the right.
            z = myrandom.choice(-1, 1) * z 
        return z * self.shell_list[0][1].shape.unit_z

    def get_shell_size(self):
        # Heads up. The cylinder's *half_length*, not radius, 
        # determines the size in case of a cylindrical surface.
        return self.shell_list[0][1].shape.half_length

    def __str__(self):
        return 'CylindricalSurface' + Single.__str__(self)


 </xmp> 
<h3> stickit.py </h3> <xmp>

""" Script to append some files together """
###### HEADER PART get bash command contents ###### 
import sys

###### FUNCTION PART ###### 

# define a function that adds something to a file, in a nice HTML format
def AddToFile(name, contents):
    # AddToFile([name of file], [contents of file]):
    # define content-specific "head"
    head = """ 
<h3> """ + name + """ </h3> <xmp>

"""
    # write contents to file, boxed by head and foot variable contents
    f.write(head)
    f.write(contents)
    f.write(foot)


###### MAIN FILE ######

# init
# open file; clean it first
f = open('stuck_together.html', 'w')
f.close()
f = open('stuck_together.html', 'a')
# define foot of piece
foot = """ </xmp>"""


# import filelist from bash command
filelist = sys.argv
# delete entry with own file name
del filelist[0]

# go through the file list
for i in range(len(filelist)):
    print sys.argv[i]                   # print file name
    fin = open(filelist[i], 'r')        # open this file
    contents = fin.read()               # put contents in variable
    AddToFile(filelist[i], contents)    # add contents to file, via function
    fin.close()                         # close this file

# give message done
print 'Done!'

# end neatly
# close file again
f.close()
 </xmp> 
<h3> utils.py </h3> <xmp>


import math
import numpy
import scipy
import myrandom

import _gfrd

Pi = scipy.pi
Pi2 = scipy.pi * 2.0
PiSqrt = math.sqrt(scipy.pi)

N_A = 6.0221367e23
INF = numpy.inf

ZEROPOS = numpy.array([0., 0., 0.])
NOWHERE = numpy.array((INF, INF, INF))

SAFETY = 1.0 + 1e-5

# Tolerance used for float comparison functions. Oversimplifying: two floats a 
# and b are considered to be equal if abs(a - b) < TOLERANCE * abs(a).
TOLERANCE = 1e-7

# Multiplication factor used for seperating 2 particles or a particle and a 
# surface after unbinding.
MINIMAL_SEPARATION_FACTOR = 1.0 + TOLERANCE
  
# Float comparison functions.
def feq(a, b, typical=1, tolerance=TOLERANCE):
    # Return True if a and b are equal, subject to given tolerances.  
    # Float comparison.

    # Also see numpy.allclose().

    # The (relative) tolerance must be positive and << 1.0

    # Instead of specifying an absolute tolerance, you can speciy a 
    # typical value for a or b. The absolute tolerance is then the 
    # relative tolerance multipied by this typical value, and will be 
    # used when comparing a value to zero. By default, the typical 
    # value is 1.

    return abs(a - b) < tolerance * (typical + min(abs(a), abs(b)))


def fgreater(a, b, typical=1, tolerance=TOLERANCE):
    # Return True if a is greater than b, subject to given tolerances.  
    # Float comparison.

    return a - b > tolerance * (typical + min(abs(a), abs(b)))


def fless(a, b, typical=1, tolerance=TOLERANCE):
    # Return True if a is less than b, subject to given tolerances.  
    # Float comparison.

    return b - a > tolerance * (typical + min(abs(a), abs(b)))


def fgeq(a, b, typical=1, tolerance=TOLERANCE):
    # Return True if a is greater or equal than b, subject to given 
    # tolerances. Float comparison.

    diff = a - b
    barrier = tolerance * (typical + min(abs(a), abs(b)))
    # Try both 'greater than' and equality.
    return diff > barrier or abs(diff) < barrier


def fleq(a, b, typical=1, tolerance=TOLERANCE):
    # Return True if a is less than or equal than b, subject to given 
    # tolerances. Float comparison.

    diff = b - a
    barrier = tolerance * (typical + min(abs(a), abs(b)))
    # Try both 'less than' and equality.
    return diff > barrier or abs(diff) < barrier

def per_M_to_m3(rate):
    """Convert a reaction rate from units 'per molar per second' to 
    units 'meters^3 per second'.

    """
    return rate / (1000 * N_A)

def per_microM_to_m3(rate):
    """Convert a reaction rate from units 'per micromolar per second' to 
    units 'meters^3 per second'.

    """
    return per_M_to_m3(rate * 1e6)

def M_to_per_m3(molar):
    """Convert a concentration from units 'molar' to units 'per 
    meters^3'.

    """
    return molar * (1000 * N_A)

def microM_to_per_m3(micromolar):
    """Convert a concentration from units 'micromolar' to units 'per 
    meters^3'.

    """
    return M_to_per_m3(micromolar / 1e6) 

def mean_arrival_time(r, D):
    return (r * r) / (6.0 * D)

def uniq(l):
    nset = {}
    map(nset.__setitem__, l, [])
    return nset.keys()

cyclic_transpose = _gfrd.cyclic_transpose

def distance_sq_array_simple(position1, positions, fsize = None):
    return numpy.square(positions - position1).sum(1)

def distance_array_simple(position1, positions, fsize = None):
    return numpy.sqrt(distance_sq_array_simple(position1, positions))

distance = _gfrd.distance

distance_cyclic = _gfrd.distance_cyclic

def distance_sq_array_cyclic(position1, positions, fsize):
    diff = numpy.abs(positions - position1)
    diff -= numpy.greater(diff, fsize * 0.5) * fsize # transpose
    return numpy.square(diff).sum(1)

def distance_array_cyclic(position1, positions, fsize = 0):
    return numpy.sqrt(distance_sq_array_cyclic(position1, positions, fsize))

def cartesian_to_spherical(c):
    # x, y, z = c
    r = length(c)
    theta = math.acos(c[2] / r)
    phi = math.atan2(c[1], c[0])
    if phi < 0.0:  # atan2 returns [- PI, PI]
        phi += 2.0 * Pi
    return numpy.array([r, theta, phi])

def spherical_to_cartesian(s):
    #FIXME: it's possible that the below is a source of some bias.
    r, theta, phi = s
    sintheta = math.sin(theta)
    return numpy.array([r * math.cos(phi) * sintheta,
                        r * math.sin(phi) * sintheta,
                        r * math.cos(theta)])

def random_unit_vector_s():
    s = numpy.array([1.0, myrandom.uniform(0, Pi), myrandom.uniform(0, Pi2)])
    return s

def random_unit_vector():
    v = [myrandom.uniform(-1,1), myrandom.uniform(-1,1), myrandom.uniform(-1,1)]
    return _gfrd.normalize(v, 1)

def random_vector(r):
    v = [myrandom.uniform(-1,1), myrandom.uniform(-1,1), myrandom.uniform(-1,1)]
    return _gfrd.normalize(v, r)

def random_vector2D(r):
    # Return a random 2D cartesian vector of length r.

    v = [myrandom.uniform(-1,1), myrandom.uniform(-1,1)]
    # Todo. return _gfrd.normalize(v, r)
    v = numpy.array(v)
    norm = numpy.linalg.norm(v)
    return v * (r / norm)

def length(a):
    return _gfrd.length(a)

def normalize(a, l=1):
    return _gfrd.normalize(a, l)

def vector_angle(a, b):
    cosangle = numpy.dot(a, b) / (length(a) * length(b))
    return math.acos(cosangle)

def vector_angle_against_z_axis(b):
    cosangle = b[2] / length(b)
    return math.acos(cosangle)

def crossproduct(a, b):
    M = numpy.array([[   0.0, - a[2],   a[1]],
                     [  a[2],    0.0, - a[0]],
                     [- a[1],   a[0],    0.0]])
    return numpy.dot(M, b)

def crossproduct_against_z_axis(a):
    return numpy.array([- a[1], a[0], 0.0])

def rotate_vector(v, r, alpha):
    # v: vector to rotate
    # r: normalized rotation axis
    # alpha: rotation angle in radian

    cosalpha = math.cos(alpha)
    sinalpha = math.sin(alpha)
    cosalphac = 1.0 - cosalpha

    M = numpy.array([[cosalpha + cosalphac * r[0] * r[0],
                      cosalphac * r[0] * r[1] - r[2] * sinalpha,
                      cosalphac * r[0] * r[2] + r[1] * sinalpha],
                     [cosalphac * r[0] * r[1] + r[2] * sinalpha,
                      cosalpha + cosalphac * r[1] * r[1],
                      cosalphac * r[1] * r[2] - r[0] * sinalpha],
                     [cosalphac * r[0] * r[2] - r[1] * sinalpha,
                      cosalphac * r[1] * r[2] + r[0] * sinalpha,
                      cosalpha + cosalphac * r[2] * r[2]]])

    return numpy.dot(M,v)

def calculate_pair_CoM(pos1, pos2, D1, D2, world_size):
    return _gfrd.calculate_pair_CoM(pos1, pos2, D1, D2, world_size);

apply_boundary = _gfrd.apply_boundary

def permutate(seq):
    # permutate a sequence and return a list of the permutations
    if not seq:
        return [seq] # is an empty sequence
    else:
        temp = []

        for k in range(len(seq)):
            part = seq[:k] + seq[k+1:]
            for m in permutate(part):
                temp.append(seq[k:k+1] + m)
        return temp

def k_D(Dtot, sigma):
    """Calculate the 'pseudo-'reaction rate (kD) caused by diffusion.
    
    kD is equal to 1 divided by the time it takes for two particles to 
    meet each other by diffusion. It is needed when converting from 
    an intrinsic reaction rate to an overall reaction rates or vice 
    versa.

    Example:
        - A + B -> C.

    Arguments:
        - Dtot:
            the diffusion constant of particle A plus the diffusion 
            constant of particle B. Units: meters^2/second.
        - sigma
            the radius of particle A plus the radius of particle B. 
            Units: meters.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    return 4.0 * numpy.pi * Dtot * sigma

def k_a(kon, kD):
    """Convert an overall reaction rate (kon) for a binding/annihilation 
    reaction rule to an intrinsic reaction rate (ka).

    Example:
        - A + B -> C
            binding reaction rule
        - A + B -> 0
            annihilation reaction rule

    Arguments:
        - kon
            the overall reaction rate for the reaction rule. Units: 
            meters^3/second.
        - kD
            the 'pseudo-'reaction rate caused by the diffusion of 
            particles A and B. See the function k_D(). Units: 
            meters^3/second.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    if kon > kD:
        raise RuntimeError, 'kon > kD.'
    ka = 1. / ((1. / kon) - (1. / kD))
    return ka

def k_d(koff, kon, kD):
    """Convert an overall reaction rate (koff) for an unbinding reaction 
    rule to an intrinsic reaction rate (kd).

    This one is a bit tricky. We consider reaction rules with only 1 
    reactant. In case there is only 1 product also, no conversion in 
    necessary. But when the reaction rule has 2 products, we need to 
    take the reverse reaction rule into account and do the proper 
    conversion.

    Example:
        - C -> A + B
            unbinding reaction rule
        - A + B -> C
            reverse reaction rule

    Arguments:
        - koff
            the overall reaction rate for the unbinding reaction rule.  
            Units: meters^3/second.
        - kon
            the overall reaction rate for the reverse reaction rule. 
            Units: meters^3/second.
        - kD
            the 'pseudo-'reaction rate caused by the diffusion of 
            particles A and B. See the function k_D(). Units: 
            meters^3/second.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    ka = k_a(kon, kD)
    kd = k_d_using_ka(koff, ka, kD)
    return kd

def k_d_using_ka(koff, ka, kD):
    """Convert an overall reaction rate (koff) for an unbinding reaction 
    rule to an intrinsic reaction rate (kd).

    Similar to the function k_d(), but expects an intrinsic rate (ka) 
    instead of an overall rate (kon) for the reversed reaction rule as 
    the second argument.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    kd =  koff * (1 + float(ka) / kD)
    return kd

def k_on(ka, kD):
    """Convert an intrinsic reaction rate (ka) for a binding/annihilation 
    reaction rule to an overall reaction rate (kon).

    The inverse of the function k_a().
    
    Rarely needed.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    kon = 1. / ((1. / kD) + (1. / ka))  # m^3/s
    return kon

def k_off(kd, kon, kD):
    """Convert an intrinsic reaction rate (kd) for an unbinding reaction 
    rule to an overall reaction rate (koff).

    The inverse of the function k_d().

    Rarely needed.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    ka = k_a(kon, kD) 
    koff = k_off_using_ka(kd, ka, kD)
    return koff

def k_off_using_ka(kd, ka, kD):
    """Convert an intrinsic reaction rate (kd) for an unbinding reaction 
    rule to an overall reaction rate (koff).

    Similar to the function k_off(), but expects an intrinsic rate 
    (ka) instead of an overall rate (kon) as the second argument.

    Rarely needed.

    This function is only available for reaction rules in 3D. No 
    analytical expression for kD in 1D or 2D is currently known. 

    """
    koff = 1. / (float(ka) / (kd * kD) + (1. / kd))
    return koff

def C2N(c, V):
    """Calculate the number of particles in a volume 'V' (dm^3) 
    with a concentration 'c' (mol/dm^3).

    """
    return c * V * N_A  # round() here?

 </xmp>