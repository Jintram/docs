 
<h3> BasicNetworkRulesImpl.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <boost/lexical_cast.hpp>
#include "utils/range_support.hpp"
#include "exceptions.hpp"
#include "generator.hpp"
#include "BasicNetworkRulesImpl.hpp"

BasicNetworkRulesImpl::~BasicNetworkRulesImpl()
{
}

BasicNetworkRulesImpl::BasicNetworkRulesImpl()
{
}

void BasicNetworkRulesImpl::add_reaction_rule(ReactionRule const& r)
{
    if (!reaction_rules_map_[r.get_reactants()].insert(r).second)
        throw already_exists(boost::lexical_cast<std::string>(r));
}

void BasicNetworkRulesImpl::remove_reaction_rule(ReactionRule const& r)
{
    reaction_rules_map_[r.get_reactants()].erase(r);
}
    
BasicNetworkRulesImpl::reaction_rule_generator*
BasicNetworkRulesImpl::query_reaction_rule(SpeciesTypeID const& r1) const
{
    reaction_rules_map::const_iterator i(
            reaction_rules_map_.find(ReactionRule::Reactants(r1)));
    if (i == reaction_rules_map_.end())
    {
        return 0;
    }
    return make_range_generator<ReactionRule>((*i).second);
}

BasicNetworkRulesImpl::reaction_rule_generator*
BasicNetworkRulesImpl::query_reaction_rule(SpeciesTypeID const& r1, SpeciesTypeID const& r2) const
{
    reaction_rules_map::const_iterator i(
            reaction_rules_map_.find(ReactionRule::Reactants(r1, r2)));
    if (i == reaction_rules_map_.end())
    {
        return 0;
    }
    return make_range_generator<ReactionRule>((*i).second);
}
 </xmp> 
<h3> ConsoleAppender.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <cstdio>
#include <boost/date_time/posix_time/posix_time.hpp>

#include "ConsoleAppender.hpp"

ConsoleAppender::~ConsoleAppender() {}

void ConsoleAppender::operator()(enum Logger::level lv, boost::posix_time::ptime const& tm, char const* name, char const** chunks)
{
    using namespace boost::posix_time;
    std::fprintf(stderr, "[%s] %s: %-8s ", to_iso_string(tm).c_str(),
                 name, Logger::stringize_error_level(lv));
    for (char const** p = chunks; *p; ++p)
        std::fwrite(*p, sizeof(char), strlen(*p), stderr);
    std::fputc('\n', stderr);
}

void ConsoleAppender::flush()
{
    std::fflush(stderr);
}
 </xmp> 
<h3> CylindricalBesselGenerator.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <cassert>

#include "compat.h"
#include "CylindricalBesselTable.hpp"
#include "CylindricalBesselGenerator.hpp"


static inline double hermite_interp(double x, 
                                    double x0, double dx, 
                                    double const* y_array)
{
    const double hinv = 1.0 / dx;

    const size_t i = static_cast<size_t>((x - x0 ) * hinv);
    const size_t index = i * 2;

    const double x_lo = (x - x0) * hinv - i;
    const double x_hi =  1.0 - x_lo;

    const double y_lo = y_array[index];
    const double ydot_lo = y_array[index + 1] * dx;
    const double y_hi = y_array[index + 2];
    const double ydot_hi = y_array[index + 3] * dx;
    
    return x_hi * x_hi * (y_lo + x_lo * (2 * y_lo + ydot_lo)) 
        + x_lo * x_lo * (y_hi + x_hi * (2 * y_hi - ydot_hi));
}

inline static Real interp(Real x_start, Real delta_x,
                          Real const* yTable, Real x)
{
    return hermite_interp(x, x_start, delta_x, yTable);
}

static Real _J(UnsignedInteger n, Real z)
{
    return gsl_sf_bessel_Jn(n, z);
}

static Real _Y(UnsignedInteger n, Real z)
{
    return gsl_sf_bessel_Yn(n, z);
}

CylindricalBesselGenerator const& CylindricalBesselGenerator::instance()
{
    static const CylindricalBesselGenerator cylindricalBesselGenerator;
    return cylindricalBesselGenerator;
}



UnsignedInteger CylindricalBesselGenerator::getMinNJ()
{
    return cb_table::cj_table_min;
}

UnsignedInteger CylindricalBesselGenerator::getMinNY()
{
    return cb_table::cy_table_min;
}

UnsignedInteger CylindricalBesselGenerator::getMaxNJ()
{
    return cb_table::cj_table_max;
}

UnsignedInteger CylindricalBesselGenerator::getMaxNY()
{
    return cb_table::cy_table_max;
}

static cb_table::Table const* getCJTable(UnsignedInteger n)
{
    return cb_table::cj_table[n];
}


static cb_table::Table const* getCYTable(UnsignedInteger n)
{
    return cb_table::cy_table[n];
}

static inline Real _J_table(UnsignedInteger n, Real z)
{
    cb_table::Table const* tablen(getCJTable(n));

    return interp(tablen->x_start, tablen->delta_x, tablen->y, z);
}

static inline Real _Y_table(UnsignedInteger n, Real z)
{
    cb_table::Table const* tablen(getCYTable(n));

    return interp(tablen->x_start, tablen->delta_x, tablen->y, z);
}



Real CylindricalBesselGenerator::J(UnsignedInteger n, Real z) const
{
    if(n > getMaxNJ())
    {
        return _J(n, z);
    }
    
    const cb_table::Table* table(getCJTable(n));
    assert(table != 0);

    const Real minz(table->x_start + table->delta_x * 3);
    const Real maxz(table->x_start + table->delta_x * (table->N-3));
    
    if(z >= minz && z < maxz)
    {
        return _J_table(n, z);
    }
    else
    {
        return _J(n, z);
    }
}

Real CylindricalBesselGenerator::Y(const UnsignedInteger n, const Real z) const
{
    if(n > getMaxNY())
    {
        return _Y(n, z);
    }
    
    const cb_table::Table* table(getCYTable(n));
    assert(table != 0);
    
    const Real minz(table->x_start + table->delta_x * 3);
    const Real maxz(table->x_start + table->delta_x * (table->N-3));
    
    if(z >= minz && z < maxz)
    {
        return _Y_table(n, z);
    }
    else
    {
        return _Y(n, z);
    }
}

 </xmp> 
<h3> findRoot.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdexcept>
#include <gsl/gsl_errno.h>

#include "Logger.hpp"
#include "findRoot.hpp"

Real findRoot(gsl_function const& F, gsl_root_fsolver* solver, Real low,
              Real high, Real tol_abs, Real tol_rel, char const* funcName)
{
    Real l(low);
    Real h(high);

    gsl_root_fsolver_set(solver, const_cast<gsl_function*>(&F), l, h);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        l = gsl_root_fsolver_x_lower(solver);
        h = gsl_root_fsolver_x_upper(solver);

        const int status(gsl_root_test_interval(l, h, tol_abs,
                                                  tol_rel));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error(std::string(funcName) + ": failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  

    const Real root(gsl_root_fsolver_root(solver));

    return root;
}
 </xmp> 
<h3> freeFunctions.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "compat.h"

#include <algorithm>
#include <stdexcept>
#include <gsl/gsl_math.h>
#include <gsl/gsl_roots.h>
#include <gsl/gsl_errno.h>

#include "Logger.hpp"
#include "freeFunctions.hpp"

/**
   Calculates std::exp(x^2) * erfc(x)

   See asymptotic expansion here:
   http://en.wikipedia.org/wiki/Error_function
*/  
Real expxsq_erfc(Real x)
{
    Real result;

    const Real xsq(x * x);
    if(x > 26.0)
    {
        const Real M_1_SQRTPI(M_2_SQRTPI * 0.5); 

        const Real x2sq_r(1.0 / (2.0 * xsq));  // 2 / (2 x)^2

        /*
          up to second term in the expansion.
          abs err ~= 9e-8 at x == 20, 3e-8 at x == 25

          the third term 
          - (8 / (x2sq * x2sq * x2sq))       
          and beyond doesn't have a major contribution for large x.
        */

        result = (M_1_SQRTPI / x) * 
            (1.0 - x2sq_r +      // term 1
              x2sq_r * x2sq_r);  // term 2
    }
    else
    {
        result = std::exp(xsq) * erfc(x);
    }

    return result;
}


/**
   W(a, b) := std::exp(2 a b + b^2) erfc(a + b)
*/
Real W(Real a, Real b)
{
    // std::exp(2 a b + b^2) erfc(a + b) == 
    //               std::exp(- a^2) std::exp((a + b)^2) erfc(a + b)
    return std::exp(- a * a) * expxsq_erfc(a + b);
}

Real __p_irr(Real r, Real t, Real r0, Real kf, Real D, Real sigma, Real alpha)
{
    //  printf("irrp %g %g %g\n",r,r0,t);
    const Real sqrtD(std::sqrt(D));

    const Real Dt4(4.0 * D * t);
    const Real r_plus_r0_minus_2sigma(r + r0 - 2.0 * sigma);

    const Real num1(std::exp(- gsl_pow_2(r - r0) / Dt4));
    const Real num2(std::exp(- gsl_pow_2(r_plus_r0_minus_2sigma) / Dt4));
    const Real num3(W(r_plus_r0_minus_2sigma / std::sqrt(Dt4), 
                        alpha * std::sqrt(t)));

    const Real num((num1 + num2) / std::sqrt(4.0 * M_PI * t) -  alpha * num3);

    const Real den(4.0 * M_PI * r * r0 * sqrtD);

    const Real result(num / den);

    const Real jacobian(4.0 * M_PI * r * r);

    return result * jacobian;
}

Real p_irr(Real r, Real t, Real r0, Real kf, Real D, Real sigma)
{
    const Real kD(4.0 * M_PI * sigma * D);
    const Real alpha((1.0 + (kf / kD)) * (std::sqrt(D) / sigma));

    const Real p(__p_irr(r, t, r0, kf, D, sigma, alpha));

    return p;
}


Real p_survival_irr(Real t, Real r0, Real kf, Real D, Real sigma)
{
    const Real kD(4.0 * M_PI * sigma * D);
    const Real alpha((1.0 + (kf / kD)) * (std::sqrt(D) / sigma));

    const Real p(__p_reaction_irr(t, r0, kf, D, sigma, alpha, kD));

    return 1.0 - p;
}

Real __p_reaction_irr(Real t, Real r0, Real kf, Real D, Real sigma,
                       Real alpha, Real kD)
{
    const Real sqrtt(std::sqrt(t));
    const Real sqrtD(std::sqrt(D));

    const Real r0_m_sigma_over_sqrt4D_t((r0 - sigma) 
                                         / ((sqrtD + sqrtD) * sqrtt));

    const Real Wf(W(r0_m_sigma_over_sqrt4D_t, alpha * sqrtt));
    const Real factor(sigma * kf / (r0 * (kf + kD)));

    return factor * (erfc(r0_m_sigma_over_sqrt4D_t) - Wf);
}


Real 
__p_reaction_irr_t_inf(Real r0, Real kf, Real sigma, Real kD)
{
    const Real kf_kD_r0((kf + kD) * r0);
    return 1 - (kf_kD_r0 - kf * sigma) / kf_kD_r0;
}


Real p_survival_nocollision(Real t, Real r0, Real D, Real a)
{
    const Real Dt(D * t);
    const Real asq(a * a);
    const Real a_r(1.0 / a);
    const Real asq_r(a_r * a_r);

    const Real PIr0(M_PI * r0);

    const Real angle_factor(PIr0 * a_r);
    const Real exp_factor(- Dt * M_PI * M_PI * asq_r);

    const Real TOLERANCE(1e-8);

    const unsigned int i_max(
        std::max(static_cast<unsigned int>(
                      std::ceil(std::sqrt(M_PI * M_PI 
                                  + asq * std::log(1.0 / TOLERANCE) / Dt) *
                            M_1_PI)), 2u));

    Real p(0.0);
    Real sign(1.0);
    unsigned int i(1);
    while(true)
    {
        const Real term(sign * 
                         std::exp(exp_factor * i * i) * 
                         std::sin(angle_factor * i) / i);
        
        p += term;

        if(i >= i_max)
        {
            break;
        }

        sign = -sign;
        ++i;
    }

    const Real factor((a + a) / PIr0);

    return p * factor;
}

Real dp_survival_nocollision(Real t, Real r0, Real D, Real a)
{
    const Real Dt(D * t);
    const Real asq(a * a);
    const Real a_r(1.0 / a);
    const Real asq_r(a_r * a_r);

    const Real PIr0(M_PI * r0);

    const Real angle_factor(PIr0 * a_r);
    const Real exp_factor(- Dt * M_PI * M_PI * asq_r);

    const Real TOLERANCE(1e-8);

    const unsigned int i_max(
        std::max(static_cast<unsigned int>(
                      std::ceil(std::sqrt(M_PI * M_PI 
                                  + asq * std::log(1.0 / TOLERANCE) / Dt) *
                            M_1_PI)), 2u));

    Real p(0.0);
    Real sign(- 1.0);
    unsigned int i(1);
    while(true)
    {
        const Real term(sign * 
                         std::exp(exp_factor * i * i) * 
                         std::sin(angle_factor * i) * i);
        
        p += term;

        if(i >= i_max)
        {
            break;
        }

        sign = -sign;
        ++i;
    }

    const Real factor(D * (M_PI + M_PI) / (a * r0));

    return p * factor;
}

Real p_theta_free(Real theta, Real r, Real r0, Real t, Real D)
{
    Real sin_theta;
    Real cos_theta;
    sincos(theta, &sin_theta, &cos_theta);

    const Real Dt4(4.0 * D * t);
    const Real Dt4Pi(Dt4 * M_PI);

    const Real term1(std::exp(- (r * r - 2.0 * cos_theta * r * r0 + r0 * r0) / 
                           Dt4));
    const Real term2(1.0 / std::sqrt(Dt4Pi * Dt4Pi * Dt4Pi));

    return term1 * term2 * sin_theta; // jacobian
}

Real ip_theta_free(Real theta, Real r, Real r0, Real t, Real D)
{
    const Real Dt(D * t);
    const Real Dt2(Dt + Dt);
    const Real rr0(r * r0);

    const Real rr0_over_2Dt(rr0 / Dt2);

    const Real rsqr0sq_over_4Dt((r * r + r0 * r0) / (Dt2 + Dt2));

    const Real term1(expm1(rr0_over_2Dt 
                             - rsqr0sq_over_4Dt));
    const Real term2(expm1(rr0_over_2Dt * cos(theta) 
                             - rsqr0sq_over_4Dt));

    const Real den(4.0 * std::sqrt(M_PI * M_PI * M_PI * Dt) * rr0);

    return (term1 - term2) / den;
}

Real g_bd(Real r, Real sigma, Real t, Real D)
{
    const Real Dt4(4.0 * D * t);
    const Real mDt4_r(- 1.0 / Dt4);
    const Real sqrtDt4(std::sqrt(Dt4));
    const Real sqrtDt4_r(1.0 / sqrtDt4);
    const Real sqrtPi(std::sqrt(M_PI));

    const Real rps(r + sigma);
    const Real rms(r - sigma);

    const Real term1((std::exp(rps * rps * mDt4_r) - 
                        std::exp(rms * rms * mDt4_r)) * sqrtDt4 / 
                      (sqrtPi * r));
    const Real term2(erf(rps * sqrtDt4_r) - erf(rms * sqrtDt4_r));

    return 0.5 * (term1 + term2) * r * r;
}
    
Real I_bd(Real sigma, Real t, Real D)
{
    const Real sqrtPi(std::sqrt(M_PI));

    const Real Dt(D * t);
    const Real Dt2(Dt + Dt);
    const Real sqrtDt(std::sqrt(Dt));
    const Real sigmasq(sigma * sigma);

    const Real term1(1.0 / (3.0 * sqrtPi));
    const Real term2(sigmasq - Dt2);
    const Real term3(Dt2 - 3.0 * sigmasq);
    const Real term4(sqrtPi * sigmasq * sigma * erfc(sigma / sqrtDt));

    const Real result(term1 * (- sqrtDt *
                                 (term2 * std::exp(- sigmasq / Dt) + term3)
                                 + term4));
    
    return result;
}


Real I_bd_r(Real r, Real sigma, Real t, Real D)
{
    const Real sqrtPi(std::sqrt(M_PI));

    const Real Dt(D * t);
    const Real Dt2(Dt + Dt);
    const Real Dt4(Dt2 + Dt2);
    const Real sqrtDt(std::sqrt(Dt));
    const Real sqrtDt4(std::sqrt(Dt4));
    const Real sigmasq(sigma * sigma);

    const Real sigmacb(sigmasq * sigma);
    const Real rcb(gsl_pow_3(r));

    const Real rsigma(r * sigma);

    const Real rps_sq(gsl_pow_2(r + sigma));
    const Real rms_sq(gsl_pow_2(r - sigma));

    const Real term1(- 2.0 * sqrtDt / sqrtPi);
    const Real term2(std::exp(- sigmasq / Dt) * (sigmasq - Dt2));
    const Real term3(- std::exp(- rps_sq / Dt4) * (rms_sq + rsigma - Dt2));
    const Real term4(std::exp(- rms_sq / Dt4) * (rps_sq - rsigma - Dt2));
    const Real term5(- sigmasq * 3.0 + Dt2);

    const Real term6((sigmacb - rcb) * erf((r - sigma) / sqrtDt4));
    const Real term7(- (sigmacb + sigmacb) * erf(sigma / sqrtDt));
    const Real term8((sigmacb + rcb) * erf((r + sigma) / sqrtDt4));

    const Real result((term1 * (term2 + term3 + term4 + term5)
                         // + sigmasq + rsigma + rsigma - Dt2)//expm1
                         + term6 + term7 + term8) / 6.0);
    
    return result;
}


struct g_bd_params
{ 
    const Real sigma;
    const Real t;
    const Real D;
    const Real target;
};


static Real I_gbd_r_F(Real r, const g_bd_params* params)
{
    const Real sigma(params->sigma);
    const Real t(params->t);
    const Real D(params->D);
    const Real target(params->target);

    return I_bd_r(r, sigma, t, D) - target;
}

Real drawR_gbd(Real rnd, Real sigma, Real t, Real D)
{
    const Real I(I_bd(sigma, t, D));

    g_bd_params params = { sigma, t, D, rnd * I };

    gsl_function F =
    {
        reinterpret_cast<typeof(F.function)>(&I_gbd_r_F),
        &params
    };

    Real low(sigma);
    Real high(sigma + 10.0 * std::sqrt (6.0 * D * t));

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    while(true)
    {
        gsl_root_fsolver_iterate(solver);

        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        int status(gsl_root_test_interval(low, high, 1e-18, 1e-12));

        if(status == GSL_CONTINUE)
        {
            if(i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawR_gbd: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    gsl_root_fsolver_free(solver);

    return low;
}
 </xmp> 
<h3> funcSum.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <vector>
#include <cmath>
#include <boost/bind.hpp>
#include <gsl/gsl_sum.h>

#include "Logger.hpp"
#include "funcSum.hpp"

typedef std::vector<Real> RealVector;

static Logger& _log(Logger::get_logger("funcSum"));

Real 
funcSum_all(boost::function<Real(unsigned int i)> f, size_t max_i)
{
    Real sum(0.0);

    const Real p_0(f(0));
    if (p_0 == 0.0)
    {
        return 0.0;
    }

    sum = p_0;

    RealVector::size_type i(1); 
    while(i < max_i)
    {
        const Real p_i(f(i));
        sum += p_i;

        ++i;
    }

    return sum;
}


Real 
funcSum_all_accel(boost::function<Real(unsigned int i)> f,
                  size_t max_i, Real tolerance)
{
    RealVector pTable;
    pTable.reserve(max_i);

    const Real p_0(f(0));
    if (p_0 == 0.0)
    {
        return 0.0;
    }

    pTable.push_back(p_0);

    RealVector::size_type i(1);
    for(;  i < max_i; ++i)
    {
        const Real p_i(f(i));
        pTable.push_back(p_i);
    }

    Real sum;
    Real error;
    gsl_sum_levin_utrunc_workspace* 
        workspace(gsl_sum_levin_utrunc_alloc(i));
    gsl_sum_levin_utrunc_accel(&pTable[0], pTable.size(), workspace, 
                                &sum, &error);
    if (fabs(error) >= fabs(sum * tolerance))
    {
        _log.error("series acceleration error: %g"
                  " (rel error: %g), terms_used = %d (%d given)",
                  fabs(error), fabs(error / sum),
                  workspace->terms_used, pTable.size());
    }

    gsl_sum_levin_utrunc_free(workspace);

    return sum;
}


Real 
funcSum(boost::function<Real(unsigned int i)> f, size_t max_i, Real tolerance)
{
    const unsigned int CONVERGENCE_CHECK(4);

    Real sum(0.0);
    RealVector pTable;

    const Real p_0(f(0));
    if (p_0 == 0.0)
    {
        return 0.0;
    }

    pTable.push_back(p_0);
    sum = p_0;

    bool extrapolationNeeded(true);

    unsigned int convergenceCounter(0);

    RealVector::size_type i(1); 
    while(i < max_i)
    {
        const Real p_i(f(i));
        pTable.push_back(p_i);
        sum += p_i;

        ++i;

        if (fabs(sum) * tolerance >= fabs(p_i)) // '=' is important
        {
            ++convergenceCounter;
        }
        /*
        // this screws it up; why?
        else
        {
            convergenceCounter = 0;
        }
        */

        if (convergenceCounter >= CONVERGENCE_CHECK)
        {
            extrapolationNeeded = false;
            break;
        }
        
    }

    if (extrapolationNeeded)
    {
        Real error;
        gsl_sum_levin_utrunc_workspace* 
            workspace(gsl_sum_levin_utrunc_alloc(i));
        gsl_sum_levin_utrunc_accel(&pTable[0], pTable.size(), workspace, 
        &sum, &error);
        if (fabs(error) >= fabs(sum * tolerance * 10))
        {
            _log.error("series acceleration error: %g"
                      " (rel error: %g), terms_used = %d (%d given)",
                      fabs(error), fabs(error / sum),
                      workspace->terms_used, pTable.size());
        }

        gsl_sum_levin_utrunc_free(workspace);
    }

    return sum;
}
 </xmp> 
<h3> GreensFunction1DAbsAbs.cpp </h3> <xmp>

#include <sstream>
#include <iostream>
#include <cstdlib>
#include <exception>
#include <vector>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_trig.h>
#include <gsl/gsl_sum.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_roots.h>

#include <math.h>

#include "findRoot.hpp"
#include "GreensFunction1DAbsAbs.hpp"
#include "Defs.hpp"


// Calculates the probability of finding the particle inside the domain at 
// time t
Real
GreensFunction1DAbsAbs::p_survival (Real t) const
{
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());

    if ( fabs(r0-sigma) < L*EPSILON || fabs(a-r0) < L*EPSILON || L < 0.0 )
    {
	// The survival probability of a zero domain is zero
	return 0.0;
    }

    // Set values that are constant in this calculation
    const Real expo(-D*t/(L*L));   // part of the exponent -D n^2 PI^2 t / L^2
    const Real r0s(r0 - sigma);
    const Real r0s_L(r0s/L);
    
    // some abbreviations for terms appearing in the sums with drift<>0
    const Real sigmav2D(sigma*v/2.0/D);
    const Real av2D(a*v/2.0/D);
    const Real Lv2D(L*v/2.0/D);
    const Real vexpo(-v*v*t/4.0/D - v*r0/2.0/D);	// exponent of the drift-prefactor
    

    // Initialize summation
    Real sum = 0, term = 0, prev_term = 0;
    Real nPI;


    // Sum
    Real n=1;
    // different calculations depending on whether v=0 or not
    if(v==0.0)	// case without drift (v==0); in this case the summation is simpler, so do the complicated caluclation only if necessary
    {
      do
      {
	  if (n >= MAX_TERMS )
	  {
	      std::cerr << "Too many terms for p_survival. N: " << n << std::endl;
	      break;
	  }
	  
	  prev_term = term;
	  nPI = (double)n*M_PI;
	  term = exp(nPI*nPI*expo) * sin(nPI*r0s_L) * (1.0 - cos(nPI)) / nPI;
	  sum += term;
	  n++;
      }
      // Is 1 a good measure or will this fail at some point?
      while (	fabs(term/sum) > EPSILON*1.0 ||
		fabs(prev_term/sum) > EPSILON*1.0 ||
		n < MIN_TERMS );

      sum = 2.0*sum;	// This is a prefactor of every term, so do only one multiplication here
    }
    else	// case with drift (v<>0)
    {
      do
      {
	  if (n >= MAX_TERMS )
	  {
	      std::cerr << "Too many terms for p_survival. N: " << n << std::endl;
	      break;
	  }
	  
	  nPI = (double)n*M_PI;
	  prev_term = term;
	  term = exp(nPI*nPI*expo) * (exp(sigmav2D) - cos(nPI)*exp(av2D)) * nPI/(Lv2D*Lv2D+nPI*nPI) * sin(nPI*r0s_L);
	  sum += term;
	  n++;
      }
      // TODO: Is 1 a good measure or will this fail at some point?
      while (	fabs(term/sum) > EPSILON*1.0 ||
		fabs(prev_term/sum) > EPSILON*1.0 ||
		n < MIN_TERMS );
      
      sum = 2.0*exp(vexpo) * sum;	// prefactor containing the drift

    }

    return sum;
}

// Calculates the probability density of finding the particle at location r at 
// time t.
Real
GreensFunction1DAbsAbs::prob_r (Real r, Real t) const
{
    THROW_UNLESS( std::invalid_argument, 0.0 <= (r-sigma) && r <= a );
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());

    // if there was no time change or no diffusivity => no movement
    if (t == 0 || D == 0)
    {
	// the probability density function is a delta function
	if (r == r0)
	{
	    return INFINITY;
	}
	else
	{      
	    return 0.0;
	}
    }
    else if ( fabs(r-sigma) < L*EPSILON || fabs(a-r) < L*EPSILON || L < 0.0 )
    {
	return 0.0;
    }

    // Set values that are constant in this calculation
    const Real expo(-D*t/(L*L));
    const Real rs_L((r-sigma)/L);
    const Real r0s_L((r0-sigma)/L);
    const Real vexpo(-v*v*t/4.0/D + v*(r-r0)/2.0/D);	// exponent of the drift-prefactor

    // Initialize summation
    Real nPI;
    Real sum = 0, term = 0, prev_term = 0;

    // Sum
    int n=1;
    do
    {
	if (n >= MAX_TERMS )
	{
	    std::cerr << "Too many terms for prob_r. N: " << n << std::endl;
	    break;
	}

	prev_term = term;

	nPI = n*M_PI;
	term = exp(nPI*nPI*expo) * sin(nPI*r0s_L) * sin(nPI*rs_L);
	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON*PDENS_TYPICAL ||
	fabs(prev_term/sum) > EPSILON*PDENS_TYPICAL ||
	n <= MIN_TERMS);

    return 2.0/L * exp(vexpo) * sum;
}

// Calculates the probability density of finding the particle at location r at 
// timepoint t, given that the particle is still in the domain.
Real
GreensFunction1DAbsAbs::calcpcum (Real r, Real t) const
{
    return prob_r(r, t) / p_survival(t);
}

// Calculates the amount of flux leaving the left boundary at time t
Real
GreensFunction1DAbsAbs::leaves(Real t) const
{
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());

    if ( fabs(r0-sigma) < L*EPSILON || fabs(a-r0) < L*EPSILON || L < 0.0 )
    {
	// The flux of a zero domain is INFINITY. Also if the particle 
	// started on the left boundary (leaking out immediately).
	return INFINITY;
    }
    else if ( t < EPSILON*this->t_scale )
    {
	// if t=0.0 the flux must be zero
	return 0.0;
    }


    Real sum = 0, term = 0, prev_term = 0;
    Real nPI;
    const Real D_L_sq(D/(L*L));
    const Real expo(-D_L_sq*t);
    const Real r0s_L((r0-sigma)/L);
    const Real vexpo(-v*v*t/4.0/D - v*(r0-sigma)/2.0/D);
    
    Real n=1;
    do
    {
	if (n >= MAX_TERMS )
	{
	    std::cerr << "Too many terms for p_survival. N: " << n << std::endl;
	    break;
	}

	nPI = n*M_PI;
	prev_term = term;
	term = nPI * exp(nPI*nPI*expo) * sin(nPI*r0s_L);
	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON*PDENS_TYPICAL ||
	fabs(prev_term/sum) > EPSILON*PDENS_TYPICAL ||
	n < MIN_TERMS );

    return 2.0*D_L_sq * exp(vexpo) * sum;
}

// Calculates the amount of flux leaving the right boundary at time t
Real
GreensFunction1DAbsAbs::leavea(Real t) const
{
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());

    if ( fabs(r0-sigma) < L*EPSILON || fabs(a-r0) < L*EPSILON || L < 0.0 )
    {
	// The flux of a zero domain is INFINITY. Also if the particle 
	// started on the right boundary (leaking out immediately).
	return INFINITY;
    }
    else if ( t < EPSILON*this->t_scale )
    {
	// if t=0.0 the flux must be zero
	return 0.0;
    }


    Real sum = 0, term = 0, prev_term = 0;
    Real nPI;
    const Real D_L_sq(D/(L*L));
    const Real expo(-D_L_sq*t);		// exponent -D n^2 PI^2 t / l^2
    const Real r0s_L((r0-sigma)/L);
    const Real vexpo(-v*v*t/4.0/D + v*(a-r0)/2.0/D);
    
    Real n=1;
    do
     {
       if (n >= MAX_TERMS )
       {
	 std::cerr << "Too many terms for leaves. N: " << n << std::endl;
	 break;
       }
       
       nPI = n*M_PI;
       prev_term = term;
       term = nPI * exp(nPI*nPI*expo) * cos(nPI) * sin(nPI*r0s_L);
       sum += term;
       n++;
     }
     while (fabs(term/sum) > EPSILON*PDENS_TYPICAL ||
	    fabs(prev_term/sum) > EPSILON*PDENS_TYPICAL ||
	    n < MIN_TERMS );
     
     return -2.0*D_L_sq * exp(vexpo) * sum;
}

// This draws an eventtype of time t based on the flux through the left (z=sigma) 
// and right (z=a) boundary. Although not completely accurate, it returns an 
// IV_ESCAPE for an escape through the right boundary and a IV_REACTION for an 
// escape through the left boundary.
GreensFunction1DAbsAbs::EventKind
GreensFunction1DAbsAbs::drawEventType( Real rnd, Real t ) const
{
    THROW_UNLESS( std::invalid_argument, rnd < 1.0 && rnd >= 0.0 );
    THROW_UNLESS( std::invalid_argument, t > 0.0 );
    // if t=0 nothing has happened => no event

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());

    // For particles at the boundaries
    if ( fabs(a-r0) < EPSILON*L )
    {
	// if the particle started on the right boundary
	return IV_ESCAPE;
    }
    else if ( fabs(r0-sigma) < EPSILON*L )
    {
	// if the particle started on the left boundary
	return IV_REACTION;
    }

    const Real leaves_s (this->leaves(t));
    const Real leaves_a (this->leavea(t));
    const Real flux_total (leaves_s + leaves_a);
    const Real fluxratio (leaves_s/flux_total);

    if (rnd > fluxratio )
    {
	return IV_ESCAPE;
    }
    else
    {
	return IV_REACTION;
    }
}

// This is a help function that casts the drawT_params parameter structure into
// the right form and calculates the survival probability from it (and returns it).
// The routine drawTime uses this one to sample the next-event time from the
// survival probability using a rootfinder from GSL.
double
GreensFunction1DAbsAbs::drawT_f (double t, void *p)
{   
    // casts p to type 'struct drawT_params *'
    struct drawT_params *params = (struct drawT_params *)p;
    
    Real sum = 0, term = 0, prev_term = 0;
    Real Xn, exponent, prefactor;
    // the maximum number of terms in the params table
    int    terms = params->terms;
    // the timescale used
    Real   tscale = params->tscale;

    int n=0;
    do
    {
	if ( n >= terms )
	{
	    std::cerr << "Too many terms needed for DrawTime. N: "
	              << n << std::endl;
	    break;
	}
	prev_term = term;

	Xn = params->Xn[n];
	exponent = params->exponent[n];
	term = Xn * exp(exponent * t);
	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON*tscale ||
	fabs(prev_term/sum) > EPSILON*tscale ||
	n <= MIN_TERMS );

    prefactor = params->prefactor;
    
    // find intersection with the random number
    return 1.0 - prefactor*sum - params->rnd;
}

// Draws the first passage time from the propensity function.
// Uses the help routine drawT_f and structure drawT_params for some technical
// reasons related to the way to input a function and parameters required by
// the GSL library.
Real
GreensFunction1DAbsAbs::drawTime (Real rnd) const
{
    THROW_UNLESS( std::invalid_argument, 0.0 <= rnd && rnd < 1.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());
    
    if (D == 0.0 )
    {
	return INFINITY;
    }
    else if ( L < 0.0 || fabs(a-r0) < EPSILON*L || fabs(r0-sigma) > (1.0 - EPSILON)*L )
    {
	// if the domain had zero size
	return 0.0;
    }

    const Real expo(-D/(L*L));
    const Real r0s_L((r0-sigma)/L);
    // some abbreviations for terms appearing in the sums with drift<>0
    const Real sigmav2D(sigma*v/2.0/D);
    const Real av2D(a*v/2.0/D);
    const Real Lv2D(L*v/2.0/D);
    // exponent of the prefactor present in case of v<>0; has to be split because it has a t-dep. and t-indep. part
    const Real vexpo_t(-v*v/4.0/D);
    const Real vexpo_pref(-v*r0/2.0/D);

    // the structure to store the numbers to calculate the numbers for 1-S
    struct drawT_params parameters;
    Real Xn, exponent, prefactor;
    
    Real nPI;
    
    // Construct the coefficients and the terms in the exponent and put them 
    // into the params structure
    int n = 0;
    // a simpler sum has to be computed for the case w/o drift, so distinguish here
    if(v==0)
    {
      do
      {
	  nPI = ((Real)(n+1))*M_PI;	// why n+1 : this loop starts at n=0 (1st index of the arrays), while the sum starts at n=1 !
	  Xn = sin(nPI*r0s_L) * (1.0 - cos(nPI)) / nPI; 
	  exponent = nPI*nPI*expo;
	  
	  // store the coefficients in the structure
	  parameters.Xn[n] = Xn;	
	  // also store the values for the exponent
	  parameters.exponent[n]=exponent;
	  n++;
      }
      // TODO: Modify this later to include a cutoff when changes are small
      while (n<MAX_TERMS);
    }
    else	// case with drift<>0
    {
     do
      {
	  nPI = ((Real)(n+1))*M_PI;	// why n+1 : this loop starts at n=0 (1st index of the arrays), while the sum starts at n=1 !
	  Xn = (exp(sigmav2D) - cos(nPI)*exp(av2D)) * nPI/(Lv2D*Lv2D+nPI*nPI) * sin(nPI*r0s_L);
	  exponent = nPI*nPI*expo + vexpo_t;
	  
	  // store the coefficients in the structure
	  parameters.Xn[n] = Xn;	
	  // also store the values for the exponent
	  parameters.exponent[n]=exponent;
	  n++;
      }
       // TODO: Modify this later to include a cutoff when changes are small
      while (n<MAX_TERMS);
    }

    // the prefactor of the sum is also different in case of drift<>0 :
    if(v==0)	prefactor = 2.0*exp(vexpo_pref);
    else	prefactor = 2.0;
    parameters.prefactor = prefactor;
    
    parameters.rnd = rnd;
    parameters.terms = MAX_TERMS;
    parameters.tscale = this->t_scale;

    gsl_function F;
    F.function = &drawT_f;
    F.params = &parameters;

    // Find a good interval to determine the first passage time in
    const Real dist( std::min(r0-sigma, a-r0) );

    // construct a guess: MSD = sqrt (2*d*D*t)
    Real t_guess( dist * dist / ( 2.0 * D ) );
    // A different guess has to be made in case of nonzero drift to account for the displacement due to it
    // When drifting towards the closest boundary...
    if( ( r0-sigma >= L/2.0 && v > 0.0 ) || ( r0-sigma <= L/2.0 && v < 0.0 ) )	t_guess = sqrt(D*D/(v*v*v*v)+dist*dist/(v*v)) - D/(v*v);
    // When drifting away from the closest boundary...
    if( ( r0-sigma  < L/2.0 && v > 0.0 ) || ( r0-sigma  > L/2.0 && v < 0.0 ) )	t_guess = D/(v*v) - sqrt(D*D/(v*v*v*v)-dist*dist/(v*v));
    
    
    Real value( GSL_FN_EVAL( &F, t_guess ) );
    Real low( t_guess );
    Real high( t_guess );

    if( value < 0.0 )
    {
	// scale the interval around the guess such that the function 
	// straddles if the guess was too low
	do
	{
	    // keep increasing the upper boundary until the 
	    // function straddles
	    high *= 10.0;
	    value = GSL_FN_EVAL( &F, high );

	    if( fabs( high ) >= t_guess * 1e6 )
	    {
		std::cerr << "Couldn't adjust high. F(" << high << ") = "
		          << value << std::endl;
		throw std::exception();
	    }
	}
	while ( value <= 0.0 );
    }
    else
    {
	// if the guess was too high initialize with 2 so the test 
	// below survives the first iteration
	Real value_prev( 2.0 );
	do
	{
	    if( fabs( low ) <= t_guess * 1.0e-6 ||
	        fabs(value-value_prev) < EPSILON*this->t_scale )
	    {
		std::cerr << "Couldn't adjust low. F(" << low << ") = "
		          << value << " t_guess: " << t_guess << " diff: "
		          << (value - value_prev) << " value: " << value
		          << " value_prev: " << value_prev << " t_scale: "
		          << this->t_scale << std::endl;
		return low;
	    }

	    value_prev = value;
	    // keep decreasing the lower boundary until the 
	    // function straddles
	    low *= 0.1;
	    // get the accompanying value
	    value = GSL_FN_EVAL( &F, low );

	}
	while ( value >= 0.0 );
    }

    // find the intersection on the y-axis between the random number and 
    // the function
    // define a new solver type brent
    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    // make a new solver instance
    // TODO: incl typecast?
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    const Real t( findRoot( F, solver, low, high, EPSILON*t_scale, EPSILON,
                            "GreensFunction1DAbsAbs::drawTime" ) );

    // return the drawn time
    return t;
}


// This is a help function that casts the drawR_params parameter structure into
// the right form and calculates the survival probability from it (and returns it).
// The routine drawR uses this function to sample the exit point, making use of the
// GSL root finder to draw the random position.
double
GreensFunction1DAbsAbs::drawR_f (double r, void *p)
{   
    struct drawR_params *params = (struct drawR_params *)p;
    double sum = 0, term = 0, prev_term = 0;
    double S_Cn_An, n_L;
    int    terms = params->terms;
    double sigma = params->H[0];
    double v2D = params->H[1];	// =v/(2D)

    int n=0;
    do
    {
	if (n >= terms )
	{
	    std::cerr << "Too many terms for DrawR. N: " << n << std::endl;
	    break;
	}
	prev_term = term;

	S_Cn_An = params->S_Cn_An[n];
	n_L = params->n_L[n];	// this is n*pi/L
	if(v2D==0.0)	term = S_Cn_An * ( 1.0 - cos(n_L*(r-sigma)) );
	else		term = S_Cn_An * ( exp(v2D*sigma) + exp(v2D*r)*( v2D/n_L*sin(n_L*(r-sigma)) - cos(n_L*(r-sigma)) ));
	  // S_Cn_An contains all expon. prefactors, the 1/S(t) term and all parts
	  // of the terms that do not depend on r.
	  //
	  // In case of zero drift the terms become S_An_Cn * ( 1 - cos(nPi/L*(r-sigma)) )
	  // as it should be. The if-statement is only to avoid calculation costs.

	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON ||
	fabs(prev_term/sum) > EPSILON ||
	n <= MIN_TERMS );

    // find the intersection with the random number
    return sum - params->rnd;
}

// Draws the position of the particle at a given time from p(r,t), assuming 
// that the particle is still in the domain
Real
GreensFunction1DAbsAbs::drawR (Real rnd, Real t) const
{
    THROW_UNLESS( std::invalid_argument, 0.0 <= rnd && rnd < 1.0 );
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );

    const Real a(this->geta());
    const Real sigma(this->getsigma());
    const Real L(this->geta() - this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());

    // the trivial case: if there was no movement or the domain was zero
    if ( (D==0.0 && v==0.0) || L<0.0 || t==0.0)
    {
	return r0;
    }
    else
    {
	// if the initial condition is at the boundary, raise an error
	// The particle can only be at the boundary in the ABOVE cases
	THROW_UNLESS( std::invalid_argument,
	              (r0-sigma) >= L*EPSILON && (r0-sigma) <= L*(1.0-EPSILON) );
    }
    // else the normal case
    // From here on the problem is well defined


    // structure to store the numbers to calculate numbers for 1-S(t)
    struct drawR_params parameters;
    Real S_Cn_An;
    Real nPI;
    const Real expo (-D*t/(L*L));
    const Real r0s_L((r0-sigma)/L);
    const Real v2D(v/2.0/D);
    const Real Lv2D(L*v/2.0/D);
    const Real vexpo(-v*v*t/4.0/D - v*r0/2.0/D);	// exponent of the drift-prefactor, same as in survival prob.
    const Real S = 2.0*exp(vexpo)/p_survival(t);	// This is a prefactor to every term, so it also contains there
							// exponential drift-prefactor.

    // Construct the coefficients and the terms in the exponent and put them 
    // in the params structure
    int n=0;
    do
    {
	nPI = ((Real)(n+1))*M_PI;	    // note: summation starting with n=1, indexing with n=0, therefore we need n+1 here
	
	if(v==0.0)	S_Cn_An = S * exp(nPI*nPI*expo) * sin(nPI*r0s_L) / nPI;
	else		S_Cn_An = S * exp(nPI*nPI*expo) * sin(nPI*r0s_L) * nPI/(nPI*nPI + Lv2D*Lv2D);
	  // The rest is the z-dependent part, which has to be defined directly in drawR_f(z).
	  // Of course also the summation happens there because the terms now are z-dependent.
	  // The last term originates from the integrated prob. density including drift.
	  //
	  // In case of zero drift this expression becomes: 2.0/p_survival(t) * exp(nPI*nPI*expo) * sin(nPI*r0s_L) / nPI
	  
	// also store the values for the exponent, so they don't have to be recalculated in drawR_f
	parameters.S_Cn_An[n]= S_Cn_An;
	parameters.n_L[n]    = nPI/L;
	n++;
    }
    while (n<MAX_TERMS);

    // store the random number for the probability
    parameters.rnd = rnd ;
    // store the number of terms used
    parameters.terms = MAX_TERMS;
    
    // store needed constants
    parameters.H[0] = sigma;
    parameters.H[1] = v2D;

    // find the intersection on the y-axis between the random number and 
    // the function
    gsl_function F;
    F.function = &drawR_f;
    F.params = &parameters;

    // define a new solver type brent
    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    // make a new solver instance
    // TODO: incl typecast?
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    const Real r( findRoot( F, solver, sigma, a, L*EPSILON, EPSILON,
                            "GreensFunction1DAbsAbs::drawR" ) );

    // return the drawn time
    return r;
}

std::string GreensFunction1DAbsAbs::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << ", sigma = " << this->getsigma() <<
        ", a = " << this->geta() << std::endl;
    return ss.str();
}
 </xmp> 
<h3> GreensFunction1DRadAbs.cpp </h3> <xmp>

#include <sstream>
#include <iostream>
#include <cstdlib>
#include <exception>
#include <vector>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_trig.h>
#include <gsl/gsl_sum.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_roots.h>

#include <math.h>

#include "findRoot.hpp"
#include "GreensFunction1DRadAbs.hpp"


// This is the appropriate definition of the function defining
// the roots of our Green's functions in GSL.
// Later needed by the rootfinder.
//
// It expects a reaction rate h=k/D already divided by D.
double
GreensFunction1DRadAbs::tan_f (double x, void *p)
{
    // casts the void to the struct pointer
    struct tan_f_params *params = (struct tan_f_params *)p;
    const Real a = (params->a);
    const Real h = (params->h);
    const Real h_a (h*a);
    if ( h_a < 1 )
    {
	// h = k/D
	return 1/tan(x) + (h_a)/x;
    }
    else
    {
	// h = k/D
	return tan(x) + x/(h_a);
    }
}

// Calculates the roots of tan(x*a)=-x/h
Real
GreensFunction1DRadAbs::root_n(int n) const
{
    const Real L( this->geta()-this->getsigma() );
    const Real h( (this->getk()+this->getv()/2.0) / this->getD() );
    // the drift v also comes into this constant, h=(k+v/2)/D
    Real upper, lower;

    if ( h*L < 1 )
    {
	// 1E-10 to make sure that he doesn't include the transition 
	lower = (n-1)*M_PI + 1E-10;
	// (asymptotic) from infinity to -infinity
	upper =  n   *M_PI - 1E-10;
    }
    else
    {
	lower = (n-1)*M_PI + M_PI_2 + 1E-10;
	upper = n    *M_PI + M_PI_2 - 1E-10;
    }

    gsl_function F;
    struct tan_f_params params = { L, h };
     
    F.function = &GreensFunction1DRadAbs::tan_f;
    F.params = &params;

    // define a new solver type brent
    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );

    // make a new solver instance
    // TODO: incl typecast?
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    // get the root = run the rootsolver
    const Real root( findRoot( F, solver, lower, upper, 1.0*EPSILON, EPSILON,
                            "GreensFunction1DRadAbs::root_tan" ) );
    gsl_root_fsolver_free( solver );
    
    return root/L;
    // This rescaling is important, because the function tan_f is used to solve for
    // tan(x)+x/h/L=0, whereas we actually need tan(x*L)+x/h=0, So if x solves the 
    // subsidiary equation, x/L solves the original one.
}

// This is the non-exponential factor in the Green's function sum, not
// including the factor containing the explicit r-dependency (The latter
// is given by the Bn's, see below).
//
// r0 is here still in the interval from 0 to a (and supposed to be the
// starting point of the particle at t0).
//
// The root a_n also must be the specific one for that interval, thus
// the one rescaled by a (see comments in function a_n(n) ).
//
// The factor calculated here is identical for the cases w. or w/o drift,
// only h changes.
Real
GreensFunction1DRadAbs::An (Real root_n) const
{
    const Real h((this->getk()+this->getv()/2.0)/this->getD());
    const Real sigma(this->getsigma());
    const Real L(this->geta()-this->getsigma());
    const Real r0(this->getr0());
    const Real rootn_r0_s = root_n*(r0-sigma);

    return (root_n*cos(rootn_r0_s) + h*sin(rootn_r0_s)) / (h + (root_n*root_n + h*h)*L);
}

// This factor appears in the survival prob.
Real
GreensFunction1DRadAbs::Bn (Real root_n) const
{
    const Real h((this->getk()+this->getv()/2.0)/this->getD());
    const Real k(this->getk());
    const Real D(this->getD());
    const Real v(this->getv());
    const Real sigma(this->getsigma());
    const Real a(this->geta());
    const Real L(this->geta()-this->getsigma());
    
    const Real rootnL(root_n*L);
    const Real rootn2(root_n*root_n);
    const Real h2(h*h);
    const Real v2D(v/2.0/D);

    if(v==0.0)	return (h2 - (rootn2 + h2)*cos(rootnL)) / (h*root_n);
    else	return (exp(v2D*sigma)*h*k/D - exp(v2D*a)*(rootn2+h2)*cos(rootnL) ) / (h/root_n*(rootn2+v2D*v2D));
}

// This is the exponential factor in the Green's function sum, also
// appearing in the survival prob. and prop. function.
//
// Also here the root is the one refering to the interval of length L.
Real
GreensFunction1DRadAbs::Cn (Real root_n, Real t)
const
{
    const Real D(this->getD());

    return std::exp(-D*root_n*root_n*t);
}

// Calculates the probability of finding the particle inside the domain
// at time t, the survival probability.
Real
GreensFunction1DRadAbs::p_survival (Real t) const
{
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );
  
    const Real D(this->getD());
    const Real v(this->getv());
    const Real vexpo(-v*v*t/4.0/D - v*r0/2.0/D);

    if (t == 0.0 || (D == 0.0 && v == 0.0) )
    {
	// if there was no time or no movement the particle was always
	// in the domain
	return 1.0;
    }


    Real root_n;
    Real sum = 0, term = 0, term_prev = 0;
    int n = 1;

    do
    {
	root_n = this->root_n(n);
	term_prev = term;
	term = this->Cn(root_n, t) * this->An(root_n) * this->Bn(root_n);
	sum += term;
	n++;
    }
    while ( fabs(term/sum) > EPSILON  ||
	fabs(term_prev/sum) > EPSILON ||
	n <= MIN_TERMS);

    return 2.0*exp(vexpo)*sum;
}


// Calculates the probability density of finding the particle at location r
// at time t.
Real
GreensFunction1DRadAbs::prob_r (Real r, Real t)
const
{
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );
    THROW_UNLESS( std::invalid_argument, (r-sigma) >= 0.0 && r <= a && (r0 - sigma) >= 0.0 && r0<=a );
    
    const Real sigma(this->getsigma());
    const Real a(this->geta());
    const Real L(this->geta()-this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());
    const Real h((this->getk()+this->getv()/2.0)/this->getD());
    
    const Real vexpo(-v*v*t/D/4.0 + v*(r-r0)/D/2.0);

    // if there was no time change or zero diffusivity => no movement
    if (t == 0 || D == 0)
    {
	// the probability density function is a delta function
	if (r == r0)
	{
	    return INFINITY;
	}
	else
	{
	    return 0.0;
	}
    }

    // if r is at the absorbing boundary
    if ( fabs(a-r) < EPSILON*L )
    {
	return 0.0;
    }

    Real root_n, root_n_r_s;
    Real sum = 0, term = 0, prev_term = 0;
    int n=1;

    do
    {
	if ( n >= MAX_TERMS )
	{
	    std::cerr << "Too many terms needed for GF1DRad::prob_r. N: "
	              << n << std::endl;
	    break;
	}

	root_n = this->root_n(n);
	root_n_r_s = root_n*(r-sigma);

	prev_term = term;
	term = Cn(root_n, t) * An(root_n) * (h*sin(root_n_r_s) + root_n*cos(root_n_r_s));
	sum += term;

	n++;
    }
    while (fabs(term/sum) > EPSILON*PDENS_TYPICAL || 
	fabs(prev_term/sum) > EPSILON*PDENS_TYPICAL ||
	n <= MIN_TERMS );

    return 2.0*exp(vexpo)*sum;
}

// Calculates the probability density of finding the particle at location z at
// timepoint t, given that the particle is still in the domain.
Real
GreensFunction1DRadAbs::calcpcum (Real r, Real t) const
{
    return prob_r(r, t)/p_survival(t);
}

// Calculates the total probability flux leaving the domain at time t
// This is simply the negative of the time derivative of the survival prob.
// at time t [-dS(t')/dt' for t'=t].
Real
GreensFunction1DRadAbs::flux_tot (Real t) const
{
    Real root_n;
    const Real D(this->getD());
    const Real v(this->getv());
    const Real vexpo(-v*v*t/4.0/D - v*r0/2.0/D);

    const Real D2 = D*D;
    const Real v2Dv2D = v*v/4.0/D2;
    double sum = 0, term = 0, prev_term = 0;
    int n=1;

    do
    {
	if ( n >= MAX_TERMS )
	{
	    std::cerr << "Too many terms needed for GF1DRad::flux_tot. N: "
	              << n << std::endl;
	    break;
	}

	root_n = this->root_n(n);
	prev_term = term;
	term = (root_n * root_n + v2Dv2D) * Cn(root_n, t) * An(root_n) * Bn(root_n);
	n++;
	sum += term;
    }
    while (fabs(term/sum) > EPSILON*PDENS_TYPICAL ||
	fabs(prev_term/sum) > EPSILON*PDENS_TYPICAL ||
	n <= MIN_TERMS );

    return 2.0*D*exp(vexpo)*sum;
}

// Calculates the probability flux leaving the domain through the radiative
// boundary at time t
Real
GreensFunction1DRadAbs::flux_rad (Real t) const
{
    return this->getk() * prob_r(this->getsigma(), t);
}

// Calculates the flux leaving the domain through the radiative boundary as a
// fraction of the total flux. This is the probability that the particle left
// the domain through the radiative boundary instead of the absorbing
// boundary.
Real
GreensFunction1DRadAbs::fluxRatioRadTot (Real t) const
{
    return flux_rad(t)/flux_tot(t);
}

// Determine which event has occured, an escape or a reaction. Based on the
// fluxes through the boundaries at the given time. Beware: if t is not a
// first passage time you still get an answer!
GreensFunction1DRadAbs::EventKind
GreensFunction1DRadAbs::drawEventType( Real rnd, Real t )
const
{
    THROW_UNLESS( std::invalid_argument, rnd < 1.0 && rnd >= 0.0 );
    THROW_UNLESS( std::invalid_argument, t > 0.0 );
    // if t=0 nothing has happened => no event

    const Real a(this->geta());
    const Real L(this->geta()-this->getsigma());
    const Real r0(this->getr0());

    // if the radiative boundary is impermeable (k==0) or
    // the particle is at the absorbing boundary (at a) => IV_ESCAPE event
    if ( k == 0 || fabs(a-r0) < EPSILON*L )
    {
	return IV_ESCAPE;
    }

    // Else the event is sampled from the flux ratio
    const Real fluxratio (this->fluxRatioRadTot(t));

    if (rnd > fluxratio )
    {
	return IV_ESCAPE;
    }
    else
    {
	return IV_REACTION;
    }
}

// This function is needed to cast the math. form of the function
// into the form needed by the GSL root solver.
double
GreensFunction1DRadAbs::drawT_f (double t, void *p)
{
    // casts p to type 'struct drawT_params *'
    struct drawT_params *params = (struct drawT_params *)p;
    Real Xn, exponent;
    Real prefactor = params->prefactor;
    int terms = params->terms;

    Real sum = 0, term = 0, prev_term = 0;
    int n=0;
    do
    {
	if ( n >= terms )
	{
	    std::cerr << "Too many terms needed for GF1DRad::DrawTime. N: "
	              << n << std::endl;
	    break;
	}
	prev_term = term;

	Xn = params->Xn[n];
	exponent = params->exponent[n];
	term = Xn * exp(exponent * t);
	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON*1.0 ||
	fabs(prev_term/sum) > EPSILON*1.0 ||
	n <= MIN_TERMS );

    // find the intersection with the random number
    return 1.0 - prefactor*sum - params->rnd;
}

// Draws the first passage time from the survival probability,
// using an assistance function drawT_f that casts the math. function
// into the form needed by the GSL root solver.
Real
GreensFunction1DRadAbs::drawTime (Real rnd) const
{
    THROW_UNLESS( std::invalid_argument, 0.0 <= rnd && rnd < 1.0 );
  
    const Real sigma(this->getsigma());
    const Real a(this->geta());
    const Real L(this->geta()-this->getsigma());
    const Real r0(this->getr0());
    const Real k(this->getk());
    const Real D(this->getD());
    const Real v(this->getv());
    const Real h((this->getk()+this->getv()/2.0)/this->getD());
    

    if ( D == 0.0 || L == INFINITY )
    {
	return INFINITY;
    }

    if ( rnd <= EPSILON || L < 0.0 || fabs(a-r0) < EPSILON*L )
    {
	return 0.0;
    }

    const Real v2D(v/2.0/D);
    const Real exp_av2D(exp(a*v2D));
    const Real exp_sigmav2D(exp(sigma*v2D));
    // exponent of the prefactor present in case of v<>0; has to be split because it has a t-dep. and t-indep. part
    const Real vexpo_t(-v*v/4.0/D);
    const Real vexpo_pref(-v*r0/2.0/D);

    // the structure to store the numbers to calculate the numbers for 1-S
    struct drawT_params parameters;
    // some temporary variables
    double root_n = 0;
    double root_n2, root_n_r0_s, root_n_L, h_root_n;
    double Xn, exponent, prefactor;


    // produce the coefficients and the terms in the exponent and put them
    // in the params structure. This is not very efficient at this point,
    // coefficients should be calculated on demand->TODO
    for (int n=0; n<MAX_TERMS; n++)
    {
	root_n = this->root_n(n+1);	// get the n-th root of tan(root*a)=root/-h (Note: root numbering starts at n=1)
	
	root_n2	    = root_n * root_n;
	root_n_r0_s = root_n * (r0-sigma);
	root_n_L    = root_n * L;
	h_root_n    = h / root_n;
	
	if(v==0)	Xn = (h*sin(root_n_r0_s) + root_n*cos(root_n_r0_s)) / (L*(root_n2+h*h)+h)
			      * ( h_root_n + sin(root_n_L) - h_root_n*cos(root_n_L) ); 
	else		Xn = (h*sin(root_n_r0_s) + root_n*cos(root_n_r0_s)) / (L*(root_n2+h*h)+h)
			      * (exp_sigmav2D*h*k/D - exp_av2D*(root_n2+h*h)*cos(root_n_L)) / (h_root_n * (root_n2 + v2D*v2D)); 
		  
	exponent = -D*root_n2 + vexpo_t;

	// store the coefficients in the structure
	parameters.Xn[n] = Xn;
	// also store the values for the exponent
	parameters.exponent[n] = exponent;
    }
    
    // the prefactor of the sum is also different in case of drift<>0 :
    if(v==0)	prefactor = 2.0;
    else	prefactor = 2.0*exp(vexpo_pref);
    parameters.prefactor  = prefactor;
    
    // store the random number for the probability
    parameters.rnd = rnd;
    // store the number of terms used
    parameters.terms = MAX_TERMS;
    parameters.tscale = this->t_scale;

    // Define the function for the rootfinder
    gsl_function F;
    F.function = &GreensFunction1DRadAbs::drawT_f;
    F.params = &parameters;


    // Find a good interval to determine the first passage time in
    // get the distance to absorbing boundary (disregard rad BC)
    const Real dist(fabs(a-r0));
    //const Real dist( std::min(r0, a-r0));	// for test purposes
    // construct a guess: MSD = sqrt (2*d*D*t)
    Real t_guess( dist * dist / ( 2.0*D ) );
    // A different guess has to be made in case of nonzero drift to account for the displacement due to it
    // TODO: This does not work properly in this case yet, but we don't know why...
    // When drifting towards the closest boundary
    //if( (r0 >= a/2.0 && v > 0.0) || (r0 <= a/2.0 && v < 0.0) )	t_guess = sqrt(D*D/(v*v*v*v)+dist*dist/(v*v)) - D/(v*v);
    // When drifting away from the closest boundary
    //if( ( r0 < a/2.0 && v > 0.0) || ( r0 > a/2.0 && v < 0.0) )	t_guess = D/(v*v) - sqrt(D*D/(v*v*v*v)-dist*dist/(v*v));
    
    Real value( GSL_FN_EVAL( &F, t_guess ) );
    Real low( t_guess );
    Real high( t_guess );


    // scale the interval around the guess such that the function straddles
    if( value < 0.0 )
    {
	// if the guess was too low
	do
	{
	    // keep increasing the upper boundary until the
	    // function straddles
	    high *= 10;
	    value = GSL_FN_EVAL( &F, high );

	    if( fabs( high ) >= t_guess * 1e6 )
	    {
		std::cerr << "GF1DRad: Couldn't adjust high. F("
		          << high << ") = " << value << std::endl;
		throw std::exception();
	    }
	}
	while ( value <= 0.0 );
    }
    else
    {
	// if the guess was too high
	// initialize with 2 so the test below survives the first
	// iteration
	Real value_prev( 2 );
	do
	{
	    if( fabs( low ) <= t_guess * 1e-6 ||
	        fabs(value-value_prev) < EPSILON*1.0 )
	    {
		std::cerr << "GF1DRad: Couldn't adjust low. F(" << low << ") = "
		          << value << " t_guess: " << t_guess << " diff: "
		          << (value - value_prev) << " value: " << value
		          << " value_prev: " << value_prev << " rnd: "
		          << rnd << std::endl;
		return low;
	    }
	    value_prev = value;
	    // keep decreasing the lower boundary until the function straddles
	    low *= 0.1;
	    // get the accompanying value
	    value = GSL_FN_EVAL( &F, low );
	}
	while ( value >= 0.0 );
    }

    // find the intersection on the y-axis between the random number and
    // the function
    
    // define a new solver type brent
    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    // make a new solver instance
    // TODO: incl typecast?
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    const Real t( findRoot( F, solver, low, high, t_scale*EPSILON, EPSILON,
                            "GreensFunction1DRadAbs::drawTime" ) );

    // return the drawn time
    return t;
}

double
GreensFunction1DRadAbs::drawR_f (double z, void *p)
{
    // casts p to type 'struct drawR_params *'
    struct drawR_params *params = (struct drawR_params *)p;
    Real v2D 		= params->H[0];	// = v2D = v/(2D)
    Real costerm 	= params->H[1];	// = k/D
    Real sinterm 	= params->H[2];	// = h*v2D
    Real sigma 		= params->H[3];	// = sigma
    int  terms = params->terms;

    Real expsigma(exp(sigma*v2D));
    Real zs(z-sigma);
    
    Real sum = 0, term = 0, prev_term = 0;
    Real root_n, S_Cn_root_n;
    
    int n = 0;
    do
    {
	if ( n >= terms )
	{
	    std::cerr << "GF1DRad: Too many terms needed for DrawR. N: "
	              << n << std::endl;
	    break;
	}
	prev_term = term;

	S_Cn_root_n = params->S_Cn_root_n[n];
	root_n  = params->root_n[n];
	term = S_Cn_root_n * ( expsigma*costerm - exp(v2D*z)*( costerm*cos(root_n*zs) - (root_n+sinterm/root_n)*sin(root_n*zs) ));

	sum += term;
	n++;
    }
    while (fabs(term/sum) > EPSILON*1.0 ||
	fabs(prev_term/sum) > EPSILON*1.0 ||
	n <= MIN_TERMS );

    // Find the intersection with the random number
    return sum - params->rnd;
}

Real
GreensFunction1DRadAbs::drawR (Real rnd, Real t) const
{
    THROW_UNLESS( std::invalid_argument, 0.0 <= rnd && rnd < 1.0 );
    THROW_UNLESS( std::invalid_argument, t >= 0.0 );
    
    const Real sigma(this->getsigma());
    const Real a(this->geta());
    const Real L(this->geta()-this->getsigma());
    const Real r0(this->getr0());
    const Real D(this->getD());
    const Real v(this->getv());
    const Real k(this->getk());
    const Real h((this->getk()+this->getv()/2.0)/this->getD());
    

    if (t==0.0 || (D==0.0 && v==0.0) )
    {
	// the trivial case
	//return r0*this->l_scale;	// renormalized version, discontinued
	return r0;
    }
    if ( a<0.0 )
    {
	// if the domain had zero size
	return 0.0;
    }

    // the structure to store the numbers to calculate the numbers for 1-S
    struct drawR_params parameters;
    double root_n = 0;
    double S_Cn_root_n;
    double root_n2, root_n_r0_s;
    const Real vexpo(-v*v*t/4.0/D - v*r0/2.0/D); // exponent of the drift-prefactor, same as in survival prob.
    const Real v2D(v/2.0/D);
    const Real v2Dv2D(v2D*v2D);
    const Real S = 2.0*exp(vexpo)/p_survival(t); // This is a prefactor to every term, so it also contains
						 // the exponential drift-prefactor.


    // produce the coefficients and the terms in the exponent and put them
    // in the params structure
    for (int n=0; n<MAX_TERMS; n++)
    {
	root_n = this->root_n(n+1);  // get the n-th root of tan(alfa*a)=alfa/-k
	root_n2 = root_n * root_n;
	root_n_r0_s = root_n * (r0-sigma);
	S_Cn_root_n =	S * exp(-D*root_n2*t)
		      * (root_n*cos(root_n_r0_s) + h*sin(root_n_r0_s)) / (L*(root_n2 + h*h) + h)
		      * root_n / (root_n2 + v2Dv2D);

	// store the coefficients in the structure
	parameters.root_n[n] = root_n;
	// also store the values for the exponent
	parameters.S_Cn_root_n[n] = S_Cn_root_n;
    }
    
    // store the random number for the probability
    parameters.rnd = rnd;
    // store the number of terms used
    parameters.terms = MAX_TERMS;
    
    // also store constant prefactors that appear in the calculation of the
    // r-dependent terms
    parameters.H[0] = v2D;		// appears together with z in one of the prefactors
    parameters.H[1] = k/D;		// further constant terms of the cosine prefactor
    parameters.H[2] = h*v2D;		// further constant terms of the sine prefactor
    parameters.H[3] = sigma;


    // find the intersection on the y-axis between the random number and
    // the function
    gsl_function F;
    F.function = &GreensFunction1DRadAbs::drawR_f;
    F.params = &parameters;

    // define a new solver type brent
    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    // make a new solver instance
    // TODO: incl typecast?
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    Real r( findRoot( F, solver, sigma, a, EPSILON*L, EPSILON,
                            "GreensFunction1DRadAbs::drawR" ) );

    // return the drawn position
    return r;
}

std::string GreensFunction1DRadAbs::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << ", sigma = " << this->getsigma() <<
        ", a = " << this->geta() <<
        ", k = " << this->getk() << std::endl;
    return ss.str();
}

 </xmp> 
<h3> GreensFunction3DAbs.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "compat.h"

#include <stdexcept>
#include <vector>
#include <sstream>
#include <algorithm>

#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_legendre.h>
#include <gsl/gsl_sf_bessel.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_roots.h>
#include <gsl/gsl_sf_lambert.h>

#include "funcSum.hpp"
#include "freeFunctions.hpp"
#include "SphericalBesselGenerator.hpp"
#include "GreensFunction3DAbs.hpp"

typedef GreensFunction3DAbs GF3DA;

GF3DA::GreensFunction3DAbs(Real D, Real r0, Real a) 
    : GreensFunction3DRadAbsBase(D, 0., r0, 0.), a(a)
{
    if (a < 0.0)
    {
        throw std::invalid_argument((boost::format("a >= 0.0 : a=%g") % a).str());
    }
}

GF3DA::~GreensFunction3DAbs()
{
    ; // do nothing
}

Real
GF3DA::p_survival(Real t) const
{
    const Real D(getD());
    const Real a(geta());

    return p_survival_nocollision(t, r0, D, a);
}


Real
GF3DA::dp_survival(Real t) const
{
    const Real D(getD());
    const Real a(geta());

    return dp_survival_nocollision(t, r0, D, a);
}

Real
GF3DA::p_int_r(Real r, Real t) const
{
    const Real D(getD());
    const Real a(geta());

    const Real Dt(D * t);
    const Real asq(a * a);
    const Real a_r(1.0 / a);
    const Real asq_r(a_r * a_r);

    const Real PIr0(M_PI * r0);
    const Real PIr(M_PI * r);

    const Real r0_angle_factor(PIr0 * a_r);
    const Real r_angle_factor(PIr * a_r);
    const Real exp_factor(- Dt * M_PI * M_PI * asq_r);

    const unsigned int i_max(
        std::max(static_cast<unsigned int>(
                      ceil(sqrt( 1.0 - asq / M_PI / M_PI
                                    * log(TOLERANCE) / Dt ) 
                          )), 
                  2u));

    Real p(0.0);
    unsigned int i(1);
    for (;;)
    {
        Real sin_r;
        Real cos_r;
        sincos(r_angle_factor * i, &sin_r, &cos_r);

        const Real isq(i * i);

        const Real term1(exp(exp_factor * isq) * 
                          sin(r0_angle_factor * i));
        const Real term2(a * sin_r - PIr * i * cos_r);
        const Real term(term1 * term2 / isq);
        
        p += term;

        if (i >= i_max)
        {
            break;
        }

        ++i;
    }

    const Real factor(M_2_PI / PIr0);

    return p * factor;
}

struct p_survival_params
{ 
    const GF3DA* const gf;
    const Real rnd;
};

Real
static p_survival_F(Real t, p_survival_params const* params)
{
    const GF3DA* const gf(params->gf); 
    const Real rnd(params->rnd);

    return rnd - gf->p_survival(t);
}

struct p_int_r_params
{ 
    const GF3DA* const gf;
    const Real t;
    const Real rnd;
};

static Real p_int_r_F(Real r, p_int_r_params const* params)
{
    const GF3DA* const gf(params->gf); 
    const Real t(params->t);
    const Real rnd(params->rnd);

    return gf->p_int_r(r, t) - rnd;
}

Real 
GF3DA::p_n_alpha(unsigned int i, unsigned int n, Real r, Real t) const
{
    const Real a(geta());

    const Real mDt(- getD() * t);

    // j = a alpha -> alpha = j / a
    const Real aalpha(gsl_sf_bessel_zero_Jnu(static_cast<Real>(n) + 0.5, 
                                               i + 1));
    const Real alpha(aalpha / a);

    const Real term1(exp(mDt * alpha * alpha));

    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());

    const Real jr( s.j(n,   r * alpha));
    const Real jr0(s.j(n,   r0 * alpha));
    const Real ja2(s.j(n+1,   aalpha));

    const Real num(jr * jr0);
    const Real den(ja2 * ja2);

    const Real result(term1 * num / den);

    return result;
}


Real 
GF3DA::p_n(Integer n, Real r, Real t) const
{
    const Real p(funcSum(boost::bind(&GF3DA::p_n_alpha, this, _1, n, r, t),
                         MAX_ALPHA_SEQ));

    return p;
}

void
GF3DA::makep_nTable(RealVector& p_nTable, Real r, Real t) const
{
    const Real a(geta());

    p_nTable.clear();

    const Real factor(1.0 / (2.0 * M_PI * gsl_pow_3(a))); 

    const Real p_0(p_n(0, r, t) * factor);
    p_nTable.push_back(p_0);

    if (p_0 == 0)
    {
        return;
    }

    const Real threshold(fabs(p_0 * THETA_TOLERANCE * 1e-1 ));

    Real p_n_prev_abs(fabs(p_0));
    unsigned int n(1);
    for (;;) 
    {
        Real p_n(this->p_n(n, r, t) * factor);

        if (! isfinite(p_n))
        {
            log_.error("makep_nTable: invalid value: %g (n=%d)", p_n, n);
            break;
        }

        p_nTable.push_back(p_n);

        const Real p_n_abs(fabs(p_n));
        // truncate when converged enough.
        if (p_n_abs <= threshold &&
            p_n_prev_abs <= threshold &&
            p_n_abs <= p_n_prev_abs)
        {
            break;
        }
        

        if (n >= MAX_ORDER)
        {
            break;
        }
        
        ++n;
        p_n_prev_abs = p_n_abs;
    }

}



static Real
p_theta_i(unsigned int n,
          GF3DA::RealVector const& p_nTable,
          GF3DA::RealVector const& lgndTable)
{
    return p_nTable[n] * lgndTable[n] * (2 * n + 1);
}

Real GF3DA::p_theta_table(Real theta, Real r, Real t, RealVector const& p_nTable) const
{
    const unsigned int tableSize(p_nTable.size());

    RealVector lgndTable(tableSize);

    Real sin_theta;
    Real cos_theta;
    sincos(theta, &sin_theta, &cos_theta);
    gsl_sf_legendre_Pl_array(tableSize-1, cos_theta, &lgndTable[0]);

    return funcSum_all(
        boost::bind(&p_theta_i, _1, p_nTable, lgndTable),
        tableSize) * sin_theta;
}


Real GF3DA::p_theta(Real theta, Real r, Real t) const 
{
    {
        const Real a(geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        if (!(r >= 0 && r < a))
        {
            throw std::invalid_argument((boost::format("r >= 0 && r < a : r=%g, a=%g") % r % a).str());
        }

        if (!(r0 >= 0 && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= 0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0)
    {
        return 0.0;
    }

    
    RealVector p_nTable;

    makep_nTable(p_nTable, r, t);

    const Real p(p_theta_table(theta, r, t, p_nTable));

    return p;
}



Real GF3DA::ip_theta(Real theta, Real r, Real t) const
{
    {
        const Real a(geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        // r \in (sigma, a)
        if (!(r >= 0.0 && r < a))
        {
            throw std::invalid_argument((boost::format("r >= 0.0 && r < a : r=%g, a=%g") % r % a).str());
        }

        if (!(r0 >= 0.0 && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0 || theta == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makep_nTable(p_nTable, r, t);

    const Real p(ip_theta_table(theta, r, t, p_nTable));

    return p;
}

static Real
ip_theta_i(unsigned int n,
           GF3DA::RealVector const& p_nTable,
           GF3DA::RealVector const& lgndTable1)
{
    // lgndTable1 is offset by 1; lgndTable1[0] is for n=-1.

    const Real lgnd_n_m1(lgndTable1[n]);   // n-1
    const Real lgnd_n_p1(lgndTable1[n+2]); // n+1
    
    return p_nTable[n] * (lgnd_n_m1 - lgnd_n_p1);// / (1.0 + 2.0 * n);
}


Real 
GF3DA::ip_theta_table(
    Real theta, Real r, Real t, RealVector const& p_nTable) const
{
    const unsigned int tableSize(p_nTable.size());

    RealVector pTable;
    pTable.reserve(tableSize);

    const Real cos_theta(cos(theta));

    // LgndTable is offset by 1 to incorporate the n=-1 case.
    // For ex: LgndTable[0] is for n=-1, lgndTable[1] is for n=0 ...

    RealVector lgndTable1(tableSize + 2);
    lgndTable1[0] = 1.0;  // n = -1
    gsl_sf_legendre_Pl_array(tableSize, cos_theta, &lgndTable1[1]);


    return funcSum_all(
        boost::bind(&ip_theta_i, _1, p_nTable, lgndTable1),
        tableSize);
}

struct GF3DA::ip_theta_params
{ 
    GF3DA const* const gf;
    const Real r;
    const Real t;
    RealVector const& p_nTable;
    const Real value;
};

Real GF3DA::ip_theta_F(Real theta, ip_theta_params const* params)
{
    const GF3DA* const gf(params->gf); 
    const Real r(params->r);
    const Real t(params->t);
    const RealVector& p_nTable(params->p_nTable);
    const Real value(params->value);

    return gf->ip_theta_table(theta, r, t, p_nTable) - value;
}


Real 
GF3DA::dp_n_alpha(unsigned int i, unsigned int n, Real t) const
{
    const Real a(geta());

    const Real mDt(- getD() * t);

    const Real 
        aalpha(gsl_sf_bessel_zero_Jnu(static_cast<Real>(n) + 0.5, i + 1));
    const Real alpha(aalpha / a);

    const Real term1(exp(mDt * alpha * alpha) * alpha);

    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());

    const Real jr0(s.j(n,   r0 * alpha));
    const Real ja2(s.j(n+1,   aalpha));

    const Real result(term1 * jr0 / ja2);

    return result;
}



Real 
GF3DA::dp_n(Integer n, Real t) const
{
    const Real 
        p(funcSum(boost::bind(&GF3DA::dp_n_alpha, this, _1, n, t),
                  MAX_ALPHA_SEQ));

    return p;
}


void GF3DA::makedp_nTable(RealVector& p_nTable, Real t) const
{
    p_nTable.clear();

    const Real factor(- getD() / (2.0 * M_PI * gsl_pow_3(a)));

    const Real p_0(dp_n(0, t) * factor);
    p_nTable.push_back(p_0);

    if (p_0 == 0)
    {
        return;
    }

    const Real threshold(fabs(THETA_TOLERANCE * p_0 * 1e-1));

    Real p_n_prev_abs(fabs(p_0));
    unsigned int n(1);
    for (;;)
    {
        Real p_n(dp_n(n, t) * factor);

        if (! isfinite(p_n))
        {
            log_.error("makedp_nTable: invalid value: %g (n=%d)", p_n, n);
            break;
        }

        p_nTable.push_back(p_n);

        const Real p_n_abs(fabs(p_n));
        // truncate when converged enough.
        if (p_n_abs <= threshold &&
            p_n_prev_abs <= threshold &&
            p_n_abs <= p_n_prev_abs)
        {
            break;
        }
        

        if (n >= MAX_ORDER)
        {
            break;
        }
        
        ++n;
        p_n_prev_abs = p_n_abs;
    }

}

Real 
GF3DA::dp_theta(Real theta, Real r, Real t) const 
{
    {
        const Real a(geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }


        // r \in [ sigma, a ]  ;  unlike p_theta,
        // defined at r == sigma and r == a.
        if (!(r >= 0.0 && r <= a))
        {
            throw std::invalid_argument((boost::format("r >= 0.0 && r <= a : r=%g, a=%g") % r % a).str());
        }

        if (!(r0 >= 0.0 && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makedp_nTable(p_nTable, t);

    const Real p(p_theta_table(theta, r, t, p_nTable));

    return p;
}

Real 
GF3DA::idp_theta(Real theta, Real r, Real t) const
{
    {
        const Real a(geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        // r \in [ sigma, a ]
        if (!(r >= 0.0 && r <= a))
        {
            throw std::invalid_argument((boost::format("r >= 0.0 && r <= a : r=%g, a=%g") % r % a).str());
        }

        if (!(r0 >= 0.0 && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0 || theta == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makedp_nTable(p_nTable, t);

    const Real p(ip_theta_table(theta, r, t, p_nTable));

    return p;
}

Real 
GF3DA::drawTime(Real rnd) const
{
   const Real a(geta());

   if (!(rnd <= 1.0 && rnd >= 0.0))
   {
       throw std::invalid_argument((boost::format("rnd <= 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
   }

   if (!(r0 >= 0.0 && r0 <= a))
   {
       throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 <= a : r0=%g, a=%g") % r0 % a).str());
   }


   if (r0 == a || a == 0.0)
   {
       return 0.0;
   }

   Real low(1e-6);
   Real high(1.0);

   p_survival_params params = { this, rnd };

   gsl_function F = {
       reinterpret_cast<typeof(F.function)>(&p_survival_F),
       &params 
   };

    // adjust high and low to make sure that f(low) and f(high) straddle.
    while(GSL_FN_EVAL(&F, high) < 0.0)
    {
        high *= 10;
        log_.info("drawTime: adjusting high: %g", high);
        if (fabs(high) >= 1e10)
        {
            throw std::runtime_error(
                (boost::format("couldn't adjust high. F(%g) = %g; r0=%g, %s") %
                    high % GSL_FN_EVAL(&F, high) % r0 % dump()).str());
        }
    }

    Real low_value(GSL_FN_EVAL(&F, low));
    while(low_value > 0.0)
    {
        low *= .1;

        const Real low_value_new(GSL_FN_EVAL(&F, low));

        log_.info("drawTime: adjusting low: %g, F = %g", low, low_value_new);

        if (fabs(low) <= MIN_T || 
            fabs(low_value - low_value_new) < TOLERANCE) 
        {
            log_.info("couldn't adjust low.  Returning %g as MIN_T; "
                      "F(%g) = %g; r0 = %g, %s", MIN_T, low,
                      GSL_FN_EVAL(&F, low), r0, dump().c_str());
            return MIN_T;
        }

        low_value = low_value_new;
    }

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);

        const int status(gsl_root_test_interval(low, high, MIN_T, 
                                                  TOLERANCE));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawTime: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    Real t(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);

    return t;
}

Real 
GF3DA::drawR(Real rnd, Real t) const
{
    const Real a(geta());

    if (!(rnd <= 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd <= 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= 0.0 && r0 < a))
    {
        throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
    }


    if (t == 0.0)
    {
        return r0;
    }

    const Real psurv(p_survival(t));

    p_int_r_params params = { this, t, rnd * psurv };

    gsl_function F = {
        reinterpret_cast<typeof(F.function)>(&p_int_r_F),
        &params 
    };

    Real low(0.0);
    Real high(a);

//    const Real lowvalue(GSL_FN_EVAL(&F, low ));
    const Real highvalue(GSL_FN_EVAL(&F, high));

    // No initial range guess, except the negative value check below,
    // as evaluation of p_int_r in this GF seems pretty robust.

    if (highvalue < 0.0)
    {
        log_.info("drawR: highvalue < 0.0 (%g). returning a (%g)", highvalue, a);
        return a;
    }


    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        const int status(gsl_root_test_interval(low, high, 1e-15,
                                                  TOLERANCE));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawR: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real r(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);

    return r;
}
    
Real 
GF3DA::drawTheta(Real rnd, Real r, Real t) const
{
    Real theta;

    const Real a(geta());

    // input parameter range checks.
    if (!(rnd <= 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd <= 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= 0.0 && r0 < a))
    {
        throw std::invalid_argument((boost::format("r0 >= 0.0 && r0 < a : r0=%g, a=%g") % r0 % a).str());
    }

    if (!(r >= 0.0 && r <= a))
    {
        throw std::invalid_argument((boost::format("r >= 0.0 && r <= a : r=%g, a=%g") % r % a).str());
    }

    if (!(t >= 0.0))
    {
        throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
    }


    // t == 0 means no move.
    if (t == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    if (r == geta() || r < 0.0)
    {
        makedp_nTable(p_nTable, t);
    }
    else
    {
        makep_nTable(p_nTable, r, t);
    }

    // root finding with the integrand form.

    const Real ip_theta_pi(ip_theta_table(M_PI, r, t, p_nTable));

    ip_theta_params params = { this, r, t, p_nTable, rnd * ip_theta_pi };

    gsl_function F = {
        reinterpret_cast<typeof(F.function)>(&ip_theta_F),
        &params 
    };

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, 0.0, M_PI);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        const Real low(gsl_root_fsolver_x_lower(solver));
        const Real high(gsl_root_fsolver_x_upper(solver));
        const int status(gsl_root_test_interval(low, high, 1e-11,
                                                  THETA_TOLERANCE));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawTheta: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    theta = gsl_root_fsolver_root(solver);
    gsl_root_fsolver_free(solver);
    
    return theta;
}

GF3DA::EventKind GF3DA::drawEventType(Real rnd, Real t) const
{
    assert(0);
}

//
// debug
//

std::string GF3DA::dump() const
{
    std::ostringstream ss;
    ss << "D = " << getD() <<
        ", a = " << geta() << std::endl;
    return ss.str();
}

Logger& GreensFunction3DAbs::log_(
    Logger::get_logger("GreensFunction3DAbs"));
 </xmp> 
<h3> GreensFunction3DAbsSym.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "compat.h"

#include <sstream>
#include <exception>
#include <vector>
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_trig.h>
#include <gsl/gsl_sum.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_roots.h>

#include "findRoot.hpp"
#include "GreensFunction3DAbsSym.hpp"

/**
  EllipticTheta[4,0,q]

  Efficiently calculate EllipticTheta[4,0,q] for q < 1.0.
*/

Real GreensFunction3DAbsSym::ellipticTheta4Zero(Real q)
{
    if (fabs(q) > 1.0)
    {
        throw std::invalid_argument((boost::format("fabs(%g) <= 1.0") % q).str());
    }

    // et4z(1 - 1e4) ~= 7.2e-23
    // et4z(1e-15) ~= 1 - 2e-15
    // et4z(1e-16) ~= 1 - 2.2e-16
    // et4z(1e-17) ~= 1 - (zero)

    const Integer N(1000);
    Real value(1.0);
    
    Real q_n(q);
    Real q_2n(1.0);
    
    for (Integer n(1); n <= N; ++n)
    {
        const Real term2(1.0 - q_2n * q);  // q^(2n-1) = (q^(n-1))^2 * q
        
        q_2n = q_n * q_n;
        
        const Real term1(1.0 - q_2n); // q^2n
        
        const Real term(term1 * term2 * term2);
        const Real value_prev(value);
        value *= term;
        
        // here only absolute error is checked because it is good enough
        // for our use.  (it's compared with 1 in p_survival).
        if (fabs(value - value_prev) < 1e-18) 
        {
            // normal exit.
            return value;
        }
        
        q_n *= q;  // q_(++n)
    }
    
    log_.warn("ellipticTheta4Zero: didn't converge");
    return value;
}


Real GreensFunction3DAbsSym::p_survival(Real t) const
{
    const Real D(getD());
    const Real a(geta());
    const Real asq(a * a);
    const Real PIsq(M_PI * M_PI);

    const Real q(- D * PIsq * t / asq);
    return 1.0 - ellipticTheta4Zero(exp(q));
} 

Real GreensFunction3DAbsSym::p_int_r_free(Real r, Real t) const
{
    const Real D(getD());
    const Real Dt(D * t);
    const Real sqrtDt(sqrt(Dt));
    const Real sqrtPI(sqrt(M_PI));

    return erf(r / (sqrtDt + sqrtDt))
        - r * exp(- r * r / (4.0 * Dt)) / (sqrtPI * sqrtDt);
}

Real GreensFunction3DAbsSym::p_int_r(Real r, Real t) const
{
    Real value(0.0);

    const Real a(geta());
    const Real p_free(this->p_int_r_free(r, t));

    // p_int_r is always smaller than p_free.
    if (fabs(p_free) < CUTOFF)
    {
        return 0.0;
    }

    const Real D(getD());
    const Real asq(a * a);
    const Real PIsq(M_PI * M_PI);

    const Real PIr(M_PI * r);
    const Real PIr_a(PIr / a);
    const Real DtPIsq_asq(D * t * PIsq / asq);
    
    const Real factor(2.0 / (a * M_PI));

    const Real maxn((a / M_PI) * sqrt(log(exp(DtPIsq_asq) / CUTOFF) / 
                                          (D * t)));

    const Integer N_MAX(10000);

    const Integer N(std::min(static_cast<Integer>(ceil(maxn) + 1),
                               N_MAX));
    if (N == N_MAX)
    {
        log_.warn("p_int_r: didn't converge");
    }
    

    for (int n(1); n <= N; ++n)
    {
        const Real term1(exp(- n * n * DtPIsq_asq));
      
        const Real angle_n(n * PIr_a);
        Real sin_n;
        Real cos_n;
        sincos(angle_n, &sin_n, &cos_n);
        const Real term2(a * sin_n);
        const Real term3(n * PIr * cos_n);

        const Real term(term1 * (term2 - term3) / n);
        value += term;
    }

    return value * factor;
} 

Real GreensFunction3DAbsSym::p_r_fourier(Real r, Real t) const 
{
    Real value(0.0);

    const Real D(getD());
    const Real a(geta());
    const Real asq(a * a);
    const Real PIsq(M_PI * M_PI);

    const Integer N(100);

    long int n(1);
    for (;;)
    {
        const Real term1(exp(- (PIsq * r * r + asq * n*n) / 
                               (4.0 * D * PIsq * t)));

        const Real term2(M_PI * r * 
                          exp(gsl_sf_lncosh(a * r * n / 
                                              (2.0 * D * M_PI * t))));

        const Real term3(a * n *
                          exp(gsl_sf_lnsinh(a * r * n / 
                                              (2.0 * D * M_PI * t))));


        const Real term(term1 * r * (term2 - term3));
        value += term;

        if (fabs(value) * 1e-8 > fabs(term))
        {
            break;
        }

        if (n > N)
        {
            log_.warn("p_r_fourier: didn't converge; n = %d, value = %g", n, value);
            break;
        }

        ++n;
    }

    const Real factor(1.0 / (sqrt(2) * PIsq * pow(D * t, 1.5)));

    return value * factor;
} 

struct p_survival_params
{
    const GreensFunction3DAbsSym* const gf;
    const Real rnd;
};

static Real p_survival_F(Real t, p_survival_params const* params)
{
    return params->rnd - params->gf->p_survival(t);
}


Real GreensFunction3DAbsSym::drawTime(Real rnd) const
{
    const Real D(getD());

    if (rnd >= 1.0 || rnd < 0.0)
    {
        throw std::invalid_argument((boost::format("0.0 <= %g < 1.0") % rnd).str());
    }

    const Real a(geta());

    if (D == 0.0 || a == INFINITY)
    {
        return INFINITY;
    }

    if (a == 0.0)
    {
        return 0.0;
    }

    p_survival_params params = { this, rnd };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_survival_F),
            &params 
        };

    const Real t_guess(a * a / (6. * D));

    Real low(t_guess);
    Real high(t_guess);

    const Real value(GSL_FN_EVAL(&F, t_guess));

    if (value < 0.0)
    {
        high *= 10;

        for (;;)
        {
            const Real high_value(GSL_FN_EVAL(&F, high));
            
            if (high_value >= 0.0)
            {
                break;
            }

            if (fabs(high) >= t_guess * 1e6)
            {
                throw std::runtime_error(
                    (boost::format("couldn't adjust high. F(%g) = %g; %s") %
                       high % GSL_FN_EVAL(&F, high) %
                       boost::lexical_cast<std::string>(*this)).str());
            }
            high *= 10;
        }
    }
    else
    {
        Real low_value_prev(value);
        low *= .1;

        for (;;)
        {
            const Real low_value(GSL_FN_EVAL(&F, low));
            
            if (low_value <= 0.0)
            {
                break;
            }
            
            if (fabs(low) <= t_guess * 1e-6 ||
                fabs(low_value - low_value_prev) < CUTOFF)
            {
                log_.info("couldn't adjust high. F(%g) = %g; %s",
                          low, GSL_FN_EVAL(&F, low),
                          boost::lexical_cast<std::string>(*this).c_str());
                log_.info("returning low (%g)", low);
                return low;
            }
            low_value_prev = low_value;
            low *= .1;
        }
    }


    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));

    const Real t(findRoot(F, solver, low, high, 1e-18, 1e-12,
                            "GreensFunction3DAbsSym::drawTime"));

    gsl_root_fsolver_free(solver);

    return t;
}

struct p_r_params
{
    const GreensFunction3DAbsSym* const gf;
    const Real t;
    const Real target;
};

static Real p_r_free_F(Real r, p_r_params const* params)
{
    return params->gf->p_int_r_free(r, params->t) - params->target;
}


static Real p_r_F(Real r, p_r_params const* params)
{
    return params->gf->p_int_r(r, params->t) - params->target;
}

Real GreensFunction3DAbsSym::drawR(Real rnd, Real t) const 
{
    if (rnd >= 1.0 || rnd < 0.0)
    {
        throw std::invalid_argument((boost::format("0.0 <= %g < 1.0") % rnd).str());
    }

    if (t < 0.0)
    {
        throw std::invalid_argument((boost::format("%g < 0.0") % t).str());
    }

    const Real a(geta());
    const Real D(getD());

    if (a == 0.0 || t == 0.0 || D == 0.0)
    {
        return 0.0;
    }

    const Real thresholdDistance(this->CUTOFF_H * sqrt(6.0 * D * t));

    gsl_function F;
    Real psurv;

    if (a <= thresholdDistance)
    {
        psurv = p_survival(t);

        if (psurv == 0.0)
        {
            return a;
        }

        assert(psurv >= 0.0);

        F.function = reinterpret_cast<typeof(F.function)>(&p_r_F);
    }
    else
    {
        // p_int_r < p_int_r_free
        if (p_int_r_free(a, t) < rnd)
        {
            log_.info("p_int_r_free(a, t) < rnd, returning a");
            return a;
        }

        psurv = 1.0;
        F.function = reinterpret_cast<typeof(F.function)>(&p_r_free_F);
    }

    const Real target(psurv * rnd);
    p_r_params params = { this, t, target };

    F.params = &params;


    const Real low(0.0);
    const Real high(a);
    //const Real high(std::min(thresholdDistance, a));

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));

    const Real r(findRoot(F, solver, low, high, 1e-18, 1e-12,
                            "GreensFunction3DAbsSym::drawR"));
  
    gsl_root_fsolver_free(solver);

    return r;
}

Logger& GreensFunction3DAbsSym::log_(
        Logger::get_logger("GreensFunction3DAbsSym"));
 </xmp> 
<h3> GreensFunction3D.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <sstream>
#include <boost/format.hpp>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_roots.h>

#include "freeFunctions.hpp"
#include "GreensFunction3D.hpp"

GreensFunction3D::~GreensFunction3D()
{
    ; // do nothing
}
    
Real GreensFunction3D::drawTime(Real rnd) const
{
    return INFINITY;
}

Real GreensFunction3D::p_r(Real r, Real t) const
{
    const Real D( getD() );
    const Real Dt( D * t );
    const Real Dt4( 4.0 * Dt );
    const Real rr04( 4.0 * r * r0 );

    const Real mrr0sq_over_4Dt( - gsl_pow_2( r + r0 ) / Dt4 );

    const Real num1( expm1( mrr0sq_over_4Dt ) );
    const Real num2( expm1( mrr0sq_over_4Dt + rr04 / Dt4 ) );

    const Real den( rr04 * sqrt( M_PI * M_PI * M_PI * Dt ) );

    const Real jacobian( 2.0 * r * r * M_PI );

    return jacobian * ( - num1 + num2 ) / den;
}

Real GreensFunction3D::ip_r(Real r, Real t) const
{
    const Real D( getD() );
    const Real Dt4( 4.0 * D * t );
    const Real Dt4r( 1.0 / Dt4 );
    const Real sqrtDt4( sqrt( Dt4 ) );
    const Real sqrtDt4r( 1.0 / sqrtDt4 );

    const Real num1a( exp( - gsl_pow_2( r - r0 ) * Dt4r ) );
    const Real num1b( exp( - gsl_pow_2( r + r0 ) * Dt4r ) );
    const Real den1( r0 * sqrt( M_PI ) );

    const Real term1( sqrtDt4 * ( - num1a + num1b ) / den1 );

    const Real term2( erf( ( r - r0 ) * sqrtDt4r ) );
    const Real term3( erf( ( r + r0 ) * sqrtDt4r ) );

    return ( term1 + term2 + term3 ) * .5;
}
    
Real GreensFunction3D::p_theta(Real theta, Real r, Real t) const
{
    return p_theta_free( theta, r, r0, t, getD() );
}

Real GreensFunction3D::ip_theta(Real theta, Real r, Real t) const
{
    return ip_theta_free( theta, r, r0, t, getD() );
}

struct ip_r_params
{ 
    GreensFunction3D const* const gf;
    const Real t;
    const Real value;
};

static Real ip_r_F(Real r, ip_r_params const* params )
{
    return params->gf->ip_r(r, params->t) - params->value;
}

Real GreensFunction3D::drawR(Real rnd, Real t) const
{
    // input parameter range checks.
    if ( !(rnd <= 1.0 && rnd >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "rnd <= 1.0 && rnd >= 0.0 : rnd=%g" ) % rnd ).str() );
    }

    if ( !(r0 >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "r0 >= 0.0 : r0=%g" ) % r0 ).str() );
    }

    if ( !(t >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "t >= 0.0 : t=%g" ) % t ).str() );
    }


    // t == 0 means no move.
    if( t == 0.0 )
    {
        return r0;
    }

    ip_r_params params = { this, t, rnd };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>( &ip_r_F ),
            &params 
        };

    const Real r_range( this->H * sqrt( 6.0 * getD() * t ) );

    const Real low_r( std::max( r0 - r_range, 0.0 ) );
    const Real max_r( r0 + r_range );


    if( GSL_FN_EVAL( &F, low_r ) >= 0.0 )
    {
        return low_r;
    }

    if( GSL_FN_EVAL( &F, max_r ) <= 0.0 )
    {
        return max_r;
    }

    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    gsl_root_fsolver_set( solver, &F, low_r, max_r );

    const unsigned int maxIter( 100 );

    unsigned int i( 0 );
    while( true )
    {
        gsl_root_fsolver_iterate( solver );
        const Real low( gsl_root_fsolver_x_lower( solver ) );
        const Real high( gsl_root_fsolver_x_upper( solver ) );
        const int status( gsl_root_test_interval( low, high, 1e-15, 
                                                  this->TOLERANCE ) );

        if( status == GSL_CONTINUE )
        {
            if( i >= maxIter )
            {
                gsl_root_fsolver_free( solver );
                throw std::runtime_error("drawR: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real r( gsl_root_fsolver_root( solver ) );
    gsl_root_fsolver_free( solver );
    
    return r;
}

struct ip_theta_params
{ 
    GreensFunction3D const* const gf;
    const Real r;
    const Real t;
    const Real value;
};

static Real ip_theta_F(Real theta, ip_theta_params const* params)
{
    return params->gf->ip_theta(theta, params->r, params->t) - params->value;
}

Real GreensFunction3D::drawTheta(Real rnd, Real r, Real t) const
{
    // input parameter range checks.
    if ( !(rnd <= 1.0 && rnd >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "rnd <= 1.0 && rnd >= 0.0 : rnd=%g" ) % rnd ).str() );
    }

    if ( !(r >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "r >= 0.0 : r=%g" ) % r ).str() );
    }

    if ( !(r0 >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "r0 >= 0.0 : r0=%g" ) % r0 ).str() );
    }

    if ( !(t >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "t >= 0.0 : t=%g" ) % t ).str() );
    }


    // t == 0 means no move.
    if( t == 0.0 )
    {
        return 0.0;
    }

    const Real ip_theta_pi( ip_theta( M_PI, r, t ) );

    ip_theta_params params = { this, r, t, rnd * ip_theta_pi };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>( &ip_theta_F ),
            &params 
        };

    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    gsl_root_fsolver_set( solver, &F, 0.0,
                          M_PI + std::numeric_limits<Real>::epsilon() );

    const unsigned int maxIter( 100 );

    unsigned int i( 0 );
    while( true )
    {
        gsl_root_fsolver_iterate( solver );
        const Real low( gsl_root_fsolver_x_lower( solver ) );
        const Real high( gsl_root_fsolver_x_upper( solver ) );
        const int status( gsl_root_test_interval( low, high, 1e-15, 
                                                  this->TOLERANCE ) );

        if( status == GSL_CONTINUE )
        {
            if( i >= maxIter )
            {
                gsl_root_fsolver_free( solver );
                throw std::runtime_error("drawTheta: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real theta( gsl_root_fsolver_root( solver ) );
    gsl_root_fsolver_free( solver );
    

    return theta;
}


std::string GreensFunction3D::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << std::endl;
    return ss.str();
}

Logger& GreensFunction3D::log_(
    Logger::get_logger("GreensFunction3D"));

 </xmp> 
<h3> GreensFunction3DRadAbsBase.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "GreensFunction3DRadAbsBase.hpp"

GreensFunction3DRadAbsBase::~GreensFunction3DRadAbsBase()
{
}
 </xmp> 
<h3> GreensFunction3DRadAbs.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "compat.h"

#include <stdexcept>
#include <vector>
#include <sstream>
#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <boost/tuple/tuple.hpp>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_legendre.h>
#include <gsl/gsl_sf_bessel.h>
#include <gsl/gsl_sf_lambert.h>
#include <gsl/gsl_integration.h>

#include "factorial.hpp"
#include "funcSum.hpp"
#include "findRoot.hpp"
#include "freeFunctions.hpp"
#include "SphericalBesselGenerator.hpp"
#include "GreensFunction3DRadAbs.hpp"

const Real GreensFunction3DRadAbs::TOLERANCE;
const Real GreensFunction3DRadAbs::MIN_T_FACTOR;
const unsigned int GreensFunction3DRadAbs::MAX_ORDER;
const unsigned int GreensFunction3DRadAbs::MAX_ALPHA_SEQ;


GreensFunction3DRadAbs::GreensFunction3DRadAbs(
    Real D, Real kf, Real r0, Real Sigma, Real a)
    : GreensFunction3DRadAbsBase(D, kf, r0, Sigma),
      h(kf / (4.0 * M_PI * Sigma * Sigma * D)),
      hsigma_p_1(1.0 + h * Sigma),
      a(a)
{
    const Real sigma(this->getSigma());

    if (a < sigma)
    {
        throw std::invalid_argument((boost::format("a >= sigma : a=%g, sigma=%g") % a % sigma).str());
    }
    clearAlphaTable();
}

GreensFunction3DRadAbs::~GreensFunction3DRadAbs()
{
    ; // do nothing
}

//
// Alpha-related methods
//

void GreensFunction3DRadAbs::clearAlphaTable() const
{
    std::for_each(this->alphaTable.begin(), this->alphaTable.end(),
                   boost::mem_fn(&RealVector::clear));
    this->alphaOffsetTable[0] = 0;
    std::fill(this->alphaOffsetTable.begin()+1, this->alphaOffsetTable.end(),
               -1);

}


Real GreensFunction3DRadAbs::f_alpha0(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());

    const Real alpha_a_m_sigma(alpha * (a - sigma));
    const Real hsigma_p_1(this->hsigma_p_1);

    Real sin_alpha_a_m_sigma;
    Real cos_alpha_a_m_sigma;
    sincos(alpha_a_m_sigma, &sin_alpha_a_m_sigma, &cos_alpha_a_m_sigma);

    const Real term1(alpha * sigma * cos_alpha_a_m_sigma);
    const Real term2(hsigma_p_1 * sin_alpha_a_m_sigma);

    const Real result(term1 + term2);

    return result;
}


Real 
GreensFunction3DRadAbs::f_alpha0_aux(Real alpha) const
{
    const Real a(this->geta());
    const Real sigma(this->getSigma());

    const Real term1((a - sigma) * alpha);

    const Real angle(this->hsigma_p_1 / (sigma * alpha));
    const Real term2(std::atan(angle));

    const Real result(term1 - term2);

    return result;
}

struct f_alpha0_aux_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real value;
};

static Real f_alpha0_aux_F(Real alpha, f_alpha0_aux_params const* params)
{
    return params->gf->f_alpha0_aux(alpha) - params->value;
}


Real GreensFunction3DRadAbs::alpha0_i(Integer i) const
{
    if (!(i >= 0))
    {
        throw std::out_of_range((boost::format("i >= 0 : i=%g") % i).str());
    }


    const Real a(this->geta());
    const Real sigma(this->getSigma());


    const Real target(i * M_PI + M_PI_2);
    f_alpha0_aux_params params = { this, target };


    gsl_function F = 
        { reinterpret_cast<typeof(F.function)>(&f_alpha0_aux_F), &params };


    // We know the range of the solution from - Pi/2 <= atan <= Pi/2.
    const Real interval(M_PI / (a - sigma));
    Real low(i * interval + std::numeric_limits<Real>::epsilon());
    Real high((i+1) * interval);

    //assert(GSL_FN_EVAL(&F, low) * GSL_FN_EVAL(&F, high) < 0.0);

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int j(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);

        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        const int status(gsl_root_test_interval(low, high, 0.0, 1e-15));

        if (status == GSL_CONTINUE)
        {
            if (j >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("alpha0_i: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++j;
    }

    const Real alpha(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);
  
    return alpha;
}


void
GreensFunction3DRadAbs::updateAlphaTable0(const Real t) const
{
    RealVector& alphaTable_0(this->getAlphaTable(0));
    alphaTable_0.clear();
    alphaTable_0.reserve(MAX_ALPHA_SEQ);

    const Real alpha0_0(this->alpha0_i(0));
    alphaTable_0.push_back(alpha0_0);

    const Real Dt(this->getD() * t);

//    const Real alpha_cutoff(sqrt((- log(TOLERANCE * 1e-2) / Dt)
//                                 + alpha0_0 * alpha0_0));
    const Real alpha_cutoff(sqrt((- log(TOLERANCE * 1e-3) / Dt)));

    unsigned int i(1);
    for (;;)
    {
        const Real alpha0_i(this->alpha0_i(i));
        alphaTable_0.push_back(alpha0_i);

        if (alpha0_i > alpha_cutoff && i >= 10) // make at least 10 terms
        {
            break;
        }

        ++i;

        if (i >= MAX_ALPHA_SEQ)
        {
            break;
        }
    }
}

Real GreensFunction3DRadAbs::f_alpha(Real alpha, Integer n) const
{
    const Real a(this->geta());
    const Real sigma(getSigma());
    const Real aAlpha(a * alpha);
    const Real sigmaAlpha(getSigma() * alpha);
    const Real hSigma(geth() * getSigma());
    const Real realn(static_cast<Real>(n));

    const Real hSigma_m_n(hSigma - realn);


    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());

    const Real js1(s.j(n,   sigmaAlpha));
    const Real ys1(s.y(n,   sigmaAlpha));
    const Real js2(s.j(n+1, sigmaAlpha));
    const Real ys2(s.y(n+1, sigmaAlpha));
    const Real ja( s.j(n,   aAlpha));
    const Real ya( s.y(n,   aAlpha));

    const Real term1((hSigma_m_n * js1 + sigmaAlpha * js2) * ya);
    const Real term2((hSigma_m_n * ys1 + sigmaAlpha * ys2) * ja);

    const Real factor(2.0 * alpha * sqrt(a * sigma) * M_1_PI);

    const Real result((term1 - term2) * factor);
    
    return result;
}

static inline const Real G(const unsigned int n, const unsigned int k)
{
    return factorial(n + k) * (factorial_r(k) * factorial_r(n - k));
}


static Real P(Integer n, Real x)
{
    Real result(0.0);

    Real sx2(1.0);
    Integer term1(1);

    const Real x2sq_r(1.0 / gsl_pow_2(x + x));
    const unsigned int maxm(n / 2);
    for(unsigned int m(0); m <= maxm; ++m)
    {
        const Real value(term1 * sx2 * G(n, 2 * m));
        result += value;

        term1 = - term1;
        sx2 *= x2sq_r;
    }

    return result;
}

static std::pair<Real, Real> P2(Integer n, Real x)
{
    Real result(0.0);
    Real resultp(0.0);

    Real sx2(1.0);
    Integer term1(1);

    const Real x2sq_r(1.0 / gsl_pow_2(x + x));
    const unsigned int np1(n + 1);
    const unsigned int maxm(n / 2);
    for(unsigned int m(0); m <= maxm; ++m)
    {
        const Real sx2p(term1 * sx2);
        const unsigned int m2(2 * m);
        const Real value(sx2p * G(n, m2));
        result += value;

        const Real valuep(sx2p * G(np1, m2));
        resultp += valuep;

        term1 = - term1;
        sx2 *= x2sq_r;
    }

    if (n % 2)
    {
        resultp += term1 * sx2 * G(np1, np1);
    }


    return std::make_pair(result, resultp);
}


static Real Q(Integer n, Real x)
{
    Real result(0.0);

    Real sx2(1.0 / (x + x));
    Integer term1(1);

    const Real x2sq(sx2 * sx2);
    const unsigned int maxm((n+1)/2); // sum_(0)^((n-1)/2)
    for(unsigned int m(0); m < maxm; ++m)
    {
        const Real value(term1 * sx2 * G(n, 2 * m + 1));
        result += value;

        term1 = - term1;  // (-1)^m
        sx2 *= x2sq;
    }

    return result;
}

static std::pair<Real, Real> Q2(Integer n, Real x)
{
    Real result(0.0);
    Real resultp(0.0);

    Real sx2(1.0 / (x + x));
    Integer term1(1);  // (-1)^m

    const Real x2sq(sx2 * sx2);
    const unsigned int np1(n + 1);
    const unsigned int maxm((n+1)/2); // sum_(0)^((n-1)/2)
    for(unsigned int m(0); m < maxm; ++m)
    {
        const Real sx2p(term1 * sx2);
        const unsigned int m2p1(2 * m + 1);
        const Real value(sx2p * G(n, m2p1));
        result += value;

        const Real valuep(sx2p * G(np1, m2p1));
        resultp += valuep;

        term1 = - term1; // (-1)^m
        sx2 *= x2sq;
    } 


    if (!(n % 2))
    {
        resultp += term1 * sx2 * G(np1, np1);
    }


    return std::make_pair(result, resultp);
}


Real GreensFunction3DRadAbs::f_alpha_aux(Real alpha, Integer n) const
{
    if (alpha == 0.0)
    {
        return -1.0;
    }

    const Real a(geta());
    const Real sigma(getSigma());

    const Real aAlpha(a * alpha);
    const Real sigmaAlpha(sigma * alpha);

    const Real n_m_hSigma(n - h * sigma);

    /*(a - s) u - 
      ArcTan[(P[n, a u] ((-n + h s) P[n, s u] + s u Q[1 + n, s u]) -
               Q[n, a u] (s u P[1 + n, s u] + (n - h s) Q[n, s u]))/
             (Q[n, a u] ((-n + h s) P[n, s u] + s u Q[1 + n, s u]) + 
               P[n, a u] (s u P[1 + n, s u] + (n - h s) Q[n, s u]))]
    */

    const Real Pa(P(n, aAlpha));
    const Real Qa(Q(n, aAlpha));

    Real Ps;
    Real Psp;
    boost::tie(Ps, Psp) = P2(n, sigmaAlpha);

    Real Qs;
    Real Qsp;
    boost::tie(Qs, Qsp) = Q2(n, sigmaAlpha);

    const Real n_m_hSigmaPs(n_m_hSigma * Ps);
    const Real n_m_hSigmaQs(n_m_hSigma * Qs);
    const Real sigmaAlphaPsp(sigmaAlpha * Psp);
    const Real sigmaAlphaQsp(sigmaAlpha * Qsp);

    const Real Qa_Pa(Qa / Pa);

    const Real A(sigmaAlphaQsp - n_m_hSigmaPs);
    const Real B(sigmaAlphaPsp + n_m_hSigmaQs);

    // this form, dividing all terms by Pa, prevents overflow.
    const Real angle((A - Qa_Pa * B) / (Qa_Pa * A + B));

    const Real term1((a - sigma) * alpha);
    const Real term2(std::atan(angle));

    const Real result(term1 - term2);

    return result;
}

struct f_alpha_aux_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Integer n;
    const Real value;
};

static Real f_alpha_aux_F(Real alpha, f_alpha_aux_params const* params)
{
    return params->gf->f_alpha_aux(alpha, params->n) - params->value;
}

Real 
GreensFunction3DRadAbs::alpha_i(Integer i, Integer n, 
                                        gsl_root_fsolver* solver) const
{
    const Real sigma(this->getSigma());
    const Real a(this->geta());

    const Real target(M_PI * i + M_PI_2);

    const Real factor(1.0 / (a - sigma));
    Real low((target - M_PI_2) * factor);
    Real high((target + M_PI_2) * factor);

    f_alpha_aux_params params = { this, n, target };

    gsl_function F = 
        { reinterpret_cast<typeof(F.function)>(&f_alpha_aux_F), &params };

    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);
    unsigned int k(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        
        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        const int status(gsl_root_test_interval(low, high, 1e-6, 1e-15));
        
        if (status == GSL_CONTINUE)
        {
            if (k >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("alpha_i: failed to converge");
            }
        }
        else
        {
            break;
        }
        
        ++k;
    }
    
    const Real alpha(gsl_root_fsolver_root(solver));

    return alpha;
}


unsigned int
GreensFunction3DRadAbs::alphaOffset(unsigned int n) const
{
    if (this->alphaOffsetTable[n] >= 0)
    {
        return this->alphaOffsetTable[n];
    }

    const Real sigma(this->getSigma());
    const Real a(this->geta());

    assert(this->alphaOffsetTable.size() >= n);
    unsigned int offset(this->alphaOffsetTable[n-1]);

    const Real factor(1.0 / (a - sigma));

    Real target(offset * M_PI + M_PI_2);
    // We know the range of the solution from - Pi/2 <= atan <= Pi/2.
    const Real alphaMid(target * factor);
    const Real alphaHalfRange(M_PI_2 * factor);
    Real low(alphaMid - alphaHalfRange * (1.0 - 1e-3)); // avoid zero.
    Real high(alphaMid + alphaHalfRange);


    // Here we find the interval where the first positive root is in.
    // We find the first pair of alpha
    // (Pi * offset + Pi/2) +- Pi/2 / (a - sigma)
    // where the values of f_alpha() straddle.
    // The assumption is the interval between roots is not much
    // smaller than Pi / (a - sigma).


    Real lowvalue(f_alpha(low,n));
    Real highvalue(f_alpha(high,n));

    for (;;) // this can be much faster if better initial guess is given.
    {

        if (lowvalue * highvalue < 0) // low and high straddle?
        {
            break;
        }

        ++offset;
        target = M_PI * offset + M_PI_2;
        low = (target - M_PI_2) * factor;
        high = (target + M_PI_2) * factor;

        lowvalue = highvalue;
        highvalue = f_alpha(high, n);
    }

    this->alphaOffsetTable[n] = offset;

    return offset;
}


void
GreensFunction3DRadAbs::updateAlphaTable(const unsigned int n,
                                                  const Real t) const
{
    if (!(n >= 0 && n <= this->MAX_ORDER))
    {
        throw std::range_error((boost::format("n >= 0 && n <= this->MAX_ORDER : n=%g, this->MAX_ORDER=%g") % n % this->MAX_ORDER).str());
    }


    if (n == 0)
    {
        this->updateAlphaTable0(t);
        return;
    }

    const unsigned int offset(alphaOffset(n));

    RealVector& alphaTable_n(this->getAlphaTable(n));
    alphaTable_n.clear();
    alphaTable_n.reserve(MAX_ALPHA_SEQ);

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));

    const Real alphan_0(alpha_i(offset, n, solver));
    const Real alphan_0_sq(alphan_0 * alphan_0);

    alphaTable_n.push_back(alphan_0);

    const Real Dt(this->getD() * t);

    const Real threshold(this->TOLERANCE * 1e-2 * 
                          alphan_0_sq * exp(- Dt * alphan_0_sq));
   
    const unsigned int end(offset + MAX_ALPHA_SEQ);
    unsigned int i(offset + 1);
    for (;;)
    {
        const Real alpha_i(this->alpha_i(i, n, solver));

        alphaTable_n.push_back(alpha_i);

        // cutoff
        const Real alpha_i_sq(alpha_i * alpha_i);
        if (alpha_i_sq * exp(- Dt * alpha_i_sq)  < threshold)
        {
            break;
        }


        ++i;

        if (i >= end)
        {
            log_.info("alphaTable (%d): didn't converge. t = %g, %s",
                       n, t, dump().c_str());
            break;
        }
    }

    gsl_root_fsolver_free(solver);
}




Real 
GreensFunction3DRadAbs::p_0_i(Real alpha, Real r) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    Real num1;
    {
        const Real angle_r(alpha * (r - sigma));
        Real sin_r;
        Real cos_r;
        sincos(angle_r, &sin_r, &cos_r);
        num1 = alpha * sigma * cos_r + hsigma_p_1 * sin_r ;
    }

    const Real num2(num_r0(alpha));

    const Real den(2 * M_PI * r * r0 * 
                    ((a - sigma) * sigmasq * alphasq +
                      hsigma_p_1 * (a + a * h * sigma - h * sigmasq)));

    const Real result(num1 * num2 / den);

    return result;
}


Real 
GreensFunction3DRadAbs::p_survival_i(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real angle_a(alpha * (a - sigma));
    const Real cos_a(cos(angle_a));

    const Real num1(h * sigmasq * hsigma_p_1 
                     - a * (hsigma_p_1 * hsigma_p_1
                             + sigmasq * alphasq) * cos_a);

    const Real num2(num_r0(alpha));

    const Real den(r0 * hsigma_p_1 * alpha * 
                    (- hsigma_p_1 *
                      (a + a * h * sigma - h * sigmasq) 
                      + (sigma - a) * sigmasq * alphasq));

    const Real result(- 2.0 * num1 * num2 / den);

    return result;
}


Real 
GreensFunction3DRadAbs::dp_survival_i(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real angle_a(alpha * (a - sigma));
    const Real cos_a(cos(angle_a));

    const Real num1(alpha * (h * sigmasq * hsigma_p_1 
                               - (a * (hsigma_p_1 * hsigma_p_1 
                                         + sigmasq * alphasq)) * cos_a));

    const Real num2(num_r0(alpha));

    const Real den(r0 * hsigma_p_1 * 
                    (- hsigma_p_1 * (a + a * h * sigma - h * sigmasq))
                    + (sigma - a) * sigmasq * alphasq);

    const Real result(2.0 * getD() * num1 * num2 / den);

    return result;
}


Real 
GreensFunction3DRadAbs::leavea_i(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real D(getD());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real angle_a(alpha * (a - sigma));
    const Real cos_a(cos(angle_a));

    const Real num1(alpha * (hsigma_p_1 * hsigma_p_1 + sigmasq * alphasq)
                     * cos_a);

    const Real num2(num_r0(alpha));
    
    const Real den(2 * a * M_PI * r0 * hsigma_p_1 *
                    (hsigma_p_1 * (a + a * h * sigma - h * sigmasq)
                      + (a - sigma) * sigmasq * alphasq));

    const Real result(D * num1 * num2 / den);

    return result;
}

Real GreensFunction3DRadAbs::leaves_i(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real D(getD());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real num(h * alpha * num_r0(alpha));
                      
    const Real den(2 * M_PI * r0 *
                    ((a - sigma) * sigmasq * alphasq +
                      hsigma_p_1 * (a + a * h * sigma - h * sigmasq)));

    const Real result(- D * num / den);
        
    return result;
}


Real GreensFunction3DRadAbs::p_leavea_i(Real alpha,
                                                Real pleave_factor) const
{
    const Real a(geta());
    const Real sigma(getSigma());

    const Real hsigma_p_1(this->hsigma_p_1);
    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real angle_a(alpha * (a - sigma));
    const Real cos_a(cos(angle_a));

    const Real num1((hsigma_p_1 * hsigma_p_1 + sigmasq * alphasq) * cos_a);

    const Real result(- 2.0 * a * num1 * pleave_factor / hsigma_p_1);

    return result;
}


Real 
GreensFunction3DRadAbs::p_leaves_i(Real alpha,
                                           Real pleave_factor) const
{
    const Real sigma(getSigma());
    const Real h(geth());
 
    const Real num(h * sigma * sigma);
                      
    const Real result(2.0 * num * pleave_factor);
        
    return result;
}

Real 
GreensFunction3DRadAbs::p_survival_den(Real alpha) const
{
    const Real a(geta());
    const Real sigma(getSigma());
    const Real h(geth());
    const Real hsigma_p_1(this->hsigma_p_1);
    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real den(r0 * alpha *
                    ((a - sigma) * sigmasq * alphasq +
                      hsigma_p_1 * (a + a * h * sigma - h * sigmasq)));
    
    return den;
}



Real GreensFunction3DRadAbs::num_r0(Real alpha) const
{
    const Real sigma(getSigma());
    const Real angle_r0(alpha * (r0 - sigma));

    Real sin_r0;
    Real cos_r0;
    sincos(angle_r0, &sin_r0, &cos_r0);

    const Real hsigma_p_1(this->hsigma_p_1);
    const Real result(alpha * sigma * cos_r0 + hsigma_p_1 * sin_r0);

    return result;
}


Real GreensFunction3DRadAbs::pleaveFactor(Real alpha) const
{
    return num_r0(alpha) / p_survival_den(alpha);
}


Real
GreensFunction3DRadAbs::p_int_r_i(Real r, Real alpha,
                                          Real num_r0) const
{
    const Real sigma(getSigma());

    const Real angle_r(alpha * (r - sigma));
    Real sin_r;
    Real cos_r;
    sincos(angle_r, &sin_r, &cos_r);  // do sincos here; latency. 

    const Real h(geth());
    const Real hsigma_p_1(this->hsigma_p_1);

    const Real sigmasq(sigma * sigma);
    const Real alphasq(alpha * alpha);

    const Real hsigma(h * sigma);

    const Real num1(alpha * (hsigma * sigma - hsigma * r * cos_r 
                               - (r - sigma) * cos_r) 
                     + (hsigma_p_1 + r * sigma * alphasq) * sin_r);

    const Real num2(num_r0);

    const Real den(r0 * alphasq * 
                    ((a - sigma) * sigmasq * alphasq +
                      hsigma_p_1 * (a + a * h * sigma - h * sigmasq)));

    const Real result(2 * num1 * num2 / den);

    return result;
}


void 
GreensFunction3DRadAbs::createPsurvTable(RealVector& table) const
{
    const RealVector& alphaTable_0(this->getAlphaTable(0));

    table.clear();
    table.reserve(alphaTable_0.size());

    std::transform(alphaTable_0.begin(), alphaTable_0.end(),
                    std::back_inserter(table),
                    boost::bind(&GreensFunction3DRadAbs::p_survival_i,
                                 this, _1));
}


void 
GreensFunction3DRadAbs::createNum_r0Table(RealVector& table) const
{
    const RealVector& alphaTable_0(this->alphaTable[0]);

    table.clear();
    table.reserve(alphaTable_0.size());

    std::transform(alphaTable_0.begin(), alphaTable_0.end(),
                    std::back_inserter(table),
                    boost::bind(&GreensFunction3DRadAbs::num_r0,
                                 this, _1));
}

void 
GreensFunction3DRadAbs::createPleaveFactorTable(RealVector& table) const
{
    const RealVector& alphaTable_0(this->alphaTable[0]);

    table.clear();
    table.reserve(alphaTable_0.size());

    std::transform(alphaTable_0.begin(), alphaTable_0.end(),
                    std::back_inserter(table),
                    boost::bind(&GreensFunction3DRadAbs::pleaveFactor,
                                 this, _1));
}


void 
GreensFunction3DRadAbs::createPleavesTable(RealVector& table,
                                                   RealVector const& pleaveFactorTable) const
{
    const RealVector& alphaTable_0(this->alphaTable[0]);

    assert(pleaveFactorTable.size() >= alphaTable_0.size());

    table.clear();
    table.reserve(alphaTable_0.size());

    for(unsigned int i(0); i < alphaTable_0.size(); ++i)
    {
        const Real alpha(alphaTable_0[i]);
        table.push_back(p_leaves_i(alpha, pleaveFactorTable[i]));
    }
}

void 
GreensFunction3DRadAbs::createPleaveaTable(RealVector& table,
                                                   RealVector const& pleaveFactorTable) const
{
    const RealVector& alphaTable_0(this->alphaTable[0]);

    assert(pleaveFactorTable.size() >= alphaTable_0.size());

    table.clear();
    table.reserve(alphaTable_0.size());

    for(unsigned int i(0); i < alphaTable_0.size(); ++i)
    {
        const Real alpha(alphaTable_0[i]);
        table.push_back(p_leavea_i(alpha, pleaveFactorTable[i]));
    }
}


Real 
GreensFunction3DRadAbs::p_0_i_exp(unsigned int i, Real t, Real r) const
{
    const Real alpha(this->getAlpha0(i));
    return std::exp(- getD() * t * alpha * alpha) * p_0_i(alpha, r);
}


Real 
GreensFunction3DRadAbs::p_survival_i_exp(unsigned int i, Real t) const
{
    const Real alpha(this->getAlpha0(i));
    return p_survival_i_alpha(alpha, t);
}

Real 
GreensFunction3DRadAbs::p_survival_i_alpha(Real alpha, Real t) const
{
    return std::exp(- getD() * t * alpha * alpha) * 
        p_survival_i(alpha);
}

Real 
GreensFunction3DRadAbs::p_survival_2i_exp(unsigned int i,
                                                  Real t) const
{
    const Real Dt(getD() * t);
    const Real alpha0(this->getAlpha0(2 * i));
    const Real p0(std::exp(- Dt * alpha0 * alpha0) * 
                   p_survival_i(alpha0));

    const Real alpha1(this->getAlpha0(2 * i + 1));
    const Real p1(std::exp(- Dt * alpha1 * alpha1) * 
                   p_survival_i(alpha1));

    return p0 + p1;
}

Real 
GreensFunction3DRadAbs::p_survival_i_exp_table(unsigned int i,
                                                       Real t,
                                                       RealVector const& table) const
{
    const Real alpha(this->getAlpha0(i));
    return std::exp(- getD() * t * alpha * alpha) * table[i];
}

Real 
GreensFunction3DRadAbs::p_leave_i_exp_table(unsigned int i, Real t, RealVector const& table) const
{
    const Real alpha(getAlpha0(i));
    return expm1(- getD() * t * alpha * alpha) * table[i];
}


Real 
GreensFunction3DRadAbs::dp_survival_i_exp(unsigned int i, Real t) const
{
    const Real alpha(this->getAlpha0(i));
    return std::exp(- getD() * t * alpha * alpha) * 
        dp_survival_i(alpha);
}

Real 
GreensFunction3DRadAbs::leavea_i_exp(unsigned int i, Real t) const
{
    const Real alpha(this->getAlpha0(i));
    return std::exp(- getD() * t * alpha * alpha) * leavea_i(alpha);
}

Real 
GreensFunction3DRadAbs::leaves_i_exp(unsigned int i, Real t) const
{
    const Real alpha(this->getAlpha0(i));

    return std::exp(- getD() * t * alpha * alpha) * leaves_i(alpha);
}

Real 
GreensFunction3DRadAbs::p_leavea_i_exp(unsigned int i,
                                               Real t) const
{
    const Real alpha(this->getAlpha0(i));
    const Real num_r0(this->num_r0(alpha)); 
    const Real den(this->p_survival_den(alpha)); 
    return exp(- getD() * t * alpha * alpha) * 
        p_leavea_i(alpha, num_r0 / den);
}

Real 
GreensFunction3DRadAbs::p_leaves_i_exp(unsigned int i, Real t) const
{
    const Real alpha(this->getAlpha0(i));
    const Real num_r0(this->num_r0(alpha)); 
    const Real den(this->p_survival_den(alpha)); 
    return exp(- getD() * t * alpha * alpha) * 
        p_leaves_i(alpha, num_r0 / den);
}

Real 
GreensFunction3DRadAbs::p_int_r_i_exp(unsigned int i,
                                              Real t,
                                              Real r) const
{
    const Real alpha(this->getAlpha0(i));

    return std::exp(- getD() * t * alpha * alpha) * 
        p_int_r_i(r, alpha, num_r0(alpha));
}

Real 
GreensFunction3DRadAbs::p_int_r_i_exp_table(unsigned int i,
                                                    Real t,
                                                    Real r,
                                                    RealVector& num_r0Table) const
{
    const Real alpha(this->getAlpha0(i));
    return std::exp(- getD() * t * alpha * alpha) * 
        p_int_r_i(r, alpha, num_r0(alpha));//num_r0Table[i]);
}

Real 
GreensFunction3DRadAbs::p_0(Real t, Real r) const
{
    const Real p(funcSum(boost::bind(&GreensFunction3DRadAbs::
                                        p_0_i_exp,
                                        this,
                                        _1, t, r),
                           this->MAX_ALPHA_SEQ));
    return p;
}


unsigned int
GreensFunction3DRadAbs::guess_maxi(Real t) const
{
    const unsigned int safety(2);

    if (t >= INFINITY)
    {
        return safety;
    }

    const Real D(this->getD());
    const Real sigma(this->getSigma());
    const Real a(this->geta());

    const Real alpha0(this->getAlpha0(0));
    const Real Dt(D * t);

    const Real thr(exp(- Dt * alpha0 * alpha0) * this->TOLERANCE * 1e-1);

    if (thr <= 0.0)
    {
        return this->MAX_ALPHA_SEQ;
    }

    const Real max_alpha(sqrt(alpha0 * alpha0 - log(thr) / Dt));

    const unsigned int 
        maxi(safety + 
              static_cast<unsigned int>(max_alpha * (a - sigma) / M_PI));

    return std::min(maxi, this->MAX_ALPHA_SEQ);
}


Real GreensFunction3DRadAbs::p_survival(Real t) const
{
    RealVector psurvTable;

    const Real p(p_survival_table(t, psurvTable));

    return p;
}

Real 
GreensFunction3DRadAbs::p_survival_table(Real t, RealVector& psurvTable) const
{
    Real p;

    const Real D(this->getD());
    const Real sigma(getSigma());
    const Real a(this->geta());

    const Real distToa(a - r0);
    const Real distTos(r0 - sigma);

    const Real H(6.0); // a fairly strict criterion for safety.
    const Real maxDist(H * sqrt(6.0 * D * t));

    if (distToa > maxDist)
    {
        if (distTos > maxDist) // far from anything; it'll survive.
        {
            p = 1.0;  
        }
        else // close only to s, ignore a
        {
            const Real sigma(this->getSigma());
            const Real kf(this->getkf());
            p = p_survival_irr(t, r0, kf, D, sigma);
        }
    }
    else
    {
        if (distTos > maxDist)  // close only to a.
        {
            p = p_survival_nocollision(t, r0, D, a);
        }
        else  // close to both boundaries.  do the normal calculation.
        {
            const unsigned int maxi(guess_maxi(t));
            
            if (psurvTable.size() < maxi + 1)
            {
                IGNORE_RETURN getAlpha0(maxi);  // this updates the table
                this->createPsurvTable(psurvTable);
            }

            p = funcSum_all(boost::bind(&GreensFunction3DRadAbs::
                                          p_survival_i_exp_table, 
                                          this,
                                          _1, t, psurvTable),
                             maxi);
        }
    }

    return p;
}

Real 
GreensFunction3DRadAbs::p_leave_table(Real t, RealVector const& table) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::p_leave_i_exp_table, 
                    this, _1, t, table),
        table.size());
}


Real GreensFunction3DRadAbs::dp_survival(Real t) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::dp_survival_i_exp, 
                    this, _1, t),
        MAX_ALPHA_SEQ);
}


Real GreensFunction3DRadAbs::leaves(Real t) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::leaves_i_exp,
                    this, _1, t),
        MAX_ALPHA_SEQ);
}

Real GreensFunction3DRadAbs::leavea(Real t) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::leavea_i_exp,
                    this, _1, t),
        MAX_ALPHA_SEQ);
}

Real GreensFunction3DRadAbs::p_leaves(Real t) const
{
    return funcSum_all(
        boost::bind(&GreensFunction3DRadAbs::p_leaves_i_exp,
                    this, _1, t),
        guess_maxi(t));
}

Real GreensFunction3DRadAbs::p_leavea(Real t) const
{
    return funcSum_all(
        boost::bind(&GreensFunction3DRadAbs::p_leavea_i_exp,
                    this, _1, t),
        guess_maxi(t));
}

Real GreensFunction3DRadAbs::p_int_r(Real r, Real t) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::p_int_r_i_exp,
                    this, _1, t, r),
        MAX_ALPHA_SEQ);
}

Real GreensFunction3DRadAbs::p_int_r_table(Real r, Real t, RealVector const& num_r0Table) const
{
    return funcSum(
        boost::bind(&GreensFunction3DRadAbs::p_int_r_i_exp_table,
                    this, _1, t, r, num_r0Table), num_r0Table.size());
}

struct p_survival_table_params
{ 
    GreensFunction3DRadAbs const* const gf;
    GreensFunction3DRadAbs::RealVector& table;
    const Real rnd;
};

Real p_survival_table_F(Real t, p_survival_table_params const* params)
{
    return params->rnd - params->gf->p_survival_table(t, params->table);
}

struct p_survival_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real rnd;
};

static Real p_survival_F(Real t, p_survival_params const* params)
{
    return params->rnd - params->gf->p_survival(t);
}

struct p_survival_2i_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real t;
};

static Real p_survival_2i_F(Real ri, p_survival_2i_params const* params)
{
    return params->gf->p_survival_2i_exp(static_cast<unsigned int>(ri),
                                         params->t);
}

struct p_survival_i_alpha_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real t;
};

static Real p_survival_i_alpha_F(Real alpha,
                                 p_survival_i_alpha_params const* params)
{
    return params->gf->p_survival_i_alpha(alpha, params->t);
}

struct p_leave_params
{ 
    GreensFunction3DRadAbs const* const gf;
    GreensFunction3DRadAbs::RealVector const& table;
    const Real rnd;
};

Real p_leave_F(Real t, p_leave_params const* params)
{
    return - params->gf->p_leave_table(t, params->table) - params->rnd;
}

struct p_int_r_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real t;
    const Real rnd;
};


static Real p_int_r_F(Real r, p_int_r_params const* params)
{
    return params->gf->p_int_r(r, params->t) - params->rnd;
}

Real GreensFunction3DRadAbs::drawTime(Real rnd) const
{
    const Real D(this->getD());
    const Real sigma(this->getSigma());
    const Real kf(this->getkf());
    const Real a(this->geta());

    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma && r0 <= a))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma && r0 <= a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
    }


    if (r0 == a || a == sigma)
    {
        return 0.0;
    }

    Real t_guess;
    Real dist;

    if (kf != 0)
    {
        dist = std::min(a - r0, r0 - sigma);
    }
    else
    {
        dist = a - r0;
    }

    t_guess = dist * dist / (6.0 * D);
    t_guess *= .1;

    const Real minT(std::min(sigma * sigma / D * this->MIN_T_FACTOR,
                               t_guess * 1e-6));

    RealVector psurvTable;

    p_survival_table_params params = { this, psurvTable, rnd };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_survival_table_F),
            &params 
        };

    Real low(t_guess);
    Real high(t_guess);

    // adjust high and low to make sure that f(low) and f(high) straddle.
    const Real value(GSL_FN_EVAL(&F, t_guess));
    if (value < 0.0)
    {
        high *= 10;
        for (;;)
        {
            const Real high_value(GSL_FN_EVAL(&F, high));
            
            if (high_value >= 0.0)
            {
                break;
            }

            if (fabs(high) >= 1e10)
            {
                throw std::runtime_error(
                    (boost::format(
                        "couldn't adjust high. F(%g) = %g; r0 = %g, %s") %
                        high % GSL_FN_EVAL(&F, high) % r0 % dump()).str());
            }

            high *= 10;
        }
    }
    else
    {
        Real low_value_prev(value);
        low *= .1;

        for (;;)
        {
            
            const Real low_value(GSL_FN_EVAL(&F, low));
            
            if (low_value <= 0.0)
            {
                break;
            }
            
            // FIXME: 
            if (fabs(low) <= minT ||
                fabs(low_value - low_value_prev) < TOLERANCE) 
            {
                log_.info("couldn't adjust low. F(%g) = %g; r0 = %g, %s",
                          low, GSL_FN_EVAL(&F, low), r0,
                          dump().c_str());
                log_.info("returning %g", low);
                return low;
            }
            low_value_prev = low_value;

            low *= .1;
        }
    }

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));

    const Real t(findRoot(F, solver, low, high, 0.0, 
                            TOLERANCE, "drawTime"));

    gsl_root_fsolver_free(solver);

    return t;
}

GreensFunction3DRadAbs::EventKind
GreensFunction3DRadAbs::drawEventType(Real rnd, Real t) const
{
    const Real D(this->getD());
    const Real sigma(this->getSigma());
    const Real kf(this->getkf());
    const Real a(this->geta());

    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma && r0 < a))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
    }

    if (!(t > 0.0))
    {
        throw std::invalid_argument((boost::format("t > 0.0 : t=%g") % t).str());
    }


    if (kf == 0)
    {
        return IV_ESCAPE;
    }
    
    // First, check if r0 is close only either to a or sigma relative
    // to Dt.  In such cases, the event type is always IV_ESCAPE or 
    // IV_REACTION, respectively. This avoids numerical instability in 
    // calculating leavea() and/or leaves().

    // Here, use a rather large threshold for safety.
    const unsigned int H(6); 
    const Real max_dist(H * sqrt(6.0 * D * t));
    const Real a_dist(a - r0);
    const Real s_dist(r0 - sigma);


    if (a_dist > max_dist)
    {
        if (s_dist < max_dist)
        {
            return IV_REACTION;
        }
    }
    else // a_dist < max_dist
    {
        if (s_dist > max_dist)
        {
            return IV_ESCAPE;
        }
    }

    const Real reaction(leaves(t) * 4.0 * M_PI * sigma * sigma);
    const Real escape(leavea(t) * 4.0 * M_PI * a * a);
    const Real value(reaction / (reaction + escape));

    if (rnd <= value)  
    {
        return IV_REACTION;   // leaves
    }
    else 
    {
        return IV_ESCAPE;     // leavea
    }
}

Real 
GreensFunction3DRadAbs::drawPleavea(gsl_function const& F,
                                            gsl_root_fsolver* solver,
                                            Real t_guess,
                                            RealVector& pleaveFactorTable,
                                            RealVector& pleaveaTable) const
{
    const Real minT(1e-12);

    Real low(t_guess);
    Real high(t_guess);

    // adjust high and low to make sure that f(low) and f(high) straddle.
    const Real value(GSL_FN_EVAL(&F, t_guess));
    if (value < 0.0)
    {
        high *= 10;
        for (;;)
        {
            const Real high_value(GSL_FN_EVAL(&F, high));
            
            if (high_value >= 0.0)
            {
                break;
            }

            if (fabs(high) >= 1e10)
            {
                throw std::runtime_error(
                    (boost::format(
                        "couldn't adjust high. Fa(%g) = %g; r0 = %g, %s") %
                        high % GSL_FN_EVAL(&F, high) % r0 % dump()).str());
            }

            log_.info("drawTime2: adjusting high: %g Fa = %g", high, high_value);
            high *= 10;
        }
    }
    else
    {
        Real low_value_prev(value);
        low *= .1;

        for (;;)
        {
            this->updateAlphaTable0(low);
            this->createPleaveFactorTable(pleaveFactorTable);
            this->createPleaveaTable(pleaveaTable, pleaveFactorTable);

            
            const Real low_value(GSL_FN_EVAL(&F, low));
            
            if (low_value <= 0.0)
            {
                break;
            }
            
            // FIXME: 
            if (fabs(low) <= minT || 
                fabs(low_value - low_value_prev) < TOLERANCE) 
            {
                log_.info("couldn't adjust low. Fa(%g) = %g; r0 = %g, %s",
                           low, GSL_FN_EVAL(&F, low), r0, dump().c_str());
                log_.info("returning %g", minT);
                return minT;
            }
            low_value_prev = low_value;

            log_.info("drawTime2: adjusting low: %g, Fa = %g", low, low_value);
            low *= .1;
        }
    }

    const Real t(findRoot(F, solver, low, high, 0.,
                            this->TOLERANCE, "drawTime2: a"));

    return t;
}


Real 
GreensFunction3DRadAbs::drawPleaves(gsl_function const& F,
                                            gsl_root_fsolver* solver,
                                            Real t_guess,
                                            RealVector& pleaveFactorTable,
                                            RealVector& pleavesTable) const
{
    const Real minT(1e-12);

    Real low(t_guess);
    Real high(t_guess);

    // adjust high and low to make sure that f(low) and f(high) straddle.
    const Real value(GSL_FN_EVAL(&F, t_guess));
    if (value < 0.0)
    {
        high *= 10;
        for (;;)
        {
            const Real high_value(GSL_FN_EVAL(&F, high));
            
            if (high_value >= 0.0)
            {
                break;
            }

            if (fabs(high) >= 1e10)
            {
                throw std::runtime_error(
                    (boost::format(
                        "couldn't adjust high. Fs(%g) = %g; r0 = %g, %s") %
                        high % GSL_FN_EVAL(&F, high) % r0 % dump()).str());
            }

            log_.info("drawTime2: adjusting high: %g Fs = %g", 
                      high, high_value);
            high *= 10;
        }
    }
    else
    {
        Real low_value_prev(value);
        low *= .1;

        for (;;)
        {
            this->updateAlphaTable0(low);
            this->createPleaveFactorTable(pleaveFactorTable);
            this->createPleavesTable(pleavesTable, pleaveFactorTable);
            
            const Real low_value(GSL_FN_EVAL(&F, low));
            
            if (low_value <= 0.0)
            {
                break;
            }
            
            // FIXME: 
            if (fabs(low) <= minT)//|| 
//                fabs(low_value - low_value_prev) < TOLERANCE) 
            {
                log_.info("couldn't adjust low.  returning minT (=%g);"
                          "Fs(%g) = %g; r0 = %g, %s",
                          minT, low, GSL_FN_EVAL(&F, low), r0, dump().c_str());
                return minT;
            }
            low_value_prev = low_value;

            log_.info("drawTime2: adjusting low: %g, Fs = %g", low, low_value);
            low *= .1;
        }
    }

    const Real t(findRoot(F, solver, low, high, 0., this->TOLERANCE,
                            "drawTime2: s"));

    return t;
}




Real GreensFunction3DRadAbs::drawR(Real rnd, Real t) const
{
    const Real D(this->getD());
    const Real sigma(this->getSigma());
    const Real a(this->geta());

    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma && r0 < a))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
    }


    if (t == 0.0)
    {
        return r0;
    }

    const Real psurv(p_survival(t));

//    RealVector num_r0Table;
//    createNum_r0Table(num_r0Table, r0);

    p_int_r_params params = { this, t, /*num_r0Table,*/ rnd * psurv };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_int_r_F),
            &params 
        };


    // adjust low and high starting from r0.
    // this is necessary to avoid root finding in the long tails where
    // numerics can be unstable.

    Real low(r0);
    Real high(r0);

    const Real sqrt6Dt(sqrt(6.0 * D * t));
    if (GSL_FN_EVAL(&F, r0) < 0.0)
    {
        // low = r0
        unsigned int H(3);

        for (;;)
        {
            high = r0 + H * sqrt6Dt;
            if (high > a)
            {
                if (GSL_FN_EVAL(&F, a) < 0.0)
                {
                    log_.info("drawR: p_int_r(a) < 0.0. returning a");
                    return a;
                }

                high = a;
                break;
            }

            const Real value(GSL_FN_EVAL(&F, high));
            if (value > 0.0)
            {
                break;
            }

            ++H;
        }

    }
    else
    {
        // high = r0
        unsigned int H(3);

        for (;;)
        {
            low = r0 - H * sqrt6Dt;
            if (low < sigma)
            {
                if (GSL_FN_EVAL(&F, sigma) > 0.0)
                {
                    log_.info("drawR: p_int_r(sigma) > 0.0. returning sigma");
                    return sigma;
                }

                low = sigma;
                break;
            }

            const Real value(GSL_FN_EVAL(&F, low));
            if (value < 0.0)
            {
                break;
            }

            ++H;
        }
    }


    // root finding by iteration.

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        const int status(gsl_root_test_interval(low, high, 1e-15,
                                                  this->TOLERANCE));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawR: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real r(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);

    return r;
}




Real GreensFunction3DRadAbs::p_n_alpha(unsigned int i, unsigned int n,
                                               Real r, Real t) const
{
    const Real sigma(this->getSigma());
    const Real h(this->geth());
    const Real a(this->geta());

    const Real mDt(- this->getD() * t);

    const Real alpha(this->getAlpha(n, i));
    const Real alphasq(alpha * alpha);

    const Real aAlpha(a * alpha);
    const Real sigmaAlpha(sigma * alpha);
    const Real hSigma(geth() * getSigma());
    const Real realn(static_cast<Real>(n));
    const Real hSigma_m_n(hSigma - realn);

    const Real term1(alphasq * alphasq * exp(mDt * alphasq));


    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());

    const Real js1(s.j(n,   sigmaAlpha));
    const Real js2(s.j(n+1, sigmaAlpha));
    const Real ja( s.j(n,   aAlpha));
    const Real ya( s.y(n,   aAlpha));
    const Real jr( s.j(n,   r * alpha));
    const Real yr( s.y(n,   r * alpha));
    const Real jr0(s.j(n,   r0 * alpha));
    const Real yr0(s.y(n,   r0 * alpha));

    const Real J(hSigma_m_n * js1 + sigmaAlpha * js2);
    const Real Jsq(J * J);

    const Real JY1(ja * yr - ya * jr);
    const Real JY2(ja * yr0 - ya * jr0);

    const Real num(Jsq * JY1 * JY2);

    const Real den1(a * (realn + realn * realn - 
                           sigma * (h + h * h * sigma + sigma * alphasq))
                     * ja * ja);

    const Real den2(sigma * Jsq);

    const Real den(den1 + den2);

    const Real result(term1 * num / den);

    return result;
}



Real 
GreensFunction3DRadAbs::p_n(Integer n, Real r, Real t, Real max_alpha) const
{
    const unsigned int min_i(2);

    Real p(0.0);
    
    Integer i(0);
    for (;;)
    {
        const Real alpha(getAlpha(n,i));

        const Real p_i(p_n_alpha(i, n, r, t));
        p += p_i;

        if(alpha >= max_alpha && i >= min_i)
        {
            break;
        }

        if(i == MAX_ALPHA_SEQ)
        {
            break;
        }

        ++i;
    }

    return p;
}

void
GreensFunction3DRadAbs::makep_nTable(RealVector& p_nTable,
                                             Real r, Real t) const
{
    const Real sigma(this->getSigma());
    const Real a(this->geta());

    p_nTable.clear();

    const Real factor(a * sigma / (M_PI * 2));

    const Real Dt(this->getD() * t);
    const Real alpha00(this->getAlpha(0, 0));

    const Real max_alpha(sqrt(alpha00 * alpha00 - 
                              log(THETA_TOLERANCE * 1e-1) / Dt));


    const Real p_0(this->p_n(0, r, t, max_alpha) * factor);

    p_nTable.push_back(p_0);

    if(p_0 == 0)
    {
        return;
    }

    const Real threshold(fabs(THETA_TOLERANCE * p_0));

    Real p_n_prev_abs(fabs(p_0));
    unsigned int n(1);
    for (;;)
    {
        if(getAlpha(n, 0) >= max_alpha)
        {
            break;
        }

        Real p_n(this->p_n(n, r, t, max_alpha) * factor);
        
        p_nTable.push_back(p_n);
        const Real p_n_abs(fabs(p_n));
        // truncate when converged enough.
        if(p_n_abs < threshold &&
           p_n_prev_abs < threshold &&
           p_n_abs <= p_n_prev_abs)
        {
            break;
        }
        
        if (n >= this->MAX_ORDER)
        {
            break;
        }
        
        ++n;
        p_n_prev_abs = p_n_abs;
    }
}


Real 
GreensFunction3DRadAbs::dp_n_alpha_at_a(unsigned int i, unsigned int n,
                                                Real t) const
{
    const Real sigma(this->getSigma());
    const Real h(this->geth());
    const Real a(this->geta());

    const Real mDt(- this->getD() * t);
    const Real alpha(this->getAlpha(n, i));

    const Real alphasq(alpha * alpha);

    const Real aAlpha(a * alpha);
    const Real sigmaAlpha(sigma * alpha);
    const Real hSigma(geth() * getSigma());
    const Real realn(static_cast<Real>(n));
    const Real hSigma_m_n(hSigma - realn);

    const Real term1(alphasq * alpha * exp(mDt * alphasq));

    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());

    const Real js1(s.j(n,   sigmaAlpha));
    const Real js2(s.j(n+1, sigmaAlpha));
    const Real ja( s.j(n,   aAlpha));
    const Real ya( s.y(n,   aAlpha));
    const Real jr0(s.j(n,   r0 * alpha));
    const Real yr0(s.y(n,   r0 * alpha));

    const Real J(hSigma_m_n * js1 + sigmaAlpha * js2);
    const Real Jsq(J * J);

    const Real JY(- jr0 * ya + ja * yr0);

    const Real num(Jsq * JY);

    const Real den1(a * (realn + realn * realn - 
                           sigma * (h + h * h * sigma + sigma * alphasq))
                     * ja * ja);

    const Real den2(sigma * Jsq);

    const Real den(den1 + den2);

    const Real result(term1 * num / den);

    return result;
}

Real 
GreensFunction3DRadAbs::dp_n_at_a(Integer n, Real t,
                                          Real max_alpha) const
{
    const unsigned int min_i(2);

    Real p(0.0);
    
    Integer i(0);
    for (;;)
    {
        const Real alpha(getAlpha(n,i));

        const Real p_i(dp_n_alpha_at_a(i, n, t));

        p += p_i;

        if(alpha >= max_alpha && i >= min_i)
        {
            break;
        }

        if(i == MAX_ALPHA_SEQ)
        {
            break;
        }

        ++i;
    }

    return p;
}


void
GreensFunction3DRadAbs::makedp_n_at_aTable(RealVector& p_nTable,
                                                   Real t) const
{
    const Real sigma(this->getSigma());
    const Real a(this->geta());

    p_nTable.clear();

    const Real factor(this->getD() * sigma / (a * M_PI * 2));

    const Real Dt(this->getD() * t);
    const Real alpha00(this->getAlpha(0, 0));

    const Real max_alpha(sqrt(Dt * alpha00 * alpha00 - 
                              log(THETA_TOLERANCE * 1e-1) / Dt));


    const Real p_0(this->dp_n_at_a(0, t, max_alpha) * factor);

    p_nTable.push_back(p_0);

    if(p_0 == 0)
    {
        return;
    }

    const Real threshold(fabs(THETA_TOLERANCE * p_0));

    Real p_n_prev_abs(fabs(p_0));
    unsigned int n(1);
    for (;;)
    {
        if(getAlpha(n, 0) >= max_alpha)
        {
            break;
        }

        Real p_n(this->dp_n_at_a(n, t, max_alpha) * factor);

        p_nTable.push_back(p_n);
        
        const Real p_n_abs(fabs(p_n));
        // truncate when converged enough.
        if(p_n_abs < threshold &&
           p_n_prev_abs < threshold &&
           p_n_abs <= p_n_prev_abs)
        {
            break;
        }
        
        if (n >= this->MAX_ORDER)
        {
            break;
        }
        
        ++n;
        p_n_prev_abs = p_n_abs;
    }

}

Real 
GreensFunction3DRadAbs::p_theta(Real theta, Real r, Real t) const 
{
    {
        const Real sigma(this->getSigma());
        const Real a(this->geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        // r \in (sigma, a);  not defined at r == sigma and r == a.
        if (!(r >= sigma && r < a))
        {
            throw std::invalid_argument((boost::format("r >= sigma && r < a : r=%g, sigma=%g, a=%g") % r % sigma % a).str());
        }

        if (!(r0 >= sigma && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makep_nTable(p_nTable, r, t);

    const Real p(p_theta_table(theta, r, t, p_nTable));

    return p;
}

Real GreensFunction3DRadAbs::dp_theta(Real theta, Real r, Real t) const 
{
    {
        const Real sigma(this->getSigma());
        const Real a(this->geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }


        // r \in [ sigma, a ]  ;  unlike p_theta,
        // defined at r == sigma and r == a.
        if (!(r >= sigma && r <= a))
        {
            throw std::invalid_argument((boost::format("r >= sigma && r <= a : r=%g, sigma=%g, a=%g") % r % sigma % a).str());
        }

        if (!(r0 >= sigma && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makedp_n_at_aTable(p_nTable, t);

    const Real p(p_theta_table(theta, r, t, p_nTable));

    return p;
}


static Real
p_theta_n(unsigned int n,
          GreensFunction3DRadAbs::RealVector const& p_nTable,
          GreensFunction3DRadAbs::RealVector const& lgndTable)
{
    return p_nTable[n] * lgndTable[n] * (2 * n + 1);
}

Real
GreensFunction3DRadAbs::p_theta_table(Real theta, Real r,
                                              Real t,
                                              RealVector const& p_nTable) const
{
    const unsigned int tableSize(p_nTable.size());

    Real sin_theta;
    Real cos_theta;
    sincos(theta, &sin_theta, &cos_theta);

    RealVector lgndTable(tableSize);
    gsl_sf_legendre_Pl_array(tableSize-1, cos_theta, &lgndTable[0]);

    return funcSum_all(
            boost::bind(&p_theta_n, _1, p_nTable, lgndTable),
            tableSize) * sin_theta;
}

void
GreensFunction3DRadAbs::
make_p_thetaTable(RealVector& pTable,
                  Real r, 
                  Real t,
                  unsigned int n,
                  RealVector const& p_nTable) const
{
    const Real thetaStep(M_PI / n);

    pTable.push_back(0.0);

    Real p_prev(0.0);
    unsigned int i(1);
    for (;;)
    {
        const Real theta(thetaStep * i);

        Real p(this->p_theta_table(theta, r, t, p_nTable));

        if (p < 0.0)
        {
            log_.info("drawTheta: p<0 %g", p);
            p = 0.0;
        }

        const Real value((p_prev + p) * 0.5);
        pTable.push_back(*(pTable.end() - 1) + value);

        if (/* value < pTable[i] * std::numeric_limits<Real>::epsilon() || */
            i >= n - 1)
        {
            break;   // pTable is valid in [0,i].
        }

        p_prev = p;
        ++i;
    }

}


Real 
GreensFunction3DRadAbs::ip_theta(Real theta, Real r, Real t) const
{
    {
        const Real sigma(this->getSigma());
        const Real a(this->geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        // r \in (sigma, a)
        if (!(r >= sigma && r < a))
        {
            throw std::invalid_argument((boost::format("r >= sigma && r < a : r=%g, sigma=%g, a=%g") % r % sigma % a).str());
        }

        if (!(r0 >= sigma && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0 || theta == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makep_nTable(p_nTable, r, t);

    const Real p(ip_theta_table(theta, r, t, p_nTable));

    return p;
}


Real 
GreensFunction3DRadAbs::idp_theta(Real theta, Real r, Real t) const
{
    {
        const Real sigma(this->getSigma());
        const Real a(this->geta());
        
        if (!(theta >= 0.0 && theta <= M_PI))
        {
            throw std::invalid_argument((boost::format("theta >= 0.0 && theta <= M_PI : theta=%g, M_PI=%g") % theta % M_PI).str());
        }

        // r \in [ sigma, a ]
        if (!(r >= sigma && r <= a))
        {
            throw std::invalid_argument((boost::format("r >= sigma && r <= a : r=%g, sigma=%g, a=%g") % r % sigma % a).str());
        }

        if (!(r0 >= sigma && r0 < a))
        {
            throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
        }

        if (!(t >= 0.0))
        {
            throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
        }

    }

    if (t == 0.0 || theta == 0.0)
    {
        return 0.0;
    }

    RealVector p_nTable;

    makedp_n_at_aTable(p_nTable, t);

    const Real p(ip_theta_table(theta, r, t, p_nTable));

    return p;
}

static Real
ip_theta_n(unsigned int n,
           GreensFunction3DRadAbs::RealVector const& p_nTable,
           GreensFunction3DRadAbs::RealVector const& lgndTable1)
{
    // lgndTable1 is offset by 1; lgndTable1[0] is for n=-1.

    const Real lgnd_n_m1(lgndTable1[n]);   // n-1
    const Real lgnd_n_p1(lgndTable1[n+2]); // n+1
    
    // the term (1 + 2 n) is canceled out.
    return p_nTable[n] * (lgnd_n_m1 - lgnd_n_p1);
}


Real 
GreensFunction3DRadAbs::ip_theta_table(Real theta, Real r,
                                               Real t, RealVector const& p_nTable) const
{
    const unsigned int tableSize(p_nTable.size());

    const Real cos_theta(cos(theta));

    // LgndTable is offset by 1 to incorporate the n=-1 case.
    // For ex: LgndTable[0] is for n=-1, lgndTable[1] is for n=0 ...

    RealVector lgndTable(tableSize + 2);
    lgndTable[0] = 1.0;  // n = -1
    gsl_sf_legendre_Pl_array(tableSize, cos_theta, &lgndTable[1]);

    return funcSum_all(
        boost::bind(&ip_theta_n, _1, p_nTable, lgndTable),
        tableSize);
}

struct GreensFunction3DRadAbs::ip_theta_params
{ 
    GreensFunction3DRadAbs const* const gf;
    const Real r;
    const Real t;
    RealVector const& p_nTable;
    const Real value;
};

Real GreensFunction3DRadAbs::ip_theta_F(Real theta, ip_theta_params const* params)
{
    const GreensFunction3DRadAbs* const gf(params->gf); 
    const Real r(params->r);
    const Real t(params->t);
    RealVector const& p_nTable(params->p_nTable);
    const Real value(params->value);

    return gf->ip_theta_table(theta, r, t, p_nTable) - value;
}

Real 
GreensFunction3DRadAbs::drawTheta(Real rnd, Real r, Real t) const
{
    Real theta;

    const Real sigma(this->getSigma());
    const Real a(this->geta());

    // input parameter range checks.
    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma && r0 < a))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma && r0 < a : r0=%g, sigma=%g, a=%g") % r0 % sigma % a).str());
    }

    if (!(r >= sigma))
    {
        throw std::invalid_argument((boost::format("r >= sigma : r=%g, sigma=%g") % r % sigma).str());
    }

    if (!(t >= 0.0))
    {
        throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
    }


    // t == 0 means no move.
    if (t == 0.0)
    {
        return 0.0;
    }

    const Real high(M_PI);

    RealVector p_nTable;

    if (r >= geta())
    {
        //puts("dp");
        makedp_n_at_aTable(p_nTable, t);
    }
    else
    {
        makep_nTable(p_nTable, r, t);
    }

    const Real ip_theta_pi(ip_theta_table(high, r, t, p_nTable));

    ip_theta_params params = { this, r, t, p_nTable, rnd * ip_theta_pi };

    gsl_function F = 
        { reinterpret_cast<typeof(F.function)>(&ip_theta_F), &params };

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, 0.0, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        const Real low(gsl_root_fsolver_x_lower(solver));
        const Real high(gsl_root_fsolver_x_upper(solver));
        const int status(gsl_root_test_interval(low, high, 1e-11,
                                                  THETA_TOLERANCE));

        if (status == GSL_CONTINUE)
        {
            if (i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawTheta: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    theta = gsl_root_fsolver_root(solver);
    gsl_root_fsolver_free(solver);
    
    return theta;
}


//
// debug
//

std::string GreensFunction3DRadAbs::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << ", sigma = " << this->getSigma() <<
        ", a = " << this->geta() <<
        ", kf = " << this->getkf() <<
        ", h = " << this->geth() << std::endl;
    return ss.str();
}

Logger& GreensFunction3DRadAbs::log_(
        Logger::get_logger("GreensFunction3DRadAbs"));
 </xmp> 
<h3> GreensFunction3DRadInf.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdexcept>
#include <vector>
#include <sstream>
#include <cmath>

#include "compat.h"

#include <boost/bind.hpp>
#include <boost/format.hpp>

#include <gsl/gsl_math.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_sf_legendre.h>
#include <gsl/gsl_sf_bessel.h>
#include <gsl/gsl_integration.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_roots.h>

#include "freeFunctions.hpp"

#include "funcSum.hpp"

#include "SphericalBesselGenerator.hpp"

#include "GreensFunction3DRadInf.hpp"



GreensFunction3DRadInf::GreensFunction3DRadInf(Real D, Real kf, Real r0, Real Sigma)
    : PairGreensFunction(D, kf, r0, Sigma),
      kD(4.0 * M_PI * getSigma() * getD()),
      alpha((1.0 + (getkf() / getkD())) * (sqrt(getD()) / getSigma()))
{
    ; // do nothing
}

GreensFunction3DRadInf::~GreensFunction3DRadInf()
{
    ; // do nothing
}

Real 
GreensFunction3DRadInf::p_corr_R(Real alpha, unsigned int n, Real r, Real t) const
{
    const Real D(this->getD());
    const Real sigma(this->getSigma());
    
    const Real ks(getkf() * sigma);
    const Real realn(static_cast<Real>(n));
    const Real ks_m_n(ks - realn);

    const Real alphasq(alpha * alpha);

    const Real term1(exp(- D * t * alphasq));

    const Real sAlpha(sigma * alpha);
    const Real rAlpha(r * alpha);
    const Real r0Alpha(r0 * alpha);

    const SphericalBesselGenerator& s(SphericalBesselGenerator::instance());
    const Real js( s.j(n,     sAlpha));
    const Real ys( s.y(n,     sAlpha));
    const Real js1(s.j(n + 1, sAlpha));
    const Real ys1(s.y(n + 1, sAlpha));
    const Real jr( s.j(n,     rAlpha));
    const Real yr( s.y(n,     rAlpha));
    const Real jr0(s.j(n,     r0Alpha));
    const Real yr0(s.y(n,     r0Alpha));

    const Real R1((ks_m_n * js + sAlpha * js1));
    const Real R2((ks_m_n * ys + sAlpha * ys1));

    const Real F1R1(R1 * jr * jr0 - R1 * yr * yr0);
    const Real F2(jr0 * yr + jr * yr0);

    const Real num(2.0 * sqrt(r * r0) *
                    alphasq * R1 * (F1R1 + F2 * R2));
    const Real den(M_PI * (R1 * R1 + R2 * R2));

    const Real result(term1 * num / den);

    assert(isfinite(result));

    return result;
}

struct GreensFunction3DRadInf::p_corr_R_params 
{ 
    const GreensFunction3DRadInf* const gf;
    unsigned int n;
    const Real r;
    const Real t; 
};

Real GreensFunction3DRadInf::p_corr_R_F(Real alpha, p_corr_R_params* params)
{
    const GreensFunction3DRadInf* const gf(params->gf); 

    const unsigned int n(params->n);
    const Real r(params->r);
    const Real t(params->t);

    return gf->p_corr_R(alpha, n, r, t);
}


Real GreensFunction3DRadInf::p_corr(Real theta, Real r, Real t) const
{
    RealVector RnTable;
    makeRnTable(RnTable, r, t);

    return p_corr_table(theta, r, t, RnTable);
}

Real GreensFunction3DRadInf::ip_corr(Real theta, Real r, Real t) const
{
    RealVector RnTable;
    makeRnTable(RnTable, r, t);

    return ip_corr_table(theta, r, t, RnTable);
}


Real GreensFunction3DRadInf::p_free(Real theta, Real r, Real t) const
{
    return p_theta_free(theta, r, r0, t, getD());
}

Real GreensFunction3DRadInf::p_survival(Real t) const
{
    return 1.0 - p_reaction(t);
}


Real GreensFunction3DRadInf::p_reaction(Real t) const
{
    const Real kf(getkf());
    const Real D(getD());
    const Real sigma(getSigma());
    const Real alpha(getalpha());
    const Real kD(getkD());

    return __p_reaction_irr(t, r0, kf, D, sigma, alpha, kD);
}

struct p_reaction_params 
{ 
    const GreensFunction3DRadInf* const gf;
    const Real rnd;
};

static Real p_reaction_F(Real t, p_reaction_params* params)
{
    const GreensFunction3DRadInf* const gf(params->gf); 
    const Real kf(gf->getkf());
    const Real D(gf->getD());
    const Real sigma(gf->getSigma());
    const Real alpha(gf->getalpha());
    const Real kD(gf->getkD());

    const Real r0(gf->getr0());
    const Real rnd(params->rnd);

    return __p_reaction_irr(t, r0, kf, D, sigma, alpha, kD ) - rnd;
}


Real 
GreensFunction3DRadInf::p_int_r(Real r, Real t) const
{
    const Real kf(getkf());
    const Real D(getD());
    const Real sigma(getSigma());
    const Real alpha(getalpha());
    const Real kD(getkD());

    const Real Dt(D * t);

    const Real kf_kD(kf + kD);
    const Real Dt4(4.0 * Dt);
    const Real sqrtDt4(sqrt(Dt4));
    const Real ksigma2(2.0 * kf * sigma);
    const Real alphasqrtt(alpha * sqrt(t));

    const Real r_r0__2s___sqrtDt4((r - 2.0 * sigma + r0) / sqrtDt4);
    const Real r_r0__sqrtDt4((r - r0) / sqrtDt4);
    const Real r0_s__sqrtDt4((r0 - sigma) / sqrtDt4);

    const Real term1((expm1(- gsl_pow_2(r_r0__2s___sqrtDt4 ))
                        - expm1(- gsl_pow_2(r_r0__sqrtDt4))) * 
                        sqrt(Dt / M_PI));

    const Real erf_r_r0__2s___sqrtDt4(erf(r_r0__2s___sqrtDt4));
    const Real term2(kf_kD * r0 * erf(r_r0__sqrtDt4) 
                      + kf_kD * r0 * erf_r_r0__2s___sqrtDt4
                      + ksigma2 * 
                      (erf(r0_s__sqrtDt4) - erf_r_r0__2s___sqrtDt4));

    const Real term3(kf * sigma * W(r0_s__sqrtDt4, alphasqrtt) 
                      - (kf * r + kD * (r - sigma)) *
                      W(r_r0__2s___sqrtDt4, alphasqrtt));

    const Real result((1 / r0) * (term1 + (1 / kf_kD) * 
                                      ((0.5 * term2) + term3)));

    return result;
}

struct p_int_r_params 
{ 
    const GreensFunction3DRadInf* const gf;
    const Real t;
    const Real rnd;
};

static Real p_int_r_F(Real r, p_int_r_params* params)
{
    const GreensFunction3DRadInf* const gf(params->gf); 

    const Real t(params->t);
    const Real rnd(params->rnd);

    return gf->p_int_r(r, t) - rnd;
}


Real GreensFunction3DRadInf::drawTime(Real rnd) const
{
    const Real sigma(this->getSigma());

    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma : r0=%g, sigma=%g") % r0 % sigma).str());
    }


    Real low(1e-100);
    Real high(100);

    {
        const Real maxp(p_reaction(INFINITY));

        if(rnd >= maxp)
        {
            return INFINITY;
        }
    }

    p_reaction_params params = { this, rnd };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_reaction_F),
            &params 
        };

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);

        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        int status(gsl_root_test_interval(low, high, 1e-18, 1e-12));

        if(status == GSL_CONTINUE)
        {
            if(i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawTime: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real r(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);

    return r;
} 




Real GreensFunction3DRadInf::drawR(Real rnd, Real t) const
{
    const Real sigma(this->getSigma());
    const Real D(this->getD());

    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r0 >= sigma))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma : r0=%g, sigma=%g") % r0 % sigma).str());
    }

    if (!(t >= 0.0))
    {
        throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
    }


    if(t == 0.0)
    {
        return r0;
    }

    const Real psurv(p_survival(t));

    p_int_r_params params = { this, t, rnd * psurv };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_int_r_F),
            &params 
        };


    // adjust low and high starting from r0.
    // this is necessary to avoid root finding in the long tails where
    // numerics can be unstable.

    Real low(r0);
    Real high(r0);

    const Real sqrt6Dt(sqrt(6.0 * D * t));
    if(GSL_FN_EVAL(&F, r0) < 0.0)
    {
        // low = r0
        unsigned int H(3);

        for (;;)
        {
            high = r0 + H * sqrt6Dt;

            const Real value(GSL_FN_EVAL(&F, high));
            if(value > 0.0)
            {
                break;
            }

            ++H;

            if(H > 20)
            {
                throw std::runtime_error("drawR: H > 20 while adjusting upper bound of r");
            }
        }

    }
    else
    {
        // high = r0
        unsigned int H(3);

        for (;;)
        {
            low = r0 - H * sqrt6Dt;
            if(low < sigma)
            {
                if(GSL_FN_EVAL(&F, sigma) > 0.0)
                {
                    log_.info("drawR: p_int_r(sigma) > 0.0. "
                              "returning sigma.");
                    return sigma;
                }

                low = sigma;
                break;
            }

            const Real value(GSL_FN_EVAL(&F, low));
            if(value < 0.0)
            {
                break;
            }

            ++H;
        }
    }


    // root finding by iteration.

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, low, high);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        low = gsl_root_fsolver_x_lower(solver);
        high = gsl_root_fsolver_x_upper(solver);
        const int status(gsl_root_test_interval(low, high, 1e-15,
                                                  this->TOLERANCE));

        if(status == GSL_CONTINUE)
        {
            if(i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawR: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    const Real r(gsl_root_fsolver_root(solver));
    gsl_root_fsolver_free(solver);

    return r;
}


Real 
GreensFunction3DRadInf::Rn(unsigned int n, Real r, Real t,
                            gsl_integration_workspace* workspace,
                            Real tol) const
{
    Real integral;
    Real error;

    p_corr_R_params params = { this, n, r, t };
    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&p_corr_R_F),
            &params
        };

    const Real umax(sqrt(40.0 / (this->getD() * t))); 

    gsl_integration_qag(&F, 0.0,
                         umax,
                         tol,
                         THETA_TOLERANCE,
                         2000, GSL_INTEG_GAUSS61,
                         workspace, &integral, &error);

    return integral;
}


Real GreensFunction3DRadInf::p_corr_n(unsigned int n, RealVector const& RnTable, RealVector const& lgndTable) const
{
    return RnTable[n] * lgndTable[n] * (2.0 * n + 1.0);
}

Real GreensFunction3DRadInf::ip_corr_n(unsigned int n, RealVector const& RnTable, RealVector const& lgndTable) const
{
    // lgndTable1 is offset by 1; lgndTable1[0] is for n=-1.

    const Real lgnd_n_m1(lgndTable[n]);   // n-1
    const Real lgnd_n_p1(lgndTable[n+2]); // n+1
    
    return RnTable[n] * (lgnd_n_m1 - lgnd_n_p1);// / (1.0 + 2.0 * n);
}


Real GreensFunction3DRadInf::p_corr_table(Real theta, Real r, Real t, RealVector const& RnTable) const
{
    const Index tableSize(RnTable.size());
    if(tableSize == 0)
    {
        return 0.0;
    }

    Real result(0.0);


    Real sin_theta;
    Real cos_theta;
    sincos(theta, &sin_theta, &cos_theta);

    RealVector lgndTable(tableSize);
    gsl_sf_legendre_Pl_array(tableSize-1, cos(theta), &lgndTable[0]);


    const Real p(funcSum_all(boost::bind(&GreensFunction3DRadInf::
                                            p_corr_n,
                                            this,
                                            _1, RnTable, lgndTable),
                               tableSize));

    result = - p * sin_theta;

    result /= 4.0 * M_PI * sqrt(r * r0);

    return result;
}


Real GreensFunction3DRadInf::ip_corr_table(Real theta, Real r,
                                            Real t, RealVector const& RnTable) const
{
    const Index tableSize(RnTable.size());
    if(tableSize == 0)
    {
        return 0.0;
    }

    const Real cos_theta(cos(theta));
    
    // lgndTable is offset by 1. lengTable[0] -> n = -1

    RealVector lgndTable(tableSize + 2);
    lgndTable[0] = 1.0; // n = -1
    gsl_sf_legendre_Pl_array(tableSize, cos_theta, &lgndTable[1]);

    const Real p(funcSum_all(boost::bind(&GreensFunction3DRadInf::
                                            ip_corr_n,
                                            this,
                                            _1, RnTable, lgndTable),
                               tableSize));

    const Real result(- p / (4.0 * M_PI * sqrt(r * r0)));
    return result;
}

Real 
GreensFunction3DRadInf::ip_free(Real theta, Real r, Real t) const
{
    return ip_theta_free(theta, r, r0, t, getD());
}


Real GreensFunction3DRadInf::p_theta(Real theta, Real r, Real t) const
{
    RealVector RnTable;
    makeRnTable(RnTable, r, t);

    return p_theta_table(theta, r, t, RnTable);
}

Real GreensFunction3DRadInf::ip_theta(Real theta, Real r, Real t) const
{
    RealVector RnTable;
    makeRnTable(RnTable, r, t);

    return ip_theta_table(theta, r, t, RnTable);
}


Real GreensFunction3DRadInf::p_theta_table(Real theta, Real r,
                                            Real t, RealVector const& RnTable) const
{
    const Real p_free(this->p_free(theta, r, t));
    const Real p_corr(this->p_corr_table(theta, r, t, RnTable)); 

//    return p_free;
    return (p_free + p_corr);
}

Real GreensFunction3DRadInf::ip_theta_table(Real theta, Real r, Real t, RealVector const& RnTable) const
{
    const Real p_free(this->ip_free(theta, r, t));
    const Real p_corr(this->ip_corr_table(theta, r, t, RnTable)); 

    return (p_free + p_corr);
}

static const Real p_free_max(Real r, Real r0, Real t, Real D)
{
    const Real Dt4(4.0 * D * t);
    const Real Dt4Pi(Dt4 * M_PI);

    const Real term1(exp(- gsl_pow_2(r - r0) / Dt4));
    const Real term2(1.0 / sqrt(Dt4Pi * Dt4Pi * Dt4Pi));

    return term1 * term2;
}

void GreensFunction3DRadInf::makeRnTable(RealVector& RnTable,
                                          Real r, Real t) const
{
    RnTable.clear();

    const Real sigma(getSigma());
    const Real D(getD());
    const Real kf(getkf());

    {  
        // First, estimate the size of p_corr, and if it's small enough,
        // we don't need to calculate it in the first place.
        const Real pirr(p_irr(r, r0, t, kf, D, sigma));
        const Real ipfree_max(ip_free(M_PI, r, t) * 2 * M_PI * r * r);
        
        if(fabs((pirr - ipfree_max) / ipfree_max) < 1e-8)
        {
            return;
        }
    }


    const Real pfreemax(p_free_max(r, r0, t, D));

    gsl_integration_workspace* 
        workspace(gsl_integration_workspace_alloc(2000));
    
    Real Rn_prev(0.0);
    const Real RnFactor(1.0 / (4.0 * M_PI * sqrt(r * r0)));

    const Real integrationTolerance(pfreemax / RnFactor * THETA_TOLERANCE);
    const Real truncationTolerance(pfreemax * THETA_TOLERANCE * 1e-1);
    
    unsigned int n(0);
    for (;;) 
    {
        const Real Rn(this->Rn(n, r, t, workspace, 
                                 integrationTolerance));
        
        RnTable.push_back(Rn);
        
        // truncate when converged enough.
        const Real absRn(fabs(Rn));
        if(absRn * RnFactor < truncationTolerance &&
            absRn < Rn_prev)
        {
            break;
        }

        if(n >= this->MAX_ORDER)
        {
            log_.info("GreensFunction3DRadInf: Rn didn't converge");
            break;
        }
        
        Rn_prev = fabs(Rn);
        
        ++n;
    }

    gsl_integration_workspace_free(workspace);
}

struct GreensFunction3DRadInf::p_theta_params 
{ 
    const GreensFunction3DRadInf* const gf;
    const Real r;
    const Real t;
    GreensFunction3DRadInf::RealVector const& RnTable;
    const Real value;
};
    
Real GreensFunction3DRadInf::ip_theta_F(Real theta, p_theta_params* params)
{
    const GreensFunction3DRadInf* const gf(params->gf); 
    const Real r(params->r);
    const Real t(params->t);
    GreensFunction3DRadInf::RealVector const& RnTable(params->RnTable);
    const Real value(params->value);

    return gf->ip_theta_table(theta, r, t, RnTable) - value;
}


Real GreensFunction3DRadInf::drawTheta(Real rnd, Real r, Real t) const
{
    Real theta;

    const Real sigma(this->getSigma());

    // input parameter range checks.
    if (!(rnd < 1.0 && rnd >= 0.0))
    {
        throw std::invalid_argument((boost::format("rnd < 1.0 && rnd >= 0.0 : rnd=%g") % rnd).str());
    }

    if (!(r >= sigma))
    {
        throw std::invalid_argument((boost::format("r >= sigma : r=%g, sigma=%g") % r % sigma).str());
    }

    if (!(r0 >= sigma))
    {
        throw std::invalid_argument((boost::format("r0 >= sigma : r0=%g, sigma=%g") % r0 % sigma).str());
    }

    if (!(t >= 0.0))
    {
        throw std::invalid_argument((boost::format("t >= 0.0 : t=%g") % t).str());
    }


    // t == 0 means no move.
    if(t == 0.0)
    {
        return 0.0;
    }

    RealVector RnTable;
    makeRnTable(RnTable, r, t);


    // root finding with the integrand form.

    const Real ip_theta_pi(ip_theta_table(M_PI, r, t, RnTable));

    p_theta_params params = { this, r, t, RnTable, rnd * ip_theta_pi };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>(&ip_theta_F),
            &params 
        };

    const gsl_root_fsolver_type* solverType(gsl_root_fsolver_brent);
    gsl_root_fsolver* solver(gsl_root_fsolver_alloc(solverType));
    gsl_root_fsolver_set(solver, &F, 0.0, M_PI);

    const unsigned int maxIter(100);

    unsigned int i(0);
    for (;;)
    {
        gsl_root_fsolver_iterate(solver);
        const Real low(gsl_root_fsolver_x_lower(solver));
        const Real high(gsl_root_fsolver_x_upper(solver));
        const int status(gsl_root_test_interval(low, high, 1e-15,
                                                  THETA_TOLERANCE));

        if(status == GSL_CONTINUE)
        {
            if(i >= maxIter)
            {
                gsl_root_fsolver_free(solver);
                throw std::runtime_error("drawTheta: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    theta = gsl_root_fsolver_root(solver);
    gsl_root_fsolver_free(solver);

    return theta;
}



//
// debug
//

std::string GreensFunction3DRadInf::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << ", sigma = " << this->getSigma() <<
        ", kf = " << this->getkf() <<
        ", kD = " << this->getkD() <<
        ", alpha = " << this->getalpha() << std::endl;
    return ss.str();
}

Logger& GreensFunction3DRadInf::log_(
        Logger::get_logger("GreensFunction3DRadInf"));

 </xmp> 
<h3> GreensFunction3DSym.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdexcept>
#include <sstream>

#include <boost/format.hpp>

#include <gsl/gsl_errno.h>
#include <gsl/gsl_roots.h>

#include "GreensFunction3DSym.hpp"

Real GreensFunction3DSym::p_r(Real r, Real t) const
{
    const Real D( getD() );
    const Real Dt( D * t );
    const Real Dt4( 4.0 * Dt );

    const Real Dt4Pi( Dt4 * M_PI );

    const Real term1( 1.0 / sqrt( gsl_pow_3( Dt4Pi ) ) );
    const Real term2( exp( - r * r / Dt4 ) );

    const Real jacobian( 4.0 * r * r * M_PI );

    return jacobian * term1 * term2;
}

Real GreensFunction3DSym::ip_r(Real r, Real t) const
{
    const Real D( getD() );
    const Real Dt( D * t );
    const Real sqrtDt_r( 1.0 / sqrt( D * t ) );
    const Real sqrtPi_r( 1.0 / sqrt( M_PI ) );

    const Real term1( exp( - r * r / ( 4.0 * Dt ) ) * 
                      r * sqrtDt_r * sqrtPi_r );
    const Real term2( erf( r * 0.5 * sqrtDt_r ) );

    return term2 - term1;
}

struct ip_r_params
{ 
    GreensFunction3DSym const* const gf;
    const Real t;
    const Real value;
};


static Real ip_r_F(Real r, ip_r_params const* params)
{
    const GreensFunction3DSym* const gf( params->gf ); 
    const Real t( params->t );
    const Real value( params->value );

    return gf->ip_r( r, t ) - value;
}


Real GreensFunction3DSym::drawR(Real rnd, Real t) const
{
    // input parameter range checks.
    if ( !(rnd <= 1.0 && rnd >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "rnd <= 1.0 && rnd >= 0.0 : rnd=%g" ) % rnd ).str() );
    }

    if ( !(t >= 0.0 ) )
    {
        throw std::invalid_argument( ( boost::format( "t >= 0.0 : t=%g" ) % t ).str() );
    }


    // t == 0 or D == 0 means no move.
    if( t == 0.0 || getD() == 0.0 )
    {
        return 0.0;
    }

    ip_r_params params = { this, t, rnd };

    gsl_function F = 
        {
            reinterpret_cast<typeof(F.function)>( &ip_r_F ),
            &params 
        };

    Real max_r( 4.0 * sqrt( 6.0 * getD() * t ) );

    while( GSL_FN_EVAL( &F, max_r ) < 0.0 )
    {
        max_r *= 10;
    }

    const gsl_root_fsolver_type* solverType( gsl_root_fsolver_brent );
    gsl_root_fsolver* solver( gsl_root_fsolver_alloc( solverType ) );
    gsl_root_fsolver_set( solver, &F, 0.0, max_r );

    const unsigned int maxIter( 100 );

    unsigned int i( 0 );
    while( true )
    {
        gsl_root_fsolver_iterate( solver );
        const Real low( gsl_root_fsolver_x_lower( solver ) );
        const Real high( gsl_root_fsolver_x_upper( solver ) );
        const int status( gsl_root_test_interval( low, high, 1e-15, 
                                                  this->TOLERANCE ) );

        if( status == GSL_CONTINUE )
        {
            if( i >= maxIter )
            {
                gsl_root_fsolver_free( solver );
                throw std::runtime_error("drawR: failed to converge");
            }
        }
        else
        {
            break;
        }

        ++i;
    }
  
    //printf("%d\n", i );

    const Real r( gsl_root_fsolver_root( solver ) );
    gsl_root_fsolver_free( solver );
    
    return r;
}


std::string GreensFunction3DSym::dump() const
{
    std::ostringstream ss;
    ss << "D = " << this->getD() << std::endl;
    return ss.str();
}


Logger& GreensFunction3DSym::log_(
        Logger::get_logger("GreensFunction3DSym"));
 </xmp> 
<h3> greens_functions.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <boost/python.hpp>

#include "freeFunctions.hpp"
#include "GreensFunction1DAbsAbs.hpp"
#include "GreensFunction1DRadAbs.hpp"
#include "GreensFunction3DSym.hpp"
#include "GreensFunction3DAbsSym.hpp"
#include "GreensFunction3DRadInf.hpp"
#include "GreensFunction3D.hpp"
#include "GreensFunction3DRadAbs.hpp"
#include "GreensFunction3DAbs.hpp"

BOOST_PYTHON_MODULE( _greens_functions )
{
    using namespace boost::python;

    //import_array();
    // free functions
    def( "p_irr", p_irr );
    def( "p_survival_irr", p_survival_irr );
    def( "p_theta_free", p_theta_free );
    def( "ip_theta_free", ip_theta_free );
    def( "g_bd", g_bd );
    def( "I_bd", I_bd );
    def( "I_bd_r", I_bd_r );
    def( "drawR_gbd", drawR_gbd );
    def( "p_reaction_irr", __p_reaction_irr );
    def( "p_reaction_irr_t_inf", __p_reaction_irr_t_inf );

    
    class_<GreensFunction1DAbsAbs>("GreensFunction1DAbsAbs",
                                   init<Real, Real, Real, Real>() )
        .def( init<Real, Real, Real, Real, Real>())
        .def( "getD", &GreensFunction1DAbsAbs::getD )
        .def( "getv", &GreensFunction1DAbsAbs::getv )
        .def( "getsigma", &GreensFunction1DAbsAbs::getsigma )
        .def( "seta", &GreensFunction1DAbsAbs::seta )
        .def( "geta", &GreensFunction1DAbsAbs::geta )
        .def( "setr0", &GreensFunction1DAbsAbs::setr0 )
        .def( "getr0", &GreensFunction1DAbsAbs::getr0 )
        .def( "drawTime", &GreensFunction1DAbsAbs::drawTime )
        .def( "drawR", &GreensFunction1DAbsAbs::drawR )
        .def( "drawEventType", &GreensFunction1DAbsAbs::drawEventType )
        .def( "leaves", &GreensFunction1DAbsAbs::leaves )
        .def( "leavea", &GreensFunction1DAbsAbs::leavea )
        .def( "p_survival", &GreensFunction1DAbsAbs::p_survival )
        .def( "calcpcum", &GreensFunction1DAbsAbs::calcpcum )
        .def( "dump", &GreensFunction1DRadAbs::dump )
        ;

    class_<GreensFunction1DRadAbs>("GreensFunction1DRadAbs",
                                   init<Real, Real, Real, Real, Real>() )
        .def( init<Real, Real, Real, Real, Real, Real>())
        .def( "getk", &GreensFunction1DRadAbs::getk )
        .def( "getD", &GreensFunction1DRadAbs::getD )
        .def( "getv", &GreensFunction1DRadAbs::getv )
        .def( "getsigma", &GreensFunction1DRadAbs::getsigma )
        .def( "seta", &GreensFunction1DRadAbs::seta )
        .def( "geta", &GreensFunction1DRadAbs::geta )
        .def( "setr0", &GreensFunction1DRadAbs::setr0 )
        .def( "getr0", &GreensFunction1DRadAbs::getr0 )
        .def( "drawTime", &GreensFunction1DRadAbs::drawTime )
        .def( "drawR", &GreensFunction1DRadAbs::drawR )
        .def( "drawEventType", &GreensFunction1DRadAbs::drawEventType )
        .def( "flux_tot", &GreensFunction1DRadAbs::flux_tot )
        .def( "flux_rad", &GreensFunction1DRadAbs::flux_rad )
        .def( "fluxRatioRadTot", &GreensFunction1DRadAbs::fluxRatioRadTot )
        .def( "p_survival", &GreensFunction1DRadAbs::p_survival )
        .def( "calcpcum", &GreensFunction1DRadAbs::calcpcum )
        .def( "dump", &GreensFunction1DRadAbs::dump )
        ;
    
    class_<GreensFunction3DSym>("GreensFunction3DSym", init<Real>())
        .def( "getD", &GreensFunction3DSym::getD )
        .def( "drawTime", &GreensFunction3DSym::drawTime )
        .def( "drawR", &GreensFunction3DSym::drawR )
        .def( "p_r", &GreensFunction3DSym::p_r )
        .def( "ip_r", &GreensFunction3DSym::ip_r )
        .def( "dump", &GreensFunction3DSym::dump )
        ;

    class_<GreensFunction3DAbsSym>("GreensFunction3DAbsSym",
                                   init<Real, Real>())
        .def( "getD", &GreensFunction3DAbsSym::getD )
        .def( "geta", &GreensFunction3DAbsSym::geta )
        .def( "drawTime", &GreensFunction3DAbsSym::drawTime )
        .def( "drawR", &GreensFunction3DAbsSym::drawR )
        .def( "p_survival", &GreensFunction3DAbsSym::p_survival )
        .def( "p_int_r", &GreensFunction3DAbsSym::p_int_r )
        .def( "p_int_r_free", &GreensFunction3DAbsSym::p_int_r_free )
        //.def( "p_r_fourier", &GreensFunction3DAbsSym::p_r_fourier )
        ;

    class_<GreensFunction3DRadInf>("GreensFunction3DRadInf",
                                   init<Real, Real, Real, Real>())
        .def( "getD", &GreensFunction3DRadInf::getD )
        .def( "getkf", &GreensFunction3DRadInf::getkf )
        .def( "getSigma", &GreensFunction3DRadInf::getSigma )
        .def( "drawTime", &GreensFunction3DRadInf::drawTime )
        .def( "drawR", &GreensFunction3DRadInf::drawR )
        .def( "drawTheta", &GreensFunction3DRadInf::drawTheta )

//        .def( "p_tot", &GreensFunction3DRadInf::p_tot )
        .def( "p_free", &GreensFunction3DRadInf::p_free )
        .def( "ip_free", &GreensFunction3DRadInf::ip_free )
        .def( "p_corr", &GreensFunction3DRadInf::p_corr )
        .def( "ip_corr", &GreensFunction3DRadInf::ip_corr )
        .def( "p_survival", &GreensFunction3DRadInf::p_survival )
        .def( "p_int_r", &GreensFunction3DRadInf::p_int_r )
        .def( "p_theta", &GreensFunction3DRadInf::p_theta )
        .def( "ip_theta", &GreensFunction3DRadInf::ip_theta )

        .def( "dump", &GreensFunction3DRadInf::dump )
        ;

    class_<GreensFunction3D>("GreensFunction3D", init<Real, Real>())
        .def( "getD", &GreensFunction3D::getD )
        .def( "getkf", &GreensFunction3D::getkf )
        .def( "getSigma", &GreensFunction3D::getSigma )
        .def( "drawTime", &GreensFunction3D::drawTime )
        .def( "drawR", &GreensFunction3D::drawR )
        .def( "drawTheta", &GreensFunction3D::drawTheta )

        .def( "p_r", &GreensFunction3D::p_r )
        .def( "ip_r", &GreensFunction3D::ip_r )
        .def( "p_theta", &GreensFunction3D::p_theta )
        .def( "ip_theta", &GreensFunction3D::ip_theta )

        .def( "dump", &GreensFunction3D::dump )
        ;

    enum_<GreensFunction::EventKind>("PairEventKind")
        .value( "IV_ESCAPE", GreensFunction3DRadAbs::IV_ESCAPE )
        .value( "IV_REACTION", GreensFunction3DRadAbs::IV_REACTION )
        .value( "IV_ESCAPE", GreensFunction1DRadAbs::IV_ESCAPE )
        .value( "IV_REACTION", GreensFunction1DRadAbs::IV_REACTION )
        ;

    class_<GreensFunction3DRadAbs>("GreensFunction3DRadAbs",
                                   init<Real, Real, Real, Real, Real>() )
        .def( "geta", &GreensFunction3DRadAbs::geta )
        .def( "getD", &GreensFunction3DRadAbs::getD )
        .def( "getkf", &GreensFunction3DRadInf::getkf )
        .def( "getSigma", &GreensFunction3DRadInf::getSigma )
        .def( "drawTime", &GreensFunction3DRadAbs::drawTime )
        //.def( "drawTime2", &GreensFunction3DRadAbs::drawTime2 )
        .def( "drawEventType", &GreensFunction3DRadAbs::drawEventType )
        .def( "drawR", &GreensFunction3DRadAbs::drawR )
        .def( "drawTheta", &GreensFunction3DRadAbs::drawTheta )

        .def( "p_survival", &GreensFunction3DRadAbs::p_survival )
        .def( "dp_survival", &GreensFunction3DRadAbs::dp_survival )
        .def( "p_leaves", &GreensFunction3DRadAbs::p_leaves )
        .def( "p_leavea", &GreensFunction3DRadAbs::p_leavea )
        .def( "leaves", &GreensFunction3DRadAbs::leaves )
        .def( "leavea", &GreensFunction3DRadAbs::leavea )

        .def( "p_0", &GreensFunction3DRadAbs::p_0 )
        .def( "p_int_r", &GreensFunction3DRadAbs::p_int_r )
        .def( "p_int_r", &GreensFunction3DRadAbs::p_int_r )
        .def( "p_theta", &GreensFunction3DRadAbs::p_theta )
        .def( "ip_theta", &GreensFunction3DRadAbs::ip_theta )
        .def( "idp_theta", &GreensFunction3DRadAbs::idp_theta )

        .def( "f_alpha0", &GreensFunction3DRadAbs::f_alpha0 )
        .def( "alpha0_i", &GreensFunction3DRadAbs::alpha0_i )
        .def( "f_alpha", &GreensFunction3DRadAbs::f_alpha )
        .def( "f_alpha_aux", &GreensFunction3DRadAbs::f_alpha_aux )

        .def( "p_survival_i_exp", &GreensFunction3DRadAbs::p_survival_i_exp )
        .def( "p_survival_i_alpha", &GreensFunction3DRadAbs::p_survival_i_alpha )

        //.def( "guess_maxi", &GreensFunction3DRadAbs::guess_maxi )

        .def( "dump", &GreensFunction3DRadAbs::dump )

//        .def( "alpha_i", &GreensFunction3DRadAbs::alpha_i )
        ;

    class_<GreensFunction3DAbs>("GreensFunction3DAbs",
                                init<Real, Real, Real>()) 
        .def( "geta", &GreensFunction3DAbs::geta )
        .def( "getD", &GreensFunction3DAbs::getD )
        .def( "drawTime", &GreensFunction3DAbs::drawTime )
        .def( "drawR", &GreensFunction3DAbs::drawR )
        .def( "drawTheta", 
              &GreensFunction3DAbs::drawTheta )

        .def( "p_survival", 
              &GreensFunction3DAbs::p_survival )
        .def( "dp_survival", 
              &GreensFunction3DAbs::dp_survival )
        .def( "p_int_r", &GreensFunction3DAbs::p_int_r )
        .def( "p_theta", &GreensFunction3DAbs::p_theta )
        .def( "ip_theta", &GreensFunction3DAbs::ip_theta )
        .def( "idp_theta", 
              &GreensFunction3DAbs::idp_theta )

        .def( "dump", &GreensFunction3DAbs::dump )
        ;
}
 </xmp> 
<h3> Logger.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <string>
#include <map>
#include <utility>
#include <cstdio>
#include <functional>
#include <boost/regex.hpp>
#include <boost/foreach.hpp>
#include <boost/type_traits/remove_pointer.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/ptr_container/ptr_map.hpp>
#include <boost/bind.hpp>
#include "Logger.hpp"
#include "ConsoleAppender.hpp"
#include "utils/pair.hpp"
#include "utils/fun_composition.hpp"
#include "utils/fun_wrappers.hpp"
#include "utils/assoc_container_traits.hpp"
#include "utils/map_adapter.hpp"

struct map_adapter_handler
{
    template<typename Tadapter_>
    void destroy(Tadapter_& cntnr) const
    {
        std::for_each(boost::begin(cntnr), boost::end(cntnr),
                compose_unary(
                    delete_ptr<
                        typename boost::remove_pointer<
                            typename Tadapter_::mapped_type>::type>(),
                    select_second<typename Tadapter_::value_type>()));
    }

    template<typename Tadapter_, typename Titer_>
    void insert(Titer_ const& b, Titer_ const& e) const
    {
    }

    template<typename Tadapter_>
    void insert(typename Tadapter_::value_type const& val) const
    {
    }
};

class LoggerManagerRegistry
{
private:
    typedef std::pair<boost::regex, boost::shared_ptr<LoggerManager> > entry_type;
public:
    void register_logger_manager(char const* logger_name_pattern,
                                 boost::shared_ptr<LoggerManager> const& manager)
    {
        managers_.push_back(entry_type(boost::regex(logger_name_pattern), manager));
    }

    boost::shared_ptr<LoggerManager>
    get_default_logger_manager() const
    {
        return default_manager_;
    }

    boost::shared_ptr<LoggerManager>
    operator()(char const* logger_name) const
    {
        if (!logger_name)
            return default_manager_;


        char const* const logger_name_end(logger_name + std::strlen(logger_name));
        BOOST_FOREACH (entry_type const& i, managers_)
        {
            if (boost::regex_match(logger_name, logger_name_end, i.first))
                return i.second;
        }

        BOOST_ASSERT(default_manager_.get());
        return default_manager_;
    }

    LoggerManagerRegistry(): default_manager_(new LoggerManager("default"))
    {
        default_manager_->add_appender(boost::shared_ptr<LogAppender>(new ConsoleAppender()));
    }

private:
    std::vector<entry_type> managers_;
    boost::shared_ptr<LoggerManager> default_manager_;
};

static LoggerManagerRegistry registry;
    
void LoggerManager::register_logger_manager(
        char const* logger_name_pattern,
        boost::shared_ptr<LoggerManager> const& manager)
{
    registry.register_logger_manager(logger_name_pattern, manager);
}

boost::shared_ptr<LoggerManager> LoggerManager::get_logger_manager(char const* logger_name_pattern)
{
    return registry(logger_name_pattern);
}

boost::shared_ptr<LoggerManager> Logger::manager() const
{
    const_cast<Logger*>(this)->ensure_initialized();
    return manager_;
}

Logger& Logger::get_logger(char const* name)
{
    typedef map_adapter<std::map<std::string, Logger*>, map_adapter_handler> loggers_type;
    static map_adapter_handler hdlr;
    static loggers_type loggers(hdlr);
    std::string _name(name);
    std::pair<loggers_type::iterator, bool> i(
            loggers.insert(loggers_type::value_type(_name, 0)));

    if (i.second)
    {
        Logger* const log(new Logger(registry, name));
        (*i.first).second = log;
    }

    return *(*i.first).second;
}


char const* Logger::stringize_error_level(enum level lv)
{
    static char const* names[] = {
        "OFF",
        "DEBUG",
        "INFO",
        "WARN",
        "ERROR",
        "FATAL"
    };
    return static_cast<std::size_t>(lv) >= sizeof(names) / sizeof(*names) ? "???": names[lv];
}

Logger::~Logger()
{
}

struct invoke_appender
{
    void operator()(boost::shared_ptr<LogAppender> const& appender) const
    {
        const char* chunks[] = { formatted_msg, NULL };
        (*appender)(level, time, name, chunks);
    }

    invoke_appender(enum Logger::level level, boost::posix_time::ptime const& time,
                    const char* name, char const *formatted_msg)
        : level(level), time(time), name(name),
          formatted_msg(formatted_msg) {}

    enum Logger::level const level;
    boost::posix_time::ptime const time;
    char const* const name;
    char const* const formatted_msg;
};

void Logger::level(enum Logger::level level)
{
    ensure_initialized();
    level_ = level;
}

enum Logger::level Logger::level() const
{
    const_cast<Logger*>(this)->ensure_initialized();
    return level_;
}

void Logger::logv(enum level lv, char const* format, va_list ap)
{
    using namespace boost::posix_time;

    ensure_initialized();

    if (lv < level_)
        return;

    char buf[1024];
    std::vsnprintf(buf, sizeof(buf), format, ap);

    std::for_each(appenders_.begin(), appenders_.end(),
            invoke_appender(lv, second_clock::local_time(), name_.c_str(),
                            buf));
}

void Logger::flush()
{
    ensure_initialized();

    std::for_each(appenders_.begin(), appenders_.end(),
            boost::bind(&LogAppender::flush, _1));
}

inline void Logger::ensure_initialized()
{
    if (!manager_)
    {
        boost::shared_ptr<LoggerManager> manager(registry_(name_.c_str()));
        std::vector<boost::shared_ptr<LogAppender> > appenders(manager->appenders());
        level_ = manager->level();
        appenders_.swap(appenders);
        manager->manage(this);
        manager_ = manager;
    }
}

Logger::Logger(LoggerManagerRegistry const& registry, char const* name)
        : registry_(registry), name_(name), manager_() {}

void LoggerManager::level(enum Logger::level level)
{
    /* synchronized { */
    level_ = level;
    std::for_each(managed_loggers_.begin(), managed_loggers_.end(),
                  boost::bind(&Logger::level, _1, level));
    /* } */
}

enum Logger::level LoggerManager::level() const
{
    return level_;
}

char const* LoggerManager::name() const
{
    return name_.c_str();
}

std::vector<boost::shared_ptr<LogAppender> > const& LoggerManager::appenders() const
{
    /* synchronized() { */
    return appenders_;
    /* } */
}

void LoggerManager::add_appender(boost::shared_ptr<LogAppender> const& appender)
{
    /* synchronized() { */
    appenders_.push_back(appender);
    /* } */
}

LoggerManager::LoggerManager(char const* name, enum Logger::level level)
    : name_(name), level_(level) {}

void LoggerManager::manage(Logger* logger)
{
    /* synchronized { */
    managed_loggers_.insert(logger);
    /* }} */
}

LogAppender::~LogAppender() {}
 </xmp> 
<h3> Model.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <algorithm>
#include <boost/type_traits/remove_pointer.hpp>
#include <boost/lexical_cast.hpp>

#include "utils/fun_wrappers.hpp"

#include "SpeciesType.hpp"
#include "NetworkRules.hpp"
#include "BasicNetworkRulesImpl.hpp"
#include "Model.hpp"

Model::Model(): network_rules_(new BasicNetworkRulesImpl())
{
}

Model::~Model()
{
}

void Model::add_species_type(boost::shared_ptr<species_type_type> const& species)
{
    species->bind_to_model(this, species_type_id_generator_());
    species_type_map_.insert(std::make_pair(species->id(), species));
}

boost::shared_ptr<Model::species_type_type> Model::get_species_type_by_id(species_id_type const& id) const
{
    species_type_map_type::const_iterator i(species_type_map_.find(id));
    if (species_type_map_.end() == i)
    {
        throw not_found(boost::lexical_cast<std::string>(id));
    }

    return (*i).second;
}

Model::species_type_range Model::get_species_types() const
{
    return species_type_range(
        species_type_iterator(species_type_map_.begin(), species_second_selector_type()),
        species_type_iterator(species_type_map_.end(), species_second_selector_type()));
}

std::string const& Model::operator[](std::string const& name) const
{
    string_map_type::const_iterator i(attrs_.find(name));
    if (i == attrs_.end())
        throw not_found((boost::format("key %s not found") % name).str());
    return (*i).second;
}

std::string& Model::operator[](std::string const& name)
{
    return attrs_[name];
}
 </xmp> 
<h3> NetworkRules.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "NetworkRules.hpp"

NetworkRules::~NetworkRules()
{
}
 </xmp> 
<h3> ParticleModel.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <algorithm>
#include <boost/type_traits/remove_pointer.hpp>
#include <boost/lexical_cast.hpp>

#include "utils/fun_wrappers.hpp"

#include "ParticleModel.hpp"

ParticleModel::ParticleModel()
{
}

ParticleModel::~ParticleModel()
{
}

void ParticleModel::add_structure_type(boost::shared_ptr<structure_type_type> const& structure)
{
    std::pair<structure_type_map_type::iterator, bool> r(
        structure_type_map_.insert(std::make_pair(structure->id(), structure)));
    if (!r.second)
    {
        throw already_exists(
            (boost::format("structure id \"%s\" is already used by %s") %
                structure->id() %
                boost::lexical_cast<std::string>(*(*(r.first)).second)).str());
    }
    structure->bind_to_model(this, structure->id());
}

boost::shared_ptr<ParticleModel::structure_type_type> ParticleModel::get_structure_type_by_id(structure_id_type const& id) const
{
    structure_type_map_type::const_iterator i(structure_type_map_.find(id));
    if (structure_type_map_.end() == i)
    {
        throw not_found(boost::lexical_cast<std::string>(id));
    }

    return (*i).second;
}

ParticleModel::structure_type_range ParticleModel::get_structure_types() const
{
    return structure_type_range(
        structure_type_iterator(structure_type_map_.begin(), structure_second_selector_type()),
        structure_type_iterator(structure_type_map_.end(), structure_second_selector_type()));
}
 </xmp> 
<h3> pyGFRD.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <exception>
#include <stdexcept>

//#include <gsl/gsl_math.h>
#include <gsl/gsl_errno.h>

#include <boost/lexical_cast.hpp>
#include <boost/python.hpp>
#include <boost/python/tuple.hpp>
#include <boost/python/module.hpp>
#include <boost/python/refcount.hpp>
#include <boost/python/return_value_policy.hpp>
#include <boost/python/reference_existing_object.hpp>
#include <boost/python/return_by_value.hpp>
#include <boost/python/wrapper.hpp>
#include <boost/python/converter/object_manager.hpp>

#include <numpy/arrayobject.h>

#include "utils.hpp"
#include "peer/utils.hpp"
#include "peer/converters/tuple.hpp"
#include "peer/numpy/wrapped_multi_array.hpp"
#include "peer/numpy/scalar_converters.hpp"

#include "binding/bd_propagator_class.hpp"
#include "binding/binding_common.hpp"
#include "binding/box_class.hpp"
#include "binding/cylinder_class.hpp"
#include "binding/domain_id_class.hpp"
#include "binding/domain_classes.hpp"
#include "binding/egfrd_simulator_classes.hpp"
#include "binding/event_classes.hpp"
#include "binding/exception_classes.hpp"
#include "binding/matrix_space_classes.hpp"
#include "binding/model_class.hpp"
#include "binding/module_functions.hpp"
#include "binding/multi_particle_container_class.hpp"
#include "binding/network_rules_class.hpp"
#include "binding/network_rules_wrapper_class.hpp"
#include "binding/particle_class.hpp"
#include "binding/particle_container_class.hpp"
#include "binding/particle_id_class.hpp"
#include "binding/particle_model_class.hpp"
#include "binding/particle_simulator_classes.hpp"
#include "binding/plane_class.hpp"
#include "binding/position_converters.hpp"
#include "binding/python_logger_classes.hpp"
#include "binding/random_number_generator_class.hpp"
#include "binding/reaction_record_classes.hpp"
#include "binding/shape_converters.hpp"
#include "binding/shell_classes.hpp"
#include "binding/shell_id_class.hpp"
#include "binding/species_id_class.hpp"
#include "binding/species_type_class.hpp"
#include "binding/sphere_class.hpp"
#include "binding/structure_classes.hpp"
#include "binding/transaction_classes.hpp"
#include "binding/world_class.hpp"

namespace b = binding;

BOOST_PYTHON_MODULE(_gfrd)
{
    using namespace boost::python;

    import_array();

    // GSL error handler: is this the best place for this?
    gsl_set_error_handler( &gsl_error_handler );

    peer::util::register_std_exception_translator();
peer::util::register_exception_translator<PyExc_IndexError, std::out_of_range>();

    b::register_model_class();
    b::register_bd_propagator_class();
    b::register_box_class();
    b::register_domain_id_class();
    b::register_domain_classes();
    b::register_exception_classes();
    b::register_spherical_shell_container_class();
    b::register_plane_class();
    b::register_cylinder_class();
    b::register_cylindrical_shell_container_class();
    b::register_network_rules_class();
    b::register_network_rules_wrapper_class();
    b::register_particle_class();
    b::register_particle_id_class();
    b::register_particle_model_class();
    b::register_position_converters();
    b::register_event_class();
    b::register_python_event_class();
    b::register_event_scheduler_class();
    b::register_random_number_generator_class();
    b::register_sphere_class();
    b::register_sphere_converters();
    b::register_spherical_shell_class();
    b::register_cylindrical_shell_class();
    b::register_shell_id_class();
    b::register_species_id_class();
    b::register_species_type_class();
    b::register_particle_container_class();
    b::register_multi_particle_container_class();
    b::register_transaction_classes();
    b::register_world_class();
    b::register_structure_classes();
    b::register_module_functions();
    b::register_reaction_record_classes();
    b::register_particle_simulator_classes();
    b::register_egfrd_simulator_classes();
    b::register_python_logger_classes();

    peer::util::register_seq_wrapped_multi_array_converter<b::Length>();
    peer::util::register_ndarray_wrapped_multi_array_converter<b::Length, 2>();
    peer::util::register_ndarray_wrapped_multi_array_converter<b::Length, 3>();

    peer::util::register_scalar_to_native_converters();
}
 </xmp> 
<h3> SpeciesType.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "SpeciesType.hpp"

SpeciesType::identifier_type const& SpeciesType::id() const
{
    if (!model_)
    {
        throw illegal_state("not bound to Model");
    }
    return id_;
}
    
std::string const& SpeciesType::operator[](std::string const& name) const
{
    string_map_type::const_iterator i(attrs_.find(name));
    if (i == attrs_.end())
        throw not_found((boost::format("key %s not found") % name).str());
    return (*i).second;
}

std::string& SpeciesType::operator[](std::string const& name)
{
    return attrs_[name];
}

SpeciesType::attributes_range SpeciesType::attributes() const
{
    return attributes_range(attrs_.begin(), attrs_.end());
}
 </xmp> 
<h3> SphericalBesselGenerator.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <cassert>

#include "compat.h"
#include "SphericalBesselTable.hpp"
#include "SphericalBesselGenerator.hpp"


static inline double hermite_interp(double x, 
                                    double x0, double dx, 
                                    double const* y_array)
{
    const double hinv = 1.0 / dx;

    const size_t i = static_cast<size_t>((x - x0 ) * hinv);
    const size_t index = i * 2;

    const double x_lo = (x - x0) * hinv - i;
    const double x_hi =  1.0 - x_lo;

    const double y_lo = y_array[index];
    const double ydot_lo = y_array[index + 1] * dx;
    const double y_hi = y_array[index + 2];
    const double ydot_hi = y_array[index + 3] * dx;
    
    return x_hi * x_hi * (y_lo + x_lo * (2 * y_lo + ydot_lo)) 
        + x_lo * x_lo * (y_hi + x_hi * (2 * y_hi - ydot_hi));
}

inline static Real interp(Real x_start, Real delta_x,
                          Real const* yTable, Real x)
{
    return hermite_interp(x, x_start, delta_x, yTable);
}

static Real _j(UnsignedInteger n, Real z)
{
    return gsl_sf_bessel_jl(n, z);
}

static Real _y(UnsignedInteger n, Real z)
{
    return gsl_sf_bessel_yl(n, z);
}

SphericalBesselGenerator const& SphericalBesselGenerator::instance()
{
    static const SphericalBesselGenerator sphericalBesselGenerator;
    return sphericalBesselGenerator;
}



UnsignedInteger SphericalBesselGenerator::getMinNJ()
{
    return sb_table::sj_table_min;
}

UnsignedInteger SphericalBesselGenerator::getMinNY()
{
    return sb_table::sy_table_min;
}

UnsignedInteger SphericalBesselGenerator::getMaxNJ()
{
    return sb_table::sj_table_max;
}

UnsignedInteger SphericalBesselGenerator::getMaxNY()
{
    return sb_table::sy_table_max;
}

static sb_table::Table const* getSJTable(UnsignedInteger n)
{
    return sb_table::sj_table[n];
}


static sb_table::Table const* getSYTable(UnsignedInteger n)
{
    return sb_table::sy_table[n];
}

static inline Real _j_table(UnsignedInteger n, Real z)
{
    sb_table::Table const* tablen(getSJTable(n));

    return interp(tablen->x_start, tablen->delta_x, tablen->y, z);
}

static inline Real _y_table(UnsignedInteger n, Real z)
{
    sb_table::Table const* tablen(getSYTable(n));

    return interp(tablen->x_start, tablen->delta_x, tablen->y, z);
}

static inline Real _j_smalln(UnsignedInteger n, Real z)
{
    assert(n <= 3 && n >= 0);

    if(n == 0)
    {
        if(z != 0)
        {
            return std::sin(z) / z;
        }
        else
        {
            return 1.0;
        }
    }

    if(z == 0.0)
    {
        return 0.0;
    }

    Real sin_z;
    Real cos_z;
    sincos(z, &sin_z, &cos_z);

    const Real z_r(1. / z);
        
    if(n == 1)
    {
        return (sin_z * z_r - cos_z) * z_r;
    }
    else if(n == 2)
    {
        const Real _3_zsq(3. * z_r * z_r);
        return (_3_zsq - 1) * sin_z * z_r - _3_zsq * cos_z;
    }
    else //if(n == 3)
    {
        const Real _15_zsq(15. * z_r * z_r);
        return ((_15_zsq - 6.) * sin_z * z_r - 
                (_15_zsq - 1) * cos_z) * z_r;
    }

}

static inline Real _y_smalln(UnsignedInteger n, Real z)
{
    assert(n <= 2 && n >= 0);

    if(n == 0)
    {
        return - std::cos(z) / z;
    }

    Real sin_z;
    Real cos_z;
    sincos(z, &sin_z, &cos_z);

    const Real z_r(1. / z);
        
    if(n == 1)
    {
        return - (cos_z * z_r + sin_z) * z_r;
    }
    else //if(n == 2)
    {
        const Real _3_zsq(3. * z_r * z_r);
        return (1 - _3_zsq) * cos_z * z_r - _3_zsq * sin_z;
    }
}



Real SphericalBesselGenerator::j(UnsignedInteger n, Real z) const
{
    if(n <= 3)
    {
        return _j_smalln(n, z);
    }

    if(n > getMaxNJ())
    {
        return _j(n, z);
    }
    
    const sb_table::Table* table(getSJTable(n));
    assert(table != 0);

    const Real minz(table->x_start + table->delta_x * 3);
    const Real maxz(table->x_start + table->delta_x * (table->N-3));
    
    if(z >= minz && z < maxz)
    {
        return _j_table(n, z);
    }
    else
    {
        return _j(n, z);
    }
}

Real SphericalBesselGenerator::y(const UnsignedInteger n, const Real z) const
{
    if(n <= 2)
    {
        return _y_smalln(n, z);
    }

    if(n > getMaxNY())
    {
        return _y(n, z);
    }
    
    const sb_table::Table* table(getSYTable(n));
    assert(table != 0);
    
    const Real minz(table->x_start + table->delta_x * 3);
    const Real maxz(table->x_start + table->delta_x * (table->N-3));
    
    if(z >= minz && z < maxz)
    {
        return _y_table(n, z);
    }
    else
    {
        return _y(n, z);
    }
}

 </xmp> 
<h3> StructureType.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include "StructureType.hpp"

StructureType::identifier_type const& StructureType::id() const
{
    if (!model_)
    {
        throw illegal_state("not bound to Model");
    }
    return id_;
}
    
std::string const& StructureType::operator[](std::string const& name) const
{
    string_map_type::const_iterator i(attrs_.find(name));
    if (i == attrs_.end())
        throw not_found((boost::format("key %s not found") % name).str());
    return (*i).second;
}

std::string& StructureType::operator[](std::string const& name)
{
    return attrs_[name];
}

StructureType::attributes_range StructureType::attributes() const
{
    return attributes_range(attrs_.begin(), attrs_.end());
}
 </xmp> 
<h3> utils.cpp </h3> <xmp>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <stdexcept>
#include <string>
#include <boost/lexical_cast.hpp>
#include "utils.hpp"

// GSL error handler.
void gsl_error_handler( char const* reason, char const* file, int line, int gsl_errno )
{
    throw std::runtime_error( std::string( "GSL error: " ) +
                              std::string( reason ) +
                              std::string( " at " ) +
                              std::string( file ) + std::string( ":" ) +
                              boost::lexical_cast< std::string >( line ) );
}
 </xmp> 
<h3> abstract_set.hpp </h3> <xmp>

#ifndef ABSTRACT_SET_HPP
#define ABSTRACT_SET_HPP

#include <set>
#include <map>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/value_type.hpp>
#include <algorithm>

template<typename T_>
struct collection_value: public boost::range_value<T_>
{
};

template<typename T_>
struct inserter: public std::unary_function<typename collection_value<T_>::type, bool>
{
    typedef T_ set_type;
    typedef typename collection_value<set_type>::type argument_type;

    inserter(set_type& set): set_(set) {}

    bool operator()(argument_type const& v)
    {
        set_.push_back(v); 
        return true;
    }

private:
    set_type& set_;
};

template<typename Tval_, typename Tcompare_, typename Talloc_>
struct inserter<std::set<Tval_, Tcompare_, Talloc_> >: public std::unary_function<typename collection_value<std::set<Tval_, Tcompare_, Talloc_> >::type, bool>
{
    typedef std::set<Tval_, Tcompare_, Talloc_> set_type;
    typedef typename collection_value<set_type>::type argument_type;

    inserter(set_type& set): set_(set) {}

    bool operator()(argument_type const& v)
    {
        return set_.insert(v).second; 
    }

private:
    set_type& set_;
};

template<typename Tkey_, typename Tval_, typename Tcompare_, typename Talloc_>
struct inserter<std::map<Tkey_, Tval_, Tcompare_, Talloc_> >: public std::unary_function<typename collection_value<std::map<Tkey_, Tval_, Tcompare_, Talloc_> >::type, bool>
{
    typedef std::map<Tkey_, Tval_, Tcompare_, Talloc_> set_type;
    typedef typename collection_value<set_type>::type argument_type;

    inserter(set_type& set): set_(set) {}

    bool operator()(argument_type const& v)
    {
        return set_.insert(v).second; 
    }

private:
    set_type& set_;
};

template<typename T_>
inline bool contains(T_ const& s, typename collection_value<T_>::type const& v)
{
    typename boost::range_const_iterator<T_>::type e(boost::end(s));
    return e != std::find(boost::begin(s), e, v);
}

template<typename T_>
inline bool insert(T_& s, typename collection_value<T_>::type const& v)
{
    return inserter<T_>(s)(v);
}

template<typename T1, typename T2, typename Tr>
inline void difference(T1 const& r1, T2 const& r2, Tr const& result)
{
    std::set_difference(
        boost::begin(r1), boost::end(r1),
        boost::begin(r2), boost::end(r2),
        result);
}

#endif /* ABSTRACT_SET_HPP */
 </xmp> 
<h3> AnalyticalPair.hpp </h3> <xmp>

#ifndef ANALYTICAL_PAIR_HPP
#define ANALYTICAL_PAIR_HPP

#include <cmath>
#include <boost/array.hpp>
#include "Pair.hpp"
#include "AnalyticalSingle.hpp"

template<typename Ttraits_, typename Tshell_>
class AnalyticalPair: public Pair<Ttraits_>
{
public:
    typedef Pair<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::world_type::traits_type::D_type D_type;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename network_rules_type::reaction_rule_type reaction_rule_type;
    typedef typename network_rules_type::reaction_rule_vector reaction_rule_vector;
    typedef Tshell_ shell_type;
    typedef std::pair<const shell_id_type, shell_type> shell_id_pair;

public:
    virtual ~AnalyticalPair() {}

    AnalyticalPair(identifier_type const& id,
                   particle_id_pair const& p0, particle_id_pair const& p1,
                   shell_id_pair const& shell,
                   position_type const& iv,
                   reaction_rule_vector const& reactions)
        : base_type(id, p0, p1), shell_(shell), iv_(iv), reactions_(reactions)
    {
        // determine a_r and a_R
        {
            D_type D0(base_type::particles_[0].second.D());
            D_type D1(base_type::particles_[1].second.D());
            length_type R0(base_type::particles_[0].second.radius());
            length_type R1(base_type::particles_[1].second.radius());
            const length_type sigma(R0 + R1);
            const length_type D_tot(D0 + D1);
            const length_type D_geom(std::sqrt(D0 * D1));
            const length_type shell_size(shape(shell.second).radius() / traits_type::SAFETY);
            const length_type r0(this->r0());
            BOOST_ASSERT(r0 >= sigma);
            if (((D_geom - D0) * r0) / D_tot + shell_size
                + std::sqrt(D0 / D1) * (R1 - shell_size) - R0 < 0)
            {
                std::swap(D0, D1);
                std::swap(R0, R1);
            }
            a_R_ = D_geom * (D0 * (shell_size - R1)
                              + D1 * (shell_size - r0 - R1)) /
                   (D1 * D1 + D1 * D0 + D_geom * D_tot);
            a_r_ = (D_geom * r0 + D_tot * (shell_size - R1)) / (D1 + D_geom);
            BOOST_ASSERT(a_r_ > 0);
            BOOST_ASSERT(a_r_ > r0);
            BOOST_ASSERT(a_R_ > 0 || (a_R_ == 0. && (D1 == 0. || D0 == 0.)));
            BOOST_ASSERT(a_R_ + a_r_ * D1 / D_tot + R1 >=
                         a_R_ + a_r_ * D0 / D_tot + R0);
            BOOST_ASSERT(std::abs(a_R_ + a_r_ * D1 / D_tot + R1 - shell_size) <
                         1e-12 * shell_size);
        }
    }

    shell_id_pair const& shell() const
    {
        return shell_;
    }

    shell_id_pair& shell()
    {
        return shell_;
    }

    position_type const& iv() const
    {
        return iv_;
    }

    length_type r0() const
    {
        return length(iv_);
    }

    length_type const& a_R() const
    {
        return a_R_;
    }

    length_type const& a_r() const
    {
        return a_r_;
    }

    length_type sigma() const
    {
        return base_type::particles_[0].second.radius()
               + base_type::particles_[1].second.radius();
    }

    D_type D_tot() const
    {
        return base_type::particles_[0].second.D()
               + base_type::particles_[1].second.D();
    }

    D_type D_geom() const
    {
        return std::sqrt(
            base_type::particles_[0].second.D() *
            base_type::particles_[1].second.D());
    }

    D_type D_R() const
    {
        return base_type::particles_[0].second.D() *
               base_type::particles_[1].second.D() / D_tot();
    }

    virtual position_type const& position() const
    {
        return shape_position(shape(shell_.second));
    }

    virtual position_type& position()
    {
        return shape_position(shape(shell_.second));
    }

    virtual length_type const& size() const
    {
        return shape_size(shape(shell_.second));
    }

    virtual length_type& size()
    {
        return shape_size(shape(shell_.second));
    }

    virtual char const* type_name() const
    {
        return retrieve_domain_type_name(*this);
    }

    reaction_rule_vector const& reactions() const
    {
        return reactions_;
    }

    virtual typename Domain<traits_type>::size_type num_shells() const
    {
        return 1;
    }

    virtual typename Domain<traits_type>::size_type multiplicity() const
    {
        return 2;
    }

    virtual void accept(ImmutativeDomainVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeDomainVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    virtual std::string as_string() const
    {
        return (boost::format(
            "%s(id=%s, event=%s, last_time=%g, dt=%g, particles=[(%s:%s), (%s:%s)], iv=%s, shell=(%s:%s))") %
            type_name() %
            boost::lexical_cast<std::string>(base_type::id_) %
            boost::lexical_cast<std::string>(base_type::event_.first) %
            base_type::last_time_ % base_type::dt_ %
            boost::lexical_cast<std::string>(base_type::particles()[0].first) %
            boost::lexical_cast<std::string>(base_type::particles()[0].second) %
            boost::lexical_cast<std::string>(base_type::particles()[1].first) %
            boost::lexical_cast<std::string>(base_type::particles()[1].second) %
            boost::lexical_cast<std::string>(iv_) %
            boost::lexical_cast<std::string>(shell_.first) %
            boost::lexical_cast<std::string>(shell_.second)).str();
    }
protected:
    shell_id_pair shell_;
    position_type const iv_;
    reaction_rule_vector const& reactions_;
    mutable length_type a_R_;
    mutable length_type a_r_;
};

#endif /* ANALYTICAL_PAIR_HPP */
 </xmp> 
<h3> AnalyticalSingle.hpp </h3> <xmp>

#ifndef ANALYTICAL_SINGLE_HPP
#define ANALYTICAL_SINGLE_HPP

#include "Single.hpp"

template<typename Ttraits_, typename Tshell_>
class AnalyticalSingle: public Single<Ttraits_>
{
public:
    typedef Single<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef Tshell_ shell_type;
    typedef std::pair<const shell_id_type, shell_type> shell_id_pair;
    typedef typename network_rules_type::reaction_rule_vector reaction_rule_vector;
    typedef typename traits_type::rate_type rate_type;

public:
    virtual ~AnalyticalSingle() {}

    AnalyticalSingle(identifier_type const& id,
                     particle_id_pair const& particle,
                     shell_id_pair const& shell)
        : base_type(id, particle), shell_(shell) {}

    shell_id_pair const& shell() const
    {
        return shell_;
    }

    shell_id_pair& shell()
    {
        return shell_;
    }

    length_type mobility_radius() const
    {
        return shape_size(shape(shell_.second)) - base_type::particle().second.radius();
    }

    virtual char const* type_name() const
    {
        return retrieve_domain_type_name(*this);
    }

    virtual position_type const& position() const
    {
        return shape_position(shape(shell_.second));
    }

    virtual position_type& position()
    {
        return shape_position(shape(shell_.second));
    }

    virtual length_type const& size() const
    {
        return shape_size(shape(shell_.second));
    }

    virtual length_type& size()
    {
        return shape_size(shape(shell_.second));
    }

    virtual typename Domain<traits_type>::size_type num_shells() const
    {
        return 1;
    }

    virtual typename Domain<traits_type>::size_type multiplicity() const
    {
        return 1;
    }

    virtual void accept(ImmutativeDomainVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeDomainVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    virtual std::string as_string() const
    {
        return (boost::format(
            "%s(id=%s, event=%s, last_time=%g, dt=%g, particle=(%s:%s), shell=(%d:%s))") %
            type_name() %
            boost::lexical_cast<std::string>(base_type::id_) %
            boost::lexical_cast<std::string>(base_type::event_.first) %
            base_type::last_time_ % base_type::dt_ %
            boost::lexical_cast<std::string>(base_type::particle().first) %
            boost::lexical_cast<std::string>(base_type::particle().second) %
            boost::lexical_cast<std::string>(shell_.first) %
            boost::lexical_cast<std::string>(shell_.second)).str();
    }

protected:
    shell_id_pair shell_;
};

#endif /* ANALYTICAL_SINGLE_HPP */
 </xmp> 
<h3> BasicNetworkRulesImpl.hpp </h3> <xmp>

#ifndef BASIC_NETWORK_RULES_IMPL_HPP
#define BASIC_NETWORK_RULES_IMPL_HPP

#include <map>
#include <set>

#include "NetworkRules.hpp"
#include "ReactionRule.hpp"

class BasicNetworkRulesImpl: public NetworkRules
{
    typedef std::set<ReactionRule> reaction_rule_set;
    typedef std::map<ReactionRule::Reactants, reaction_rule_set> reaction_rules_map;

public:
    virtual void add_reaction_rule(ReactionRule const&);
    virtual void remove_reaction_rule(ReactionRule const&);

    virtual reaction_rule_generator* query_reaction_rule(SpeciesTypeID const& r1) const;

    virtual reaction_rule_generator* query_reaction_rule(SpeciesTypeID const& r1, SpeciesTypeID const& r2) const;

    virtual ~BasicNetworkRulesImpl();

    BasicNetworkRulesImpl();

private:
    reaction_rules_map reaction_rules_map_;
};

#endif /* BASIC_NETWORK_RULES_IMPL_HPP */
 </xmp> 
<h3> BasicReactionRecorderImpl.hpp </h3> <xmp>

#ifndef BASIC_REACTION_RECORDER_IMPL_HPP
#define BASIC_REACTION_RECORDER_IMPL_HPP

#include <vector>
#include "ReactionRecorder.hpp"

template<typename Trr_>
class BasicReactionRecorderImpl: public ReactionRecorder<Trr_>
{
public:
    typedef Trr_ reaction_record_type;

public:
    virtual void operator()(reaction_record_type const& rec)
    {
        records_.push_back(rec);
    }


protected:
    std::vector<reaction_record_type> records_;
};

#endif /* BASIC_REACTION_RECORDER_IMPL_HPP */
 </xmp> 
<h3> BDPropagator.hpp </h3> <xmp>

#ifndef BD_PROPAGATOR_HPP
#define BD_PROPAGATOR_HPP

#include <algorithm>
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/range/size.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/scoped_ptr.hpp>
#include "Defs.hpp"
#include "generator.hpp"
#include "exceptions.hpp"
#include "freeFunctions.hpp"
#include "utils.hpp"
#include "utils/random.hpp"
#include "utils/get_default_impl.hpp"
#include "Logger.hpp"

template<typename Ttraits_>
class BDPropagator
{
public:
    typedef Ttraits_ traits_type;
    typedef typename Ttraits_::world_type::particle_container_type particle_container_type;
    typedef typename particle_container_type::species_id_type species_id_type;
    typedef typename particle_container_type::position_type position_type;
    typedef typename particle_container_type::particle_shape_type particle_shape_type;
    typedef typename particle_container_type::species_type species_type;
    typedef typename particle_container_type::length_type length_type;
    typedef typename particle_container_type::particle_id_type particle_id_type;
    typedef typename particle_container_type::particle_type particle_type;
    typedef typename particle_container_type::particle_id_pair particle_id_pair;
    typedef std::vector<particle_id_type> particle_id_vector_type;
    typedef typename particle_container_type::particle_id_pair_generator particle_id_pair_generator;
    typedef typename particle_container_type::particle_id_pair_and_distance particle_id_pair_and_distance;
    typedef typename particle_container_type::particle_id_pair_and_distance_list particle_id_pair_and_distance_list;
    typedef typename particle_container_type::structure_type structure_type;
    typedef typename traits_type::world_type::traits_type::rng_type rng_type;
    typedef typename traits_type::time_type time_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename network_rules_type::reaction_rules reaction_rules;
    typedef typename network_rules_type::reaction_rule_type reaction_rule_type;
    typedef typename traits_type::reaction_record_type reaction_record_type;
    typedef typename traits_type::reaction_recorder_type reaction_recorder_type;

public:
    template<typename Trange_>
    BDPropagator(
        particle_container_type& tx, network_rules_type const& rules,
        rng_type& rng, time_type dt, int max_retry_count,
        reaction_recorder_type* rrec, Trange_ const& particles)
        : tx_(tx), rules_(rules), rng_(rng), dt_(dt),
          max_retry_count_(max_retry_count), rrec_(rrec),
          queue_(), rejected_move_count_(0)
    {
        call_with_size_if_randomly_accessible(
            boost::bind(&particle_id_vector_type::reserve, &queue_, _1),
            particles);
        for (typename boost::range_const_iterator<Trange_>::type
                i(boost::begin(particles)),
                e(boost::end(particles)); i != e; ++i)
        {
            queue_.push_back(*i);
        }
        shuffle(rng, queue_);
    }

    bool operator()()
    {
        if (queue_.empty())
            return false;

        particle_id_type pid(queue_.back());
        queue_.pop_back();
        particle_id_pair pp(tx_.get_particle(pid));

        LOG_DEBUG(("propagating particle %s", boost::lexical_cast<std::string>(pp.first).c_str()));

        try
        {
            if (attempt_reaction(pp))
                return true;
        }
        catch (propagation_error const& reason)
        {
            log_.info("first-order reaction rejected (reason: %s)", reason.what());
            ++rejected_move_count_;
            return true;
        }

        const species_type species(tx_.get_species(pp.second.sid()));
        if (species.D() == 0.)
            return true;

        position_type const displacement(drawR_free(species));
        position_type const new_pos(
            tx_.apply_boundary(
                add(pp.second.position(), displacement)));

        particle_id_pair particle_to_update(
                pp.first, particle_type(species.id(),
                    particle_shape_type(new_pos, species.radius()),
                    species.D()));
        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(
            tx_.check_overlap(particle_to_update.second.shape(),
                              particle_to_update.first));
        switch (overlapped ? overlapped->size(): 0)
        {
        case 0:
            break;

        case 1:
            {
                particle_id_pair_and_distance const& closest(overlapped->at(0));
                try
                {
                    attempt_reaction(pp, closest.first);
                }
                catch (propagation_error const& reason)
                {
                    log_.info("second-order reaction rejected (reason: %s)", reason.what());
                    ++rejected_move_count_;
                }
            }
            /* reject the move even if the reaction has not occurred */
            return true;

        default:
            log_.info("collision involving two or more particles; move rejected");
            ++rejected_move_count_;
            return true;
        }
        tx_.update_particle(particle_to_update);
        return true;
    }

    std::size_t get_rejected_move_count() const
    {
        return rejected_move_count_;
    }

private:
    position_type drawR_free(species_type const& species)
    {
        return tx_.get_structure(species.structure_id())->bd_displacement(std::sqrt(2.0 * species.D() * dt_), rng_);
    }

    bool attempt_reaction(particle_id_pair const& pp)
    {
        reaction_rules const& rules(rules_.query_reaction_rule(pp.second.sid()));
        if (::size(rules) == 0)
        {
            return false;
        }

        const Real rnd(rng_() / dt_);
        Real prob = 0.;

        for (typename boost::range_const_iterator<reaction_rules>::type
                i(boost::begin(rules)), e(boost::end(rules)); i != e; ++i)
        {
            reaction_rule_type const& r(*i);
            prob += r.k();
            if (prob > rnd)
            {
                typename reaction_rule_type::species_id_range products(
                        r.get_products());
                switch (::size(products))
                {
                case 0:
                    remove_particle(pp.first);
                    break;

                case 1:
                    {
                        const species_type s0(tx_.get_species(products[0]));
                        const particle_id_pair new_p(
                            pp.first, particle_type(products[0],
                                particle_shape_type(pp.second.position(),
                                                    s0.radius()),
                                                    s0.D()));
                        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(tx_.check_overlap(new_p.second.shape(), new_p.first));
                        if (overlapped && overlapped->size() > 0)
                        {
                            throw propagation_error("no space");
                        }

                        tx_.update_particle(new_p);

                        if (rrec_)
                        {
                            (*rrec_)(
                                reaction_record_type(
                                    r.id(), array_gen(new_p.first), pp.first));
                        }
                    }
                    break;

                case 2:
                    {
                        const species_type s0(tx_.get_species(products[0])),
                                s1(tx_.get_species(products[1]));
                        const Real D01(s0.D() + s1.D());
                        const length_type r01(s0.radius() + s1.radius());
                        int i = max_retry_count_;
                        position_type np0, np1;

                        for (;;)
                        {
                            if (--i < 0)
                            {
                                throw propagation_error("no space");
                            }

                            const Real rnd(rng_());
                            length_type pair_distance(
                                drawR_gbd(rnd, r01, dt_, D01));
                            const position_type m(random_unit_vector() * pair_distance);
                            np0 = tx_.apply_boundary(pp.second.position()
                                    + m * (s0.D() / D01));
                            np1 = tx_.apply_boundary(pp.second.position()
                                    - m * (s1.D() / D01));
                            boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped_s0(
                                tx_.check_overlap(
                                    particle_shape_type(np0, s0.radius()),
                                    pp.first));
                            boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped_s1(
                                tx_.check_overlap(
                                    particle_shape_type(np1, s1.radius()),
                                    pp.first));
                            if (!(overlapped_s0 && overlapped_s0->size() > 0) && !(overlapped_s1 && overlapped_s1->size() > 0))
                                break;
                        }

                        tx_.remove_particle(pp.first);
                        const particle_id_pair
                            npp0(tx_.new_particle(s0.id(), np0)),
                            npp1(tx_.new_particle(s1.id(), np1));

                        if (rrec_)
                        {
                            (*rrec_)(
                                reaction_record_type(
                                    r.id(),
                                    array_gen(npp0.first, npp1.first),
                                    pp.first));
                        }
                    }
                    break;
                default:
                    throw not_implemented("monomolecular reactions that produce more than two products are not supported");
                }
                return true;
            }
        }
        return false;
    }

    bool attempt_reaction(particle_id_pair const& pp0, particle_id_pair const& pp1)
    {
        reaction_rules const& rules(rules_.query_reaction_rule(pp0.second.sid(), pp1.second.sid()));
        if (::size(rules) == 0)
        {
            return false;
        }

        const species_type s0(tx_.get_species(pp0.second.sid())),
                s1(tx_.get_species(pp1.second.sid()));
        const length_type r01(s0.radius() + s1.radius());

        const Real rnd(rng_());
        Real prob = 0;

        for (typename boost::range_const_iterator<reaction_rules>::type
                i(boost::begin(rules)), e(boost::end(rules)); i != e; ++i)
        {
            reaction_rule_type const& r(*i);
            const Real p(r.k() * dt_ / ((I_bd(r01, dt_, s0.D()) + I_bd(r01, dt_, s1.D())) * 4.0 * M_PI));
            BOOST_ASSERT(p >= 0.);
            prob += p;
            if (prob >= 1.)
            {
                throw propagation_error(
                    "invalid acceptance ratio ("
                    + boost::lexical_cast<std::string>(p)
                    + ") for reaction rate "
                    + boost::lexical_cast<std::string>(r.k())
                    + ".");
            }
            if (prob > rnd)
            {
                LOG_DEBUG(("fire reaction"));
                const typename reaction_rule_type::species_id_range products(
                    r.get_products());

                switch (::size(products))
                {
                case 1:
                    {
                        const species_id_type product(products[0]);
                        const species_type sp(tx_.get_species(product));

                        const position_type new_pos(
                            tx_.apply_boundary(
                                divide(
                                    add(multiply(pp0.second.position(), s1.D()),
                                        multiply(tx_.cyclic_transpose(
                                            pp1.second.position(),
                                            pp0.second.position()), s0.D())),
                                    (s0.D() + s1.D()))));
                        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(
                            tx_.check_overlap(particle_shape_type(new_pos, sp.radius()),
                                              pp0.first, pp1.first));
                        if (overlapped && overlapped->size() > 0)
                        {
                            throw propagation_error("no space");
                        }

                        remove_particle(pp0.first);
                        remove_particle(pp1.first);
                        particle_id_pair npp(tx_.new_particle(product, new_pos));
                        if (rrec_)
                        {
                            (*rrec_)(
                                reaction_record_type(
                                    r.id(), array_gen(npp.first), pp0.first, pp1.first));
                        }
                        break;
                    }
                case 0:
                    remove_particle(pp0.first);
                    remove_particle(pp1.first);
                    break;
                
                default:
                    throw not_implemented("bimolecular reactions that produce more than one product are not supported");
                }

                return true;
            }
        }
        return false;
    }

    void remove_particle(particle_id_type const& pid)
    {
        LOG_DEBUG(("remove particle %s", boost::lexical_cast<std::string>(pid).c_str()));
        tx_.remove_particle(pid);
        typename particle_id_vector_type::iterator i(
            std::find(queue_.begin(), queue_.end(), pid));
        if (queue_.end() != i)
            queue_.erase(i);
    }

private:
    position_type random_unit_vector()
    {
        position_type v(rng_() - .5, rng_() - .5, rng_() - .5);
        return v / length(v);
    }

private:
    particle_container_type& tx_;
    network_rules_type const& rules_;
    rng_type& rng_;
    Real const dt_;
    int const max_retry_count_;
    reaction_recorder_type* const rrec_;
    particle_id_vector_type queue_;
    int rejected_move_count_;
    static Logger& log_;
};

template<typename Ttraits_>
Logger& BDPropagator<Ttraits_>::log_(Logger::get_logger("ecell.BDPropagator"));

#endif /* BD_PROPAGATOR_HPP */

 </xmp> 
<h3> BDSimulator.hpp </h3> <xmp>

#ifndef BD_SIMULATOR_HPP
#define BD_SIMULATOR_HPP

#include <algorithm>
#include <limits>
#include <boost/foreach.hpp>
#include <boost/random/mersenne_twister.hpp>
#include "NetworkRules.hpp"
#include "BDPropagator.hpp"
#include "World.hpp"
#include "ParticleSimulator.hpp"
#include "utils/pair.hpp"

template<typename Tworld_>
struct BDSimulatorTraitsBase: public ParticleSimulatorTraitsBase<Tworld_>
{
};

template<typename Ttraits_>
class BDSimulator: public ParticleSimulator<Ttraits_>
{
public:
    typedef Ttraits_ traits_type;
    typedef ParticleSimulator<Ttraits_> base_type;
    typedef typename traits_type::world_type world_type;
    typedef typename world_type::traits_type::rng_type rng_type;
    typedef typename world_type::species_id_type species_id_type;
    typedef typename world_type::species_type species_type;
    typedef typename traits_type::time_type time_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename traits_type::reaction_rule_type reaction_rule_type;
    typedef typename traits_type::rate_type rate_type;
    typedef typename traits_type::reaction_record_type reaction_record_type;
    typedef typename traits_type::reaction_recorder_type reaction_recorder_type;

public:
    Real const& dt_factor()
    {
        return dt_factor_;
    }

    virtual ~BDSimulator() {}

    BDSimulator(boost::shared_ptr<world_type> world, 
                boost::shared_ptr<network_rules_type const> network_rules,
                rng_type& rng, Real dt_factor = .5,
                int dissociation_retry_moves = 1)
        : base_type(world, network_rules, rng),
          dt_factor_(dt_factor), num_retrys_(dissociation_retry_moves)
    {
        calculate_dt();
    }

    virtual void calculate_dt()
    {
        base_type::dt_ = dt_factor_ * determine_dt(*base_type::world_);
        LOG_DEBUG(("dt=%f", base_type::dt_));
    }

    virtual void step()
    {
        step(base_type::dt_);
    }

    virtual bool step(time_type upto)
    {
        time_type const lt(upto - base_type::t_);
        if (lt <= 0.)
            return false;
        if (base_type::dt_ < lt)
        {
            _step(base_type::dt_);
        }
        else
        {
            _step(lt);
            base_type::t_ = upto;
        }
        return true;
    }

    static Real determine_dt(world_type const& world)
    {
        Real D_max(0.), radius_min(std::numeric_limits<Real>::max());

        BOOST_FOREACH(species_type s, world.get_species())
        {
            if (D_max < s.D())
                D_max = s.D();
            if (radius_min > s.radius())
                radius_min = s.radius();
        }
        return gsl_pow_2(radius_min * 2) / (D_max * 2);
    }

protected:
    void _step(time_type dt)
    {
        {
            BDPropagator<traits_type> propagator(
                base_type::world_,
                base_type::network_rules_,
                base_type::rng_,
                dt, num_retrys_,
                make_select_first_range(base_type::world_.get_particles_range()));
            while (propagator());
            LOG_DEBUG(("%d: t=%lg, dt=%lg", base_type::num_steps_, base_type::t_, dt));
        }
        ++base_type::num_steps_;
        base_type::t_ += dt;
    }

private:
    Real const dt_factor_;
    int const num_retrys_;
    static Logger& log_;
};

template<typename Ttraits_>
Logger& BDSimulator<Ttraits_>::log_(Logger::get_logger("BDSimulator"));


#endif /* BD_SIMULATOR_HPP */
 </xmp> 
<h3> bessel.hpp </h3> <xmp>

#ifndef __BESSEL_HPP__
#define __BESSEL_HPP__

void bessjy(double x, double xnu, double *rj, double *ry, double *rjp, double *ryp);


#endif /* __BESSEL_HPP__ */
 </xmp> 
<h3> Box.hpp </h3> <xmp>

#ifndef BOX_HPP
#define BOX_HPP

#include <boost/array.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/multi_array.hpp>
#include <utility>
#include <algorithm>
#include "utils/array_helper.hpp"
#include "Shape.hpp"
#include "linear_algebra.hpp"

template<typename T_>
class Box
{
public:
    typedef T_ value_type;
    typedef Vector3<T_> position_type;
    typedef T_ length_type;

public:
    Box(position_type const& position = position_type())
        : position_(position),
          units_(array_gen(
            create_vector<position_type>(1., 0., 0.),
            create_vector<position_type>(0., 1., 0.),
            create_vector<position_type>(0., 0., 1.))),
          half_extent_(array_gen<length_type>(0.5, 0.5, 0.5)) {}

    template<typename Tarray_>
    Box(position_type const& position, Tarray_ const& half_extent)
        : position_(position),
          units_(array_gen(
            create_vector<position_type>(1., 0., 0.),
            create_vector<position_type>(0., 1., 0.),
            create_vector<position_type>(0., 0., 1.)))
    {
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    template<typename Tarray1, typename Tarray2>
    Box(position_type const& position,
        Tarray1 const& units, Tarray2 const& half_extent)
        : position_(position)
    {
        std::copy(boost::begin(units), boost::end(units),
                  boost::begin(units_));
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    template<typename Tarray_>
    Box(position_type const& position,
        position_type const& vx,
        position_type const& vy,
        position_type const& vz,
        Tarray_ const& half_extent = array_gen<length_type>(0.5, 0.5, 0.5))
        : position_(position), units_(array_gen(vx, vy, vz))
    {
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    Box(position_type const& position,
        position_type const& vx,
        position_type const& vy,
        position_type const& vz,
        length_type const& half_lx,
        length_type const& half_ly,
        length_type const& half_lz)
        : position_(position), units_(array_gen(vx, vy, vz)),
          half_extent_(array_gen<length_type>(half_lx, half_ly, half_lz)) {}

    position_type const& position() const
    {
        return position_;
    }

    position_type& position()
    {
        return position_;
    }

    position_type const& unit_x() const
    {
        return units_[0];
    }

    position_type& unit_x()
    {
        return units_[0];
    }

    position_type const& unit_y() const
    {
        return units_[1];
    }

    position_type& unit_y()
    {
        return units_[1];
    }

    position_type const& unit_z() const
    {
        return units_[2];
    }

    position_type& unit_z()
    {
        return units_[2];
    }

    boost::array<position_type, 3> const& units() const
    {
        return units_;
    }

    boost::array<position_type, 3>& units()
    {
        return units_;
    }

    length_type const Lx() const
    { 
        return 2 * half_extent_[0];
    }

    length_type Lx()
    {
        return 2 * half_extent_[0];
    }

    length_type const Ly() const
    {
        return 2 * half_extent_[1];
    }

    length_type Ly()
    {
        return 2 * half_extent_[1];
    }

    length_type const Lz() const
    {
        return 2 * half_extent_[2];
    }

    length_type Lz()
    {
        return 2 * half_extent_[2];
    }

    boost::array<length_type, 3> const& half_extent() const
    {
        return half_extent_;
    }

    boost::array<length_type, 3>& half_extent()
    {
        return half_extent_;
    }

    bool operator==(const Box& rhs) const
    {
        return position_ == rhs.position_ && units_ == rhs.units_ &&
               half_extent_ == rhs.half_extent_;
    }

    bool operator!=(const Box& rhs) const
    {
        return !operator==(rhs);
    }

    std::string show(int precision)
    {
        std::ostringstream strm;
        strm.precision(precision);
        strm << *this;
        return strm.str();
    }

protected:
    // Middle of box.
    position_type position_;
    boost::array<position_type, 3> units_;
    // Extent: for a box of 2 by 2 by 2, half_extent is 1 by 1 by 1.
    boost::array<length_type, 3> half_extent_;
};

template<typename T_>
inline boost::array<typename Box<T_>::length_type, 3>
to_internal(Box<T_> const& obj, typename Box<T_>::position_type const& pos)
{
    // Return pos relative to position of box. 
    typedef typename Box<T_>::position_type position_type;
    position_type pos_vector(subtract(pos, obj.position()));

    return array_gen<typename Box<T_>::length_type>(
        dot_product(pos_vector, obj.unit_x()),
        dot_product(pos_vector, obj.unit_y()),
        dot_product(pos_vector, obj.unit_z()));
}

template<typename T_>
inline std::pair<typename Box<T_>::position_type,
                 typename Box<T_>::length_type>
projected_point(Box<T_> const& obj, typename Box<T_>::position_type const& pos)
{
    // Todo. If we ever need it.
    // The projection of a point on a box.
    return std::make_pair(typename Box<T_>::position_type(),
                          typename Box<T_>::length_type());
}

template<typename T_>
inline typename Box<T_>::length_type
distance(Box<T_> const& obj, typename Box<T_>::position_type const& pos)
{
    typedef typename Box<T_>::length_type length_type;
    boost::array<length_type, 3> x_y_z(to_internal(obj, pos));
    boost::array<length_type, 3> dx_dy_dz(subtract(abs(x_y_z), obj.half_extent()));

    if (dx_dy_dz[0] > 0)
    {
        if (dx_dy_dz[1] > 0)
        {
            if (dx_dy_dz[2] > 0)
            {
                // Far away from box.
                return length(dx_dy_dz);
            }
            else
            {
                return length(array_slice<0, 2>(dx_dy_dz));
            }
        }
        else
        {
            if (dx_dy_dz[2] > 0)
            {
                return std::sqrt(gsl_pow_2(dx_dy_dz[0]) + gsl_pow_2(dx_dy_dz[2]));
            }
            else
            {
                return dx_dy_dz[0];
            }
        }
    }
    else
    {
        if (dx_dy_dz[1] > 0)
        {
            if (dx_dy_dz[2] > 0)
            {
                return length(array_slice<1, 3>(dx_dy_dz));
            }
            else
            {
                return dx_dy_dz[1];
            }
        }
        else
        {
            if (dx_dy_dz[2] > 0)
            {
                return dx_dy_dz[2];
            }
            else
            {
                // Inside box.
                return std::max(std::max(dx_dy_dz[0], dx_dy_dz[1]), dx_dy_dz[2]);
            }
        }
    }
}

template<typename T, typename Trng>
inline typename Box<T>::position_type
random_position(Box<T> const& shape, Trng& rng)
{
    boost::const_multi_array_ref<T, 2> mat(&shape.units()[0][0], boost::extents[3][3]);
    // -1 < rng() < 1. See for example CuboidalRegion.hpp.
    return add(
        shape.position(),
        multiply(
            create_vector<typename Box<T>::position_type>(
                shape.half_extent()[0] * rng(),
                shape.half_extent()[1] * rng(),
                shape.half_extent()[2] * rng()),
            mat));
}

template<typename T>
inline Box<T> const& shape(Box<T> const& shape)
{
    return shape;
}

template<typename T>
inline Box<T>& shape(Box<T>& shape)
{
    return shape;
}

template<typename T_>
struct is_shape<Box<T_> >: public boost::mpl::true_ {};

template<typename T_>
struct shape_position_type<Box<T_> >
{
    typedef typename Box<T_>::position_type type;
};

template<typename Tstrm_, typename Ttraits_, typename T_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm,
        const Box<T_>& v)
{
    strm << "{" << v.position() <<  ", " << v.unit_x() << ", " << v.unit_y() << ", " << v.unit_z() << "," << v.Lx() << ", " << v.Ly() << ", " << v.Lz() << "}";
    return strm;
}


#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_>
struct hash<Box<T_> >
{
    typedef Box<T_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::position_type>()(val.position()) ^
            hash<typename argument_type::position_type>()(val.unit_x()) ^
            hash<typename argument_type::position_type>()(val.unit_y()) ^
            hash<typename argument_type::position_type>()(val.unit_z()) ^
            hash<typename argument_type::length_type>()(val.half_extent()[0]) ^
            hash<typename argument_type::length_type>()(val.half_extent()[1]) ^
            hash<typename argument_type::length_type>()(val.half_extent()[2]);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* BOX_HPP */
 </xmp> 
<h3> ConsoleAppender.hpp </h3> <xmp>

#ifndef CONSOLE_LOGGER_HPP
#define CONSOLE_LOGGER_HPP

#include <string>

#include "Logger.hpp"

class ConsoleAppender: public LogAppender
{
public:
    typedef LogAppender base_type;

public:
    virtual ~ConsoleAppender();

    virtual void flush();

    virtual void operator()(enum Logger::level lv, boost::posix_time::ptime const& tm, char const* name, char const** chunks);
};

#endif /* CONSOLE_LOGGER_HPP */
 </xmp> 
<h3> CuboidalRegion.hpp </h3> <xmp>

#ifndef CUBOIDAL_REGION_HPP
#define CUBOIDAL_REGION_HPP

#include <boost/bind.hpp>
#include "Region.hpp"
#include "Box.hpp"

template<typename Ttraits_>
class CuboidalRegion
    : public BasicRegionImpl<Ttraits_, Box<typename Ttraits_::world_type::traits_type::length_type> >
{
public:
    typedef BasicRegionImpl<Ttraits_, Box<typename Ttraits_::world_type::traits_type::length_type> > base_type;
    typedef typename base_type::traits_type traits_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::shape_type shape_type;
    typedef typename base_type::rng_type rng_type;
    typedef typename base_type::position_type position_type;
    typedef typename base_type::length_type length_type;

    identifier_type const& id() const
    {
        return base_type::id_;
    }

    virtual position_type random_position(rng_type& rng) const
    {
        return ::random_position(base_type::shape(),
                boost::bind(&rng_type::uniform, rng, -1., 1.));
    }

    virtual position_type random_vector(length_type const& r, rng_type& rng) const
    {
        return normalize(
            create_vector<position_type>(
                rng.uniform(-1., 1.),
                rng.uniform(-1., 1.),
                rng.uniform(-1., 1.)), r);
    }

    virtual position_type bd_displacement(length_type const& r, rng_type& rng) const
    {
        return create_vector<position_type>(
            rng.normal(0., r),
            rng.normal(0., r),
            rng.normal(0., r));
    }

    virtual void accept(ImmutativeStructureVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeStructureVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    CuboidalRegion(identifier_type const& id, shape_type const& shape)
        : base_type(id, shape) {}
};

#endif /* CUBOIDAL_REGION_HPP */
 </xmp> 
<h3> Cylinder.hpp </h3> <xmp>

#ifndef CYLINDER_HPP
#define CYLINDER_HPP

#include <ostream>
#include <cmath>
#include "Vector3.hpp"
#include "Shape.hpp"

// Todo. Make sure cylinder is never larger than 1 cellsize or something.  
template<typename T_>
class Cylinder
{
public:
    typedef T_ value_type;
    typedef Vector3<T_> position_type;
    typedef T_ length_type;

public:
    Cylinder()
        : position_(), radius_(0), unit_z_(), half_length_(0) {}

    Cylinder(position_type const& position, length_type const& radius,
             position_type const& unit_z, length_type const& half_length )
        : position_(position), radius_(radius), unit_z_(unit_z),
          half_length_(half_length) {}

    bool operator==(const Cylinder& rhs) const
    {
        return position_ == rhs.position() && radius_ == rhs.radius() && unit_z_ == rhs.unit_z() && half_length_ == rhs.half_length();
    }

    bool operator!=(const Cylinder& rhs) const
    {
        return !operator==(rhs);
    }

    position_type const& position() const
    {
        return position_;
    }

    position_type& position()
    {
        return position_;
    }

    length_type const& radius() const
    {
        return radius_;
    }

    length_type& radius()
    {
        return radius_;
    }

    position_type const& unit_z() const
    {
        return unit_z_;
    }

    position_type& unit_z()
    {
        return unit_z_;
    }

    length_type const& half_length() const
    {
        return half_length_;
    }

    length_type& half_length()
    {
        return half_length_;
    }

    std::string show(int precision)
    {
        std::ostringstream strm;
        strm.precision(precision);
        strm << *this;
        return strm.str();
    }

private:
    position_type position_; // centre.
    length_type radius_;
    position_type unit_z_; // Z-unit_z. should be normalized.
    length_type half_length_;
};

template<typename Tstrm_, typename T_>
inline std::basic_ostream<Tstrm_>& operator<<(std::basic_ostream<Tstrm_>& strm,
        const Cylinder<T_>& v)
{
    strm << "{" << v.position() <<  ", " << v.radius() << ", " << v.unit_z() << ", " << v.half_length() << "}";
    return strm;
}

template<typename T_>
inline std::pair<typename Cylinder<T_>::length_type,
                 typename Cylinder<T_>::length_type>
to_internal(Cylinder<T_> const& obj, typename Cylinder<T_>::position_type const& pos)
{
    // Return pos relative to position of cylinder. 
    typedef typename Cylinder<T_>::position_type position_type;
    typedef typename Cylinder<T_>::length_type length_type;

    const position_type pos_vector(subtract(pos, obj.position()));
    // z can be < 0
    const length_type z(dot_product(pos_vector, obj.unit_z()));
    // r is always >= 0
    const length_type r(length(pos_vector - multiply(obj.unit_z(), z)));

    return std::make_pair(r, z);
}

template<typename T_>
inline std::pair<typename Cylinder<T_>::position_type,
                 typename Cylinder<T_>::length_type>
projected_point(Cylinder<T_> const& obj,
                typename Cylinder<T_>::position_type const& pos)
{
    typedef typename Cylinder<T_>::length_type length_type;

    // The projection lies on the z-axis.
    std::pair<length_type, length_type> r_z(to_internal(obj, pos));
    return std::make_pair(
        add(obj.position(), multiply(obj.unit_z(), r_z.second)),
        r_z.first);
}

template<typename T_>
inline typename Cylinder<T_>::length_type
distance(Cylinder<T_> const& obj,
                typename Cylinder<T_>::position_type const& pos)
{
    typedef typename Cylinder<T_>::position_type position_type;
    typedef typename Cylinder<T_>::length_type length_type;

    /* First compute the (z,r) components of pos in a coordinate system 
     * defined by the vectors unitR and unit_z, where unitR is
     * choosen such that unitR and unit_z define a plane in which
     * pos lies. */
    const std::pair<length_type, length_type> r_z(to_internal(obj, pos));

    /* Then compute distance to cylinder. */
    const length_type dz(std::fabs(r_z.second) - obj.half_length());
    const length_type dr(r_z.first - obj.radius());
    length_type distance;
    if (dz > 0)
    {
        // pos is (either) to the right or to the left of the cylinder.
        if (r_z.first > obj.radius())
        {
            // Compute distance to edge.
            distance = std::sqrt( dz * dz + dr * dr );
        }
        else
        {
            distance = dz;
        }
    }
    else
    {
        if (dr > obj.radius())
        {
            // pos is somewhere 'parallel' to the cylinder.
            distance = dr;
        }
        else
        {
            // Inside cylinder. 
            distance = std::max(dr, dz);
        }
    }
    return distance;
}

template<typename T, typename Trng>
inline typename Cylinder<T>::position_type
random_position(Cylinder<T> const& shape, Trng& rng)
{
    // -1 < rng() < 1. See for example CylindricalSurface.hpp.
    return add(shape.position(),
               multiply(shape.unit_z(), rng() * shape.half_length()));
}

template<typename T_>
inline Cylinder<T_> const& shape(Cylinder<T_> const& shape)
{
    return shape;
}

template<typename T_>
inline Cylinder<T_>& shape(Cylinder<T_>& shape)
{
    return shape;
}

template<typename T_>
struct is_shape<Cylinder<T_> >: public boost::mpl::true_ {};

template<typename T_>
struct shape_position_type<Cylinder<T_> >
{
    typedef typename Cylinder<T_>::position_type type;
};

template<typename T_>
struct shape_length_type<Cylinder<T_> > {
    typedef typename Cylinder<T_>::length_type type;
};

template<typename T>
inline typename shape_length_type<Cylinder<T> >::type const& shape_size(Cylinder<T> const& shape)
{
    return shape.radius();
} 

template<typename T>
inline typename shape_length_type<Cylinder<T> >::type& shape_size(Cylinder<T>& shape)
{
    return shape.radius();
} 

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_>
struct hash<Cylinder<T_> >
{
    typedef Cylinder<T_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::position_type>()(val.position()) ^
            hash<typename argument_type::length_type>()(val.radius()) ^
            hash<typename argument_type::position_type>()(val.unit_z()) ^
            hash<typename argument_type::length_type>()(val.half_length());
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* CYLINDER_HPP */
 </xmp> 
<h3> CylindricalBesselGenerator.hpp </h3> <xmp>

#ifndef __CYLINDRICALBESSELGENERATOR_HPP
#define __CYLINDRICALBESSELGENERATOR_HPP

#include <cmath>

#include <gsl/gsl_errno.h>
#include <gsl/gsl_sf_bessel.h>

#include "Defs.hpp"


class CylindricalBesselGenerator
{

    typedef UnsignedInteger Index;

public:

    CylindricalBesselGenerator()
    {
        ; // do nothing
    }

    ~CylindricalBesselGenerator()
    {
        ; // do nothing
    }

    Real J(UnsignedInteger n, Real z) const;

    Real Y(UnsignedInteger n, Real z) const;

    static UnsignedInteger getMinNJ();
    static UnsignedInteger getMinNY();
    static UnsignedInteger getMaxNJ();
    static UnsignedInteger getMaxNY();

    static CylindricalBesselGenerator const& instance();
};




#endif /* __CYLINDRICALBESSELGENERATOR_HPP */
 </xmp> 
<h3> CylindricalSurface.hpp </h3> <xmp>

#ifndef CYLINDRICAL_SURFACE_HPP
#define CYLINDRICAL_SURFACE_HPP

#include <boost/bind.hpp>
#include "Surface.hpp"
#include "Cylinder.hpp"

template<typename Ttraits_>
class CylindricalSurface
    : public BasicSurfaceImpl<Ttraits_, Cylinder<typename Ttraits_::world_type::traits_type::length_type> >
{
public:
    typedef BasicSurfaceImpl<Ttraits_, Cylinder<typename Ttraits_::world_type::traits_type::length_type> > base_type;
    typedef typename base_type::traits_type traits_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::shape_type shape_type;
    typedef typename base_type::rng_type rng_type;
    typedef typename base_type::position_type position_type;
    typedef typename base_type::length_type length_type;

    virtual position_type random_position(rng_type& rng) const
    {
        return ::random_position(base_type::shape(), boost::bind(&rng_type::uniform, rng, -1., 1.));
    }

    virtual position_type random_vector(length_type const& r, rng_type& rng) const
    {
        return multiply(base_type::shape().unit_z(),
                (rng.uniform_int(0, 1) * 2 - 1) * r);
    }

    virtual position_type bd_displacement(length_type const& r, rng_type& rng) const
    {
        return multiply(base_type::shape().unit_z(), rng.normal(0., r));
    }

    virtual length_type minimal_distance(length_type const& radius) const
    {
        length_type cylinder_radius = base_type::shape().radius();
        // Return minimal distance *to* surface.
        return (cylinder_radius + radius) * traits_type::MINIMAL_SEPARATION_FACTOR - cylinder_radius;
    }

    virtual void accept(ImmutativeStructureVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeStructureVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    CylindricalSurface(identifier_type const& id, shape_type const& shape)
        : base_type(id, shape) {}
};

#endif /* CYLINDRICAL_SURFACE_HPP */
 </xmp> 
<h3> Defs.hpp </h3> <xmp>

#if !defined( __DEFS_HPP )
#define __DEFS_HPP

#include <cstddef>

typedef double Real;
typedef long int Integer;
typedef unsigned long int UnsignedInteger;
typedef size_t Index;

// stringifiers.  see preprocessor manual
#define XSTR( S ) STR( S )
#define STR( S ) #S

#define THROW_UNLESS( CLASS, EXPRESSION )       \
    if( ! ( EXPRESSION ) )\
    {\
        throw CLASS( "Check [" + std::string( STR( EXPRESSION ) ) +\
                     "] failed." );\
    }\


#define IGNORE_RETURN (void)

#endif // __DEFS_HPP
 </xmp> 
<h3> DomainFactory.hpp </h3> <xmp>

#ifndef DOMAIN_FACTORY_HPP
#define DOMAIN_FACTORY_HPP

template<typename Ttraits_>
struct DomainFactory
{
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::shell_id_pair shell_id_pair;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::single_type single_type;
    typedef typename traits_type::pair_type pair_type;
    typedef typename traits_type::domain_id_type domain_id_type;
    typedef typename traits_type::network_rules_type network_rules_type;

    virtual single_type*
    create_single(domain_id_type const& domain_id,
                  particle_id_pair const& particle_id_pair,
                  shell_id_pair const& shell_id_pair,
                  typename network_rules_type::reaction_rule_vector const& reactions) const = 0;

    virtual pair_type*
    create_pair(domain_id_type const& domain_id,
                position_type const& com,
                particle_id_pair const& single1,
                particle_id_pair const& single2,
                shell_id_pair const& shell_id_pair,
                typename network_rules_type::reaction_rule_vector const& reactions) const = 0;
};

#endif /* DOMAIN_FACTORY_HPP */
 </xmp> 
<h3> Domain.hpp </h3> <xmp>

#ifndef DOMAIN_HPP
#define DOMAIN_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <string>
#include <cstddef>
#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>

template<typename Ttraits_>
class ImmutativeDomainVisitor;

template<typename Ttraits_>
class MutativeDomainVisitor;

template<typename Ttraits_>
class Domain
{
public:
    typedef Ttraits_ traits_type;
    typedef std::size_t size_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::event_id_pair_type event_id_pair_type;
    typedef typename traits_type::time_type time_type;

public:
    virtual ~Domain() {}

    Domain(identifier_type const& id)
        : id_(id), last_time_(0.), dt_(0.) {}

    identifier_type const& id() const
    {
        return id_;
    }

    event_id_pair_type const& event() const
    {
        return event_;
    }

    event_id_pair_type& event()
    {
        return event_;
    }

    time_type const& last_time() const
    {
        return last_time_;
    }

    time_type& last_time()
    {
        return last_time_;
    }

    time_type const& dt() const
    {
        return dt_;
    }

    time_type& dt()
    {
        return dt_;
    }

    virtual size_type num_shells() const = 0;

    virtual size_type multiplicity() const = 0;

    virtual char const* type_name() const = 0;

    virtual std::string as_string() const
    {
        return (boost::format(
            "%s(id=%s, event=%s, last_time=%g, dt=%g)") %
            type_name() %
            boost::lexical_cast<std::string>(id_).c_str() %
            boost::lexical_cast<std::string>(event_.first).c_str() %
            last_time_ % dt_).str();
    }

    virtual void accept(ImmutativeDomainVisitor<traits_type> const&) const = 0;

    virtual void accept(MutativeDomainVisitor<traits_type> const&) = 0;

protected:
    identifier_type id_;
    event_id_pair_type event_;
    time_type last_time_;
    time_type dt_;
};

template<typename Tstrm, typename Ttraits, typename TdomTraits>
inline std::basic_ostream<Tstrm, Ttraits>&
operator<<(std::basic_ostream<Tstrm, Ttraits>& lhs,
           Domain<TdomTraits> const& rhs)
{
    lhs << rhs.as_string();
    return lhs;
}

template<typename Ttraits>
inline char const* retrieve_domain_type_name(Domain<Ttraits> const&)
{
    return "Domain";
}

#endif /* DOMAIN_HPP */
 </xmp> 
<h3> DomainID.hpp </h3> <xmp>

#ifndef DOMAIN_ID_HPP
#define DOMAIN_ID_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif
#include "Identifier.hpp"

struct DomainID: public Identifier<DomainID, unsigned long long, int>
{
    typedef Identifier<DomainID, unsigned long long, int> base_type;

    DomainID(value_type const& value = value_type(0, 0))
        : base_type(value) {}
};

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<>
struct hash<DomainID>
{
    std::size_t operator()(DomainID const& val) const
    {
        return static_cast<std::size_t>(val().first ^ val().second);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

template<typename Tstrm_>
inline std::basic_ostream<Tstrm_>& operator<<(std::basic_ostream<Tstrm_>& strm,
        const DomainID& v)
{
    strm << "DID(" << v().first << ":" << v().second << ")";
    return strm;
}

#endif /* DOMAIN_ID_HPP */
 </xmp> 
<h3> DomainUtils.hpp </h3> <xmp>

#ifndef DOMAIN_UTILS_HPP
#define DOMAIN_UTILS_HPP

#include "exceptions.hpp"
#include "Single.hpp"
#include "Pair.hpp"
#include "GreensFunction3DAbsSym.hpp"

template<typename Ttraits_>
struct DomainUtils
{
    typedef Ttraits_ traits_type;
    typedef typename traits_type::spherical_shell_type spherical_shell_type;
    typedef typename traits_type::cylindrical_shell_type cylindrical_shell_type;
    typedef typename traits_type::domain_type domain_type;
    typedef Single<Ttraits_, spherical_shell_type> spherical_single_type;
    typedef Single<Ttraits_, cylindrical_shell_type> cylindrical_single_type;
    typedef Pair<Ttraits_, spherical_shell_type> spherical_pair_type;
    typedef Pair<Ttraits_, cylindrical_shell_type> cylindrical_pair_type;

    static length_type calculate_mobility_radius(spherical_single_type const& dom)
    {
        return dom.shell().second.shape().radius() - dom.particle().second.shape().radius();
    }

    static length_type calculate_mobility_radius(cylindrical_single_type const& dom)
    {
        return dom.shell().second.shape().size() - dom.particle().second.shape().radius();
    }

    static length_type calculate_mobility_radius(domain_type const& dom)
    {
        {
            spherical_single_type const* x(
                dynamic_cast<spherical_single_type const*>(&dom));
            if (x)
            {
                return calculate_mobility_radius(*x);
            }
        }
        {
            cylindrical_single_type const* x(
                dynamic_cast<cylindrical_single_type const*>(&dom));
            if (x)
            {
                return calculate_mobility_radius(*x);
            }
        }
        throw unsupported("unsupported domain type");
    }

    static length_type get_shell_size(spherical_single_type const& dom)
    {
        return dom.shell().second.radius();
    }

    static length_type get_shell_size(cylindrical_single_type const& dom)
    {
        return dom.shell().second.radius();
    }

    static length_type get_shell_size(spherical_pair_type const& dom)
    {
        return dom.shell().second.radius();
    }

    static length_type get_shell_size(cylindrical_pair_type const& dom)
    {
        return dom.shell().second.radius();
    }

    static length_type get_shell_size(domain_type const& dom)
    {
        {
            spherical_single_type const* x(
                dynamic_cast<spherical_single_type const*>(&dom));
            if (x)
            {
                return get_shell_size(*x);
            }
        }
        {
            cylindrical_single_type const* x(
                dynamic_cast<cylindrical_single_type const*>(&dom));
            if (x)
            {
                return get_shell_size(*x);
            }
        }
        {
            spherical_pair_type const* x(
                dynamic_cast<spherical_pair_type const*>(&dom));
            if (x)
            {
                return get_shell_size(*x);
            }
        }
        {
            cylindrical_pair_type const* x(
                dynamic_cast<cylindrical_pair_type const*>(&dom));
            if (x)
            {
                return get_shell_size(*x);
            }
        }
        throw unsupported("unsupported domain type");
    }

    template<typename Tdom_>
    static GreensFunction3DAbsSym get_com_greens_function(Tdom_ const& dom)
    {
        return GreensFunction3DAbsSym(dom)
    }
};

#endif /* DOMAIN_UTILS_HPP */
 </xmp> 
<h3> DynamicPriorityQueue.hpp </h3> <xmp>

#ifndef __DYNAMICPRIORITYQUEUE_HPP
#define __DYNAMICPRIORITYQUEUE_HPP
//
// written by Koichi Takahashi based on the initial version by Eiichiro Adachi.
// modified by Mozoyoshi Koizumi
//


#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

#include <functional>
#include <vector>
#include <algorithm>
#include <utility>
#include <stdexcept>

#include <boost/format.hpp>
#include <boost/lexical_cast.hpp>

//#define HAVE_TR1_UNORDERED_MAP

#if HAVE_UNORDERED_MAP
#include <unordered_map>
#elif HAVE_TR1_UNORDERED_MAP
#include <tr1/unordered_map>
#elif HAVE_BOOST_UNORDERED_MAP_HPP
#include <boost/unordered_map.hpp>
#else
#include <map>
#endif /* HAVE_UNORDERED_MAP */

#ifdef DEBUG
#include <iostream>
#endif

#include "utils/swap.hpp"

template<typename Tid_>
struct default_id_generator
{
    typedef Tid_ identifier_type;

    default_id_generator(): next_() {}

    default_id_generator(identifier_type const& first): next_(first) {}

    identifier_type operator()()
    {
        return ++next_;
    }

protected:
    identifier_type next_;
};


template<typename Tid_ = unsigned long long,
         typename Tindex_ = std::size_t,
         typename Tidgen_ = default_id_generator<Tid_> >
class persistent_id_policy
{
public:
    typedef Tid_ identifier_type;
    typedef Tindex_ index_type;
    typedef Tidgen_ identifier_generator;

protected:
    struct hasher
        : public std::unary_function<identifier_type, std::size_t>
    {
        std::size_t operator()(identifier_type value) const
        {
            return static_cast<std::size_t>(value) ^
                static_cast<std::size_t>(
                    value >> (sizeof(identifier_type) * 8 / 2));
        }
    };
#if HAVE_UNORDERED_MAP
    typedef std::unordered_map<identifier_type, index_type, hasher> index_map;
#elif HAVE_TR1_UNORDERED_MAP
    typedef std::tr1::unordered_map<identifier_type, index_type, hasher> index_map;
#elif HAVE_BOOST_UNORDERED_MAP_HPP
    typedef boost::unordered_map<identifier_type, index_type, hasher> index_map;
#else 
    typedef std::map<identifier_type, index_type> index_map;
#endif

public:
    index_type index(identifier_type const& id) const
    {
        typename index_map::const_iterator i(index_map_.find(id));
        if (i == index_map_.end())
        {
            throw std::out_of_range((boost::format("%s: Key not found (%s)") % __PRETTY_FUNCTION__ % boost::lexical_cast<std::string>(id)).str());
        }
        return (*i).second;
    }

    identifier_type push(index_type index)
    {
        const identifier_type id(idgen_());
        index_map_.insert(typename index_map::value_type(id, index));
        return id;
    }

    void pop(index_type index, identifier_type id, identifier_type last_item_id)
    {
        index_map_[last_item_id] = index;
        index_map_.erase(id);
    }

    void clear()
    {
        index_map_.clear();
    }

private:
    index_map index_map_;
    identifier_generator idgen_;
};

template<typename Tindex_ = std::size_t>
class volatile_id_policy
{
public:
    typedef Tindex_ identifier_type;
    typedef Tindex_ index_type;

    index_type index(identifier_type const& id) const
    {
        return id;
    }

    identifier_type push(index_type index)
    {
        return index;
    }

    void pop(index_type, identifier_type, identifier_type) {}

    void clear() {}
};


/**
   Dynamic priority queue for items of type Titem_.

   When Tpolicy_ template parameter is persistent_id_policy, identifier_types assigned
   to pushed items are persistent for the life time of this priority
   queue.

   When Volatileidentifier_typePolicy template parameter is used as the Tpolicy_,
   identifier_types are valid only until the next call of pop or push methods.
   However, Volatileidentifier_typePolicy saves some memory and eliminates the
   overhead incurred in pop/push methods.
*/

template<typename Titem_, typename Tcomparator = std::less_equal<Titem_>, class Tpolicy_ = persistent_id_policy<> >
class DynamicPriorityQueue: private Tpolicy_
{
public:
    typedef Tpolicy_ policy_type;
    typedef typename policy_type::identifier_type identifier_type;
    typedef typename policy_type::index_type index_type;
    typedef Titem_ element_type;
    typedef std::pair<identifier_type, element_type> value_type;
    typedef Tcomparator comparator_type;

protected:
    typedef std::vector<value_type> value_vector;
    typedef std::vector<index_type> index_vector;

public:
    typedef typename value_vector::size_type size_type;
    typedef typename value_vector::const_iterator iterator;
    typedef typename value_vector::const_iterator const_iterator;

public:
    bool empty() const
    {
        return items_.empty();
    }

    size_type size() const
    {
        return items_.size();
    }

    void clear();

    value_type const& top() const
    {
        return items_[top_index()];
    }

    value_type const& second() const
    {
        return items_[second_index()];
    }

    element_type const& get(identifier_type id) const
    {
        return items_[policy_type::index(id)].second;
    }

    void pop()
    {
        pop_by_index(top_index());
    }

    void pop(identifier_type id)
    {
        pop_by_index(policy_type::index(id));
    }

    void replace(value_type const& item);

    identifier_type push(element_type const& item);

    element_type const& operator[](identifier_type id) const
    {
        return get(id);
    }

    const_iterator begin() const
    {
        return items_.begin();
    }

    const_iterator end() const
    {
        return items_.end();
    }

    // self-diagnostic methods
    bool check() const; // check all
    bool check_size() const;
    bool check_position_mapping() const;
    bool check_heap() const;


protected:
    index_type top_index() const 
    {
        return heap_[0];
    }

    index_type second_index() const 
    {
        if (size() <= 1)
        {
            throw std::out_of_range("DynamicPriorityQueue::second_index():"
                                     " item count less than 2.");
        }

        const index_type index1(heap_[1]);

        if (size() == 2)
        {
            return index1;
        }

        const index_type index2(heap_[2]);
        if (comp(items_[index1].second, items_[index2].second))
        {
            return index1;
        }
        else
        {
            return index2;
        }
    }

    void pop_by_index(index_type index);

    void move(index_type index)
    {
        const index_type pos(position_vector_[index]);
        move_pos(pos);
    }

    void move_top()
    {
        move_down_pos(0);
    }

    void move_pos(index_type pos);

    void move_up(index_type index)
    {
        const index_type position(position_vector_[index]);
        move_up_pos(position);
    }

    void move_down(index_type index)
    {
        const index_type position(position_vector_[index]);
        move_down_pos(position);
    }


    void move_up_pos(index_type position, index_type start = 0);
    void move_down_pos(index_type position);

    void move_up_pos_impl(index_type position, index_type start = 0);
    void move_down_pos_impl(index_type position); 

private:
    value_vector items_;
    index_vector heap_;
    index_vector position_vector_;

    comparator_type comp;
};

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::clear()
{
    items_.clear();
    heap_.clear();
    position_vector_.clear();
    policy_type::clear();
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::move_pos(index_type pos)
{
    const index_type index(heap_[pos]);
    const value_type& item(items_[index]);
    const index_type succ(2 * pos + 1);
    if (succ < size())
    {
        if (comp(items_[heap_[succ]].second, item.second) || (succ + 1 < size() && comp(items_[heap_[succ + 1]].second, item.second)))
        {
            move_down_pos_impl(pos);
            return;
        }
    }

    move_up_pos(pos);
}

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::move_up_pos(index_type position, index_type start)
{
    if (position == 0)
        return;

    const index_type index(heap_[position]);
    const value_type& item(items_[index]);

    const index_type pred((position - 1) / 2);
    const index_type predindex_type(heap_[pred]);

    if (comp(item.second, items_[predindex_type].second))
    {
        move_up_pos_impl(position, start);
    }
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::move_down_pos(index_type position)
{
    const index_type index(heap_[position]);
    const value_type& item(items_[index]);

    const index_type succ(2 * position + 1);
    if (succ < size())
    {
        if (comp(items_[heap_[succ]].second, item.second) || (succ + 1 < size() && comp(items_[heap_[succ + 1]].second, item.second)))
        {
            move_down_pos_impl(position);
        }
    }
}

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::move_up_pos_impl(index_type position, index_type start)
{
    const index_type index(heap_[position]);
    const value_type& item(items_[index]);

    if (position <= start)
    {
        return;
    }

    index_type pos(position);
    index_type pred((pos - 1) / 2);
    index_type predindex_type(heap_[pred]);

    do
    {
        heap_[pos] = predindex_type;
        position_vector_[predindex_type] = pos;
        pos = pred;

        if (pos <= start)
        {
            break;
        }

        pred = (pos - 1) / 2;
        predindex_type = heap_[pred];

    } while (! comp(items_[predindex_type].second, item.second));

    heap_[pos] = index;
    position_vector_[index] = pos;
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::move_down_pos_impl(index_type position)
{
    const index_type index(heap_[position]);

    index_type succ(2 * position + 1);
    index_type pos(position);
    while (succ < size())
    {
        const index_type right_pos(succ + 1);
        if (right_pos < size() && !comp(items_[heap_[succ]].second, items_[heap_[right_pos]].second))
        {
            succ = right_pos;
        }

        heap_[pos] = heap_[succ];
        position_vector_[heap_[pos]] = pos;
        pos = succ;
        succ = 2 * pos + 1;
    }

    heap_[pos] = index;
    position_vector_[index] = pos;

    move_up_pos(pos, position);
}



template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline typename DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::identifier_type
DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::push(Titem_ const& item)
{
    const index_type index(items_.size());
    const identifier_type id(policy_type::push(index));
    items_.push_back(value_type(id, item));
    // index == pos at this time.
    heap_.push_back(index);
    position_vector_.push_back(index);
    move_up_pos(index); 
    return id;
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::pop_by_index(index_type index)
{
    value_type& item(items_[index]);
    // 1. update index<->identifier_type mapping.
    policy_type::pop(index, item.first, items_.back().first);

    // 2. pop the item from the items_.
    blit_swap(item, items_.back());
    items_.pop_back();

    const index_type removed_pos(position_vector_[index]);
    const index_type moved_pos(position_vector_.back());

    // 3. swap position_vector_[end] and position_vector_[index]
    position_vector_[index] = moved_pos;
    heap_[moved_pos] = index;

    // 4. if heap_[end] and heap_[removed] do not overlap,
    //    swap these, pop back, and update the heap_.
    if (removed_pos != heap_.size() - 1)
    {
        heap_[removed_pos] = heap_.back();
        position_vector_[heap_.back()] = removed_pos;

        position_vector_.pop_back();
        heap_.pop_back();

        move_pos(removed_pos);
    }
    else  // if heap_[end] and heap_[removed] are the same, simply pop back.
    {
        position_vector_.pop_back();
        heap_.pop_back();
    }
}

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline void DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::replace(value_type const& value)
{
    const index_type index(policy_type::index(value.first));
    items_[index].second = value.second;
    move(index);
}

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline bool DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::check() const
{
    bool result(true);

    result = result && check_size();
    result = result && check_position_mapping();
    result = result && check_heap();

    return result;
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline bool DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::check_size() const
{
    bool result(true);

    // check sizes of data structures.
    result = result && items_.size() == size();
    result = result && heap_.size() == size();
    result = result && position_vector_.size() == size();

    return result;
}


template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline bool DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::check_position_mapping() const
{
    bool result(true);

    // assert correct mapping between the heap_ and the position_vector_.
    for (index_type i(0); i < size(); ++i)
    {
        result = result && heap_[i] < size();
        result = result && position_vector_[i] < size();
        result = result && heap_[position_vector_[i]] == i;
    }

    return result;
}

template<typename Titem_, typename Tcomparator_, typename Tpolicy_>
inline bool DynamicPriorityQueue<Titem_, Tcomparator_, Tpolicy_>::check_heap() const
{
    bool result(true);

    // assert correct ordering of items in the heap_.

    for (index_type pos(0); pos < size(); ++pos)
    {
        const value_type& item(items_[heap_[pos]]);

        const index_type succ(pos * 2 + 1);
        if (succ < size())
        {
            result = result && 
                comp(item.second, items_[heap_[succ]].second);

            const index_type right_pos(succ + 1);
            if (right_pos < size())
            {
                result = result && comp(item.second, items_[heap_[right_pos]].second);
            }
        }

    }

    return result;
}


#endif // __DYNAMICPRIORITYQUEUE_HPP
 </xmp> 
<h3> EGFRDSimulatorFactory.hpp </h3> <xmp>

#ifndef EGFRD_SIMULATOR_FACTORY_HPP
#define EGFRD_SIMULATOR_FACTORY_HPP

#include "ParticleSimulatorFactory.hpp"
#include "EGFRDSimulator.hpp"
#include "CuboidalRegion.hpp"
#include "linear_algebra.hpp"

template<typename Ttraits_>
class EGFRDSimulatorFactory: public ParticleSimulatorFactory<Ttraits_>
{
public:
    typedef ParticleSimulatorFactory<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::traits_type world_traits_type;
    typedef typename traits_type::world_type world_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename world_traits_type::length_type length_type;
    typedef typename world_traits_type::size_type size_type;
    typedef typename world_traits_type::position_type position_type;
    typedef typename world_traits_type::rng_type rng_type;
    typedef CuboidalRegion<traits_type> cuboidal_region_type;

public:
    EGFRDSimulatorFactory(rng_type& rng): rng_(rng) {}

    virtual ~EGFRDSimulatorFactory() {}

    virtual EGFRDSimulator<traits_type>* operator()(ParticleModel const& model) const
    {
        length_type const world_size(boost::lexical_cast<length_type>(model["size"]));
        size_type matrix_size(3);
        int dissociation_retry_moves(3);

        try
        {
            matrix_size = boost::lexical_cast<length_type>(model["matrix_size"]);
        }
        catch (not_found const&) {}

        try
        {
            dissociation_retry_moves = boost::lexical_cast<length_type>(model["dissociation_retry_moves"]);
        }
        catch (not_found const&) {}

        position_type const x(divide(position_type(world_size, world_size, world_size), 2));
        boost::shared_ptr<world_type> world(
            new world_type(world_size, matrix_size));
        world->add_structure(
            boost::shared_ptr<cuboidal_region_type>(
                new cuboidal_region_type(
                    "world",
                    typename cuboidal_region_type::shape_type(x, x))));

        BOOST_FOREACH (boost::shared_ptr<StructureType> st,
                       model.get_structure_types())
        {
            std::string const& type((*st)["type"]);
            // TODO: add surfaces to world
        }

        BOOST_FOREACH (boost::shared_ptr<SpeciesType> st,
                       model.get_species_types())
        {
            std::string const& structure_id((*st)["structure"]);
            world->add_species(
                typename world_traits_type::species_type(
                    st->id(),
                    boost::lexical_cast<typename world_traits_type::D_type>(
                        (*st)["D"]),
                    boost::lexical_cast<length_type>((*st)["radius"]),
                    boost::lexical_cast<typename world_traits_type::structure_id_type>(
                        structure_id.empty() ? "world": structure_id)
                    ));
        }

        return new EGFRDSimulator<traits_type>(
            world,
            boost::shared_ptr<network_rules_type>(
                new network_rules_type(model.network_rules())),
            rng_, dissociation_retry_moves);
    }

protected:
    rng_type& rng_;
};

#endif /* EGFRD_SIMULATION_HPP */
 </xmp> 
<h3> EGFRDSimulator.hpp </h3> <xmp>

#ifndef EGFRDSIMULATOR_HPP
#define EGFRDSIMULATOR_HPP

#include <boost/bind.hpp>
#include <boost/array.hpp>
#include <boost/format.hpp>
#include <boost/optional.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/lambda/lambda.hpp>
#include <boost/lambda/bind.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/fusion/container/map.hpp>
#include <boost/fusion/algorithm/iteration/for_each.hpp>
#include <boost/fusion/sequence/intrinsic/at_key.hpp>
#include <boost/fusion/sequence/intrinsic/value_at_key.hpp>
#include <boost/fusion/include/at_key.hpp>
#include <boost/none_t.hpp>
#include <boost/variant.hpp>
#include "utils/array_helper.hpp"
#include "utils/get_mapper_mf.hpp"
#include "utils/fun_composition.hpp"
#include "utils/fun_wrappers.hpp"
#include "utils/pointer_as_ref.hpp"
#include "utils/pair.hpp"
#include "utils/math.hpp"
#include "utils/stringizer.hpp"
#include "ShellID.hpp"
#include "DomainID.hpp"
#include "Shell.hpp"
#include "EventScheduler.hpp"
#include "PairGreensFunction.hpp"
#include "ParticleSimulator.hpp"
#include "MatrixSpace.hpp"
#include "AnalyticalSingle.hpp"
#include "AnalyticalPair.hpp"
#include "Multi.hpp"
#include "GreensFunction3DRadAbs.hpp"
#include "GreensFunction3DRadInf.hpp"
#include "GreensFunction3DAbsSym.hpp"
#include "GreensFunction3DAbs.hpp"
#include "GreensFunction3D.hpp"

template<typename Tworld_>
struct EGFRDSimulatorTraitsBase: public ParticleSimulatorTraitsBase<Tworld_>
{
    typedef ParticleSimulatorTraitsBase<Tworld_> base_type;
    typedef Tworld_ world_type;
    typedef ShellID shell_id_type;
    typedef DomainID domain_id_type;
    typedef SerialIDGenerator<shell_id_type> shell_id_generator;
    typedef SerialIDGenerator<domain_id_type> domain_id_generator; typedef Domain<EGFRDSimulatorTraitsBase> domain_type;
    typedef std::pair<const domain_id_type, boost::shared_ptr<domain_type> > domain_id_pair;
    typedef int event_id_type;
    typedef EventScheduler<typename base_type::time_type> event_scheduler_type;
    typedef typename event_scheduler_type::Event event_type;
    typedef typename event_scheduler_type::value_type event_id_pair_type;

    template<typename Tshape_>
    struct shell_generator
    {
        typedef Shell<Tshape_, domain_id_type> type;
    };

    static const Real SAFETY = 1. + 1e-5;
    static const Real SINGLE_SHELL_FACTOR = .1;
    static const Real DEFAULT_DT_FACTOR = 1e-5;
    static const Real CUTOFF_FACTOR = 5.6;
};

namespace detail {

template<typename T_>
struct get_greens_function {};

template<typename T_>
struct get_greens_function<Sphere<T_> >
{
    typedef GreensFunction3DAbsSym type;
};

template<typename T_>
struct get_greens_function<Cylinder<T_> >
{
    typedef GreensFunction3DAbsSym type;
};

template<typename T_>
struct get_pair_greens_function {};

template<typename T_>
struct get_pair_greens_function<Sphere<T_> >
{
    typedef GreensFunction3DRadAbs iv_type;
    typedef GreensFunction3DAbsSym com_type;
};

template<typename T_>
struct get_pair_greens_function<Cylinder<T_> >
{
    typedef GreensFunction3DRadAbs iv_type;
    typedef GreensFunction3DAbsSym com_type;
};

} // namespace detail

template<typename Ttraits_>
class EGFRDSimulator;

template<typename Ttraits_>
struct ImmutativeDomainVisitor
{
    typedef typename EGFRDSimulator<Ttraits_>::multi_type multi_type;
    typedef typename EGFRDSimulator<Ttraits_>::spherical_single_type spherical_single_type;
    typedef typename EGFRDSimulator<Ttraits_>::cylindrical_single_type cylindrical_single_type;
    typedef typename EGFRDSimulator<Ttraits_>::spherical_pair_type spherical_pair_type;
    typedef typename EGFRDSimulator<Ttraits_>::cylindrical_pair_type cylindrical_pair_type;

    virtual ~ImmutativeDomainVisitor() {}

    virtual void operator()(multi_type const&) const = 0;

    virtual void operator()(spherical_single_type const&) const = 0;

    virtual void operator()(cylindrical_single_type const&) const = 0;

    virtual void operator()(spherical_pair_type const&) const = 0;

    virtual void operator()(cylindrical_pair_type const&) const = 0;
};

template<typename Ttraits_>
struct MutativeDomainVisitor
{
    typedef typename EGFRDSimulator<Ttraits_>::multi_type multi_type;
    typedef typename EGFRDSimulator<Ttraits_>::spherical_single_type spherical_single_type;
    typedef typename EGFRDSimulator<Ttraits_>::cylindrical_single_type cylindrical_single_type;
    typedef typename EGFRDSimulator<Ttraits_>::spherical_pair_type spherical_pair_type;
    typedef typename EGFRDSimulator<Ttraits_>::cylindrical_pair_type cylindrical_pair_type;

    virtual ~MutativeDomainVisitor() {}

    virtual void operator()(multi_type&) const = 0;

    virtual void operator()(spherical_single_type&) const = 0;

    virtual void operator()(cylindrical_single_type&) const = 0;

    virtual void operator()(spherical_pair_type&) const = 0;

    virtual void operator()(cylindrical_pair_type&) const = 0;
};


#define CHECK(expr) \
    do \
    { \
        if (!(expr)) { retval = false; LOG_DEBUG(("checking [%s] failed", #expr)); } \
    } while (0)

template<typename Ttraits_>
class EGFRDSimulator: public ParticleSimulator<Ttraits_>
{
public:
    typedef Ttraits_ traits_type;
    typedef ParticleSimulator<Ttraits_> base_type;
    typedef typename base_type::sphere_type sphere_type;
    typedef typename base_type::cylinder_type cylinder_type;
    typedef typename base_type::particle_simulation_structure_type particle_simulation_structure_type;
    typedef typename base_type::spherical_surface_type spherical_surface_type;
    typedef typename base_type::cylindrical_surface_type cylindrical_surface_type;
    typedef typename base_type::planar_surface_type planar_surface_type;
    typedef typename base_type::cuboidal_region_type cuboidal_region_type;
    typedef typename traits_type::world_type world_type;
    typedef typename traits_type::domain_id_type domain_id_type;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::template shell_generator<sphere_type>::type spherical_shell_type;
    typedef typename traits_type::template shell_generator<cylinder_type>::type cylindrical_shell_type;
    typedef std::pair<const shell_id_type, spherical_shell_type> spherical_shell_id_pair;
    typedef std::pair<const shell_id_type, cylindrical_shell_type> cylindrical_shell_id_pair;
    typedef typename traits_type::shell_id_generator shell_id_generator;
    typedef typename traits_type::domain_id_generator domain_id_generator;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename world_type::traits_type::length_type length_type;
    typedef typename world_type::traits_type::position_type position_type;
    typedef typename world_type::traits_type::rng_type rng_type;
    typedef typename world_type::traits_type::particle_type particle_type;
    typedef typename world_type::traits_type::D_type D_type;
    typedef typename world_type::traits_type::species_type species_type;
    typedef typename world_type::traits_type::species_id_type species_id_type;
    typedef typename world_type::traits_type::structure_type structure_type;
    typedef typename world_type::particle_shape_type particle_shape_type;
    typedef typename world_type::traits_type::particle_id_type particle_id_type;
    typedef typename world_type::particle_id_pair particle_id_pair;
    typedef typename world_type::particle_id_pair_and_distance particle_id_pair_and_distance;
    typedef typename world_type::particle_id_pair_and_distance_list particle_id_pair_and_distance_list;

    typedef typename traits_type::domain_type domain_type;
    typedef typename traits_type::domain_id_pair domain_id_pair;
    typedef typename traits_type::time_type time_type;

    typedef Single<traits_type> single_type;
    typedef Pair<traits_type> pair_type;
    typedef Multi<EGFRDSimulator> multi_type;
    typedef ShapedDomain<traits_type> shaped_domain_type;
    typedef AnalyticalSingle<traits_type, spherical_shell_type> spherical_single_type;
    typedef AnalyticalSingle<traits_type, cylindrical_shell_type> cylindrical_single_type;
    typedef AnalyticalPair<traits_type, spherical_shell_type> spherical_pair_type;
    typedef AnalyticalPair<traits_type, cylindrical_shell_type> cylindrical_pair_type;

    typedef typename traits_type::reaction_record_type reaction_record_type;
    typedef typename traits_type::reaction_recorder_type reaction_recorder_type;
    typedef typename traits_type::event_scheduler_type event_scheduler_type;
    typedef typename traits_type::event_type event_type;
    typedef typename traits_type::event_id_type event_id_type;
    typedef typename traits_type::event_id_pair_type event_id_pair_type;
    typedef boost::variant<boost::none_t, spherical_shell_type, cylindrical_shell_type> shell_variant_type;

    enum domain_kind
    {
        NONE = 0,
        SPHERICAL_SINGLE,
        CYLINDRICAL_SINGLE,
        SPHERICAL_PAIR,
        CYLINDRICAL_PAIR,
        MULTI,
        NUM_DOMAIN_KINDS
    };

    enum single_event_kind
    {
        SINGLE_EVENT_REACTION,
        SINGLE_EVENT_ESCAPE,
        NUM_SINGLE_EVENT_KINDS
    };

    enum pair_event_kind
    {
        PAIR_EVENT_SINGLE_REACTION_0,
        PAIR_EVENT_SINGLE_REACTION_1,
        PAIR_EVENT_COM_ESCAPE,
        PAIR_EVENT_IV_UNDETERMINED,
        PAIR_EVENT_IV_ESCAPE,
        PAIR_EVENT_IV_REACTION,
        NUM_PAIR_EVENT_KINDS
    };

protected:
    typedef boost::fusion::map<
        boost::fusion::pair<spherical_shell_type, 
                            MatrixSpace<spherical_shell_type,
                                        shell_id_type, get_mapper_mf>&>,
        boost::fusion::pair<cylindrical_shell_type, MatrixSpace<cylindrical_shell_type,
                                        shell_id_type, get_mapper_mf>&> >
            shell_matrix_map_type;
    typedef typename boost::remove_reference<
        typename boost::fusion::result_of::value_at_key<
            shell_matrix_map_type,
            spherical_shell_type>::type>::type
                spherical_shell_matrix_type;
    typedef typename boost::remove_reference<
        typename boost::fusion::result_of::value_at_key<
            shell_matrix_map_type,
            cylindrical_shell_type>::type>::type
                cylindrical_shell_matrix_type;
    typedef typename get_mapper_mf<domain_id_type, boost::shared_ptr<domain_type> >::type domain_map;
    typedef typename network_rules_type::reaction_rules reaction_rules;
    typedef typename network_rules_type::reaction_rule_type reaction_rule_type;
    typedef typename traits_type::rate_type rate_type;

    struct domain_event_base: public event_type
    {
        domain_event_base(time_type time): event_type(time) {}

        virtual domain_type& domain() const = 0;
    };

    template<typename Tdomain_, typename TeventKind_>
    class domain_event: public domain_event_base
    {
    public:
        typedef domain_event_base base_type;
        typedef Tdomain_ domain_type;
        typedef TeventKind_ event_kind_type;

    public:
        virtual domain_type& domain() const { return domain_; }

        virtual ~domain_event() {}

        event_kind_type kind() const { return kind_; }

        domain_event(time_type time,
                     domain_type& domain,
                     event_kind_type kind)
            : base_type(time), domain_(domain), kind_(kind) {}

    private:
        domain_type& domain_;
        event_kind_type kind_;
    };

    typedef domain_event<single_type, single_event_kind> single_event;
    typedef domain_event<pair_type, pair_event_kind> pair_event;

    class multi_event: public domain_event_base
    {
    public:
        typedef domain_event_base base_type;
        typedef multi_type domain_type;

    public:
        virtual domain_type& domain() const { return domain_; }

        virtual ~multi_event() {}

        multi_event(time_type time,
                     domain_type& domain)
            : base_type(time), domain_(domain) {}

    private:
        domain_type& domain_;
    };

    struct intruder_collector
    {
        intruder_collector(world_type const& world,
                           particle_shape_type const& cmp,
                           domain_id_type const& ignore)
            : world(world), cmp(cmp), ignore(ignore),
              closest(domain_id_type(),
                      std::numeric_limits<length_type>::infinity()) {}

        template<typename Titer>
        void operator()(Titer const& i, position_type const& off)
        {
            domain_id_type const& did((*i).second.did());
            if (did == ignore)
                return;

            length_type const distance(
                    world.distance(
                        shape(offset((*i).second, off)), cmp.position()));
            if (distance > cmp.radius())
            {
                if (distance < closest.second)
                {
                    closest.first = did;
                    closest.second = distance;
                }
            }
            else
            {
                if (!intruders.container())
                {
                    intruders.container().set(new std::vector<domain_id_type>());
                }
                intruders.push_no_duplicate(did);
            }
        }

        world_type const& world;
        particle_shape_type cmp;
        domain_id_type ignore;
        std::pair<domain_id_type, length_type> closest;
        sorted_list<std::vector<domain_id_type>,
                    std::less<domain_id_type>,
                    pointer_as_ref<std::vector<domain_id_type> > > intruders;
    };

    struct no_filter
    {
        bool operator()(domain_id_type const&) const { return true; }
    };

    struct one_id_filter
    {
        bool operator()(domain_id_type const& did) const { return did != ignore; }
        one_id_filter(domain_id_type const& did): ignore(did) {}

        domain_id_type const ignore;
    };

    template<typename TfilterFn_>
    struct domain_collector 
    {
        typedef TfilterFn_ filter_function;

        domain_collector(world_type const& world,
                        particle_shape_type const& cmp,
                        filter_function const& filter)
            : world(world), cmp(cmp), filter(filter) {}

        template<typename Titer>
        void operator()(Titer const& i, position_type const& off)

        {
            domain_id_type const& did((*i).second.did());
            if (!filter(did))
                return;

            length_type const distance(world.distance(shape(offset((*i).second, off)), cmp.position()));
            if (distance < cmp.radius())
            {
                if (!neighbors.container())
                {
                    neighbors.container().set(new std::vector<domain_id_type>());
                }
                neighbors.push_no_duplicate(did);
            }
        }

        world_type const& world;
        particle_shape_type cmp;
        filter_function const& filter;

        std::pair<domain_id_type, length_type> closest;
        sorted_list<std::vector<domain_id_type>,
                    std::less<domain_id_type>,
                    pointer_as_ref<std::vector<domain_id_type> > > neighbors;
    };

    template<typename TdidSet_>
    struct closest_object_finder
    {
        typedef TdidSet_ domain_id_set;

        closest_object_finder(world_type const& world,
                              position_type const& cmp,
                              domain_id_set const& ignore)
            : world(world), cmp(cmp), ignore(ignore),
              closest(domain_id_type(),
                      std::numeric_limits<length_type>::infinity()) {}

        template<typename Titer>
        void operator()(Titer const& i, position_type const& off)
        {
            domain_id_type const& did((*i).second.did());
            if (contains(ignore, did))
                return;

            length_type const distance(world.distance(shape(offset((*i).second, off)), cmp));
            if (distance < closest.second)
            {
                closest.first = did;
                closest.second = distance;
            }
        }

        world_type const& world;
        position_type cmp;
        domain_id_set const& ignore;
        std::pair<domain_id_type, length_type> closest;
    };

    template<typename Tcol_>
    struct shell_collector_applier
    {
        typedef Tcol_ collector_type;

        shell_collector_applier(collector_type& col,
                                   position_type const& pos)
            : col_(col), pos_(pos) {}

        template<typename T>
        void operator()(T const& smat) const
        {
            world_type::traits_type::each_neighbor(smat.second, col_, pos_);
        }

    private:
        collector_type& col_;
        position_type pos_;
    };

    struct distance_calculator
    {
        distance_calculator(world_type const& world,
                            position_type const& pos)
            : world_(world), pos_(pos) {}

        template<typename Tshape_>
        length_type operator()(Tshape_ const& shape) const
        {
            return world_.distance(shape, pos_);
        }

    private:
        world_type const& world_;
        position_type pos_;
    };

    template<typename Tmap_>
    struct domain_shell_map_builder
    {
        typedef Tmap_ domain_shell_association;
        domain_shell_map_builder(world_type const& world,
                                 domain_shell_association& did_map)
            : world_(world), did_map_(did_map) {}

        template<typename T>
        void operator()(T const& smat) const
        {
            BOOST_ASSERT(world_.world_size() == smat.second.world_size());
            BOOST_FOREACH (typename boost::remove_reference<typename T::second_type>::type::value_type pair, smat.second)
            {
                did_map_[pair.second.did()].insert(pair.first);
            }
        }

    private:
        world_type const& world_;
        domain_shell_association& did_map_;
    };

    template<typename Tset_>
    struct shell_id_collector
    {
        shell_id_collector(Tset_& shell_ids)
            : shell_ids_(shell_ids) {}

        template<typename T>
        void operator()(T const& smat) const
        {
            std::for_each(
                boost::begin(smat.second),
                boost::end(smat.second),
                compose_unary(
                    boost::bind(&insert<Tset_>,
                                boost::reference_wrapper<Tset_>(shell_ids_),
                                _1),
                    select_first<typename boost::remove_reference<
                        typename T::second_type>::type::value_type>()));
        }

    private:
        Tset_& shell_ids_;
    };

    struct shell_finder
    {
        shell_finder(shell_id_type const& id, shell_variant_type& result)
            : id(id), result(result) {}

        template<typename T>
        void operator()(T const& smat) const
        {
            typename boost::remove_reference<typename T::second_type>::type::const_iterator i(smat.second.find(id));
            if (i != smat.second.end())
            {
                result = (*i).second;
            }
        }

        shell_id_type id;
        shell_variant_type& result;
    };

    struct draw_on_com_escape
    {
        position_type draw_com(spherical_pair_type const& domain,
                               time_type dt) const
        {
            return add(
                domain.shell().second.position(),
                normalize(
                    create_vector<position_type>(
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.)),
                    domain.a_R()));

        }

        position_type draw_iv(spherical_pair_type const& domain,
                              time_type dt, position_type const& old_iv) const
        {
            boost::scoped_ptr<PairGreensFunction> const gf(
                choose_pair_greens_function(domain, dt));
            length_type const r(draw_r(
                rng_, *gf, dt, domain.a_r(), domain.sigma()));
            length_type const theta(draw_theta(rng_, *gf, dt, r));
            return adjust_iv_with_old_iv(
                spherical_to_cartesian(
                    array_gen(r, theta, rng_.uniform(0., 1.) * 2 * M_PI)),
                old_iv);
        }

        position_type draw_com(cylindrical_pair_type const& domain,
                               time_type dt) const
        {
            boost::shared_ptr<structure_type> const _structure(
                world_.get_structure(
                    world_.get_species(
                        domain.particles()[0].second.sid())
                    .structure_id()));
            
            cylindrical_surface_type const* const structure(
                dynamic_cast<cylindrical_surface_type*>(_structure.get()));

            return add(
                domain.shell().second.position(),
                multiply(structure->shape().unit_z(), domain.a_R()));
        }

        position_type draw_iv(cylindrical_pair_type const& domain,
                              time_type dt, position_type const& old_iv) const
        {
            BOOST_ASSERT(::size(domain.reactions()) == 1);
            length_type const r(
                draw_r(rng_, GreensFunction3DRadAbs(domain.D_tot(),
                    domain.reactions()[0].k(), domain.r0(),
                    domain.sigma(), domain.a_r()),
                   dt, domain.a_r(), domain.sigma()));
            return multiply(normalize(old_iv), r);
        }

        draw_on_com_escape(rng_type& rng, world_type const& world)
            : rng_(rng), world_(world) {}

        rng_type& rng_;
        world_type const& world_;
    };

    struct draw_on_single_reaction
    {
        position_type draw_com(spherical_pair_type const& domain,
                               time_type dt) const
        {
            return add(
                domain.shell().second.position(),
                draw_r(rng_,
                        GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                        dt, domain.a_R()));

        }

        position_type draw_iv(spherical_pair_type const& domain,
                              time_type dt, position_type const& old_iv) const
        {
            boost::scoped_ptr<PairGreensFunction> const gf(
                choose_pair_greens_function(domain, dt));
            length_type const r(draw_r(
                rng_, *gf, dt, domain.a_r(), domain.sigma()));
            length_type const theta(draw_theta(rng_, *gf, dt, r));
            return adjust_iv_with_old_iv(
                spherical_to_cartesian(
                    array_gen(r, theta, rng_.uniform(0., 1.) * 2 * M_PI)),
                old_iv);
        }

        position_type draw_com(cylindrical_pair_type const& domain,
                               time_type dt) const
        {
            boost::shared_ptr<structure_type> const _structure(
                world_.get_species(
                    domain.particles()[0].second.sid())
                .structure_id());
            
            cylindrical_surface_type const* const structure(
                dynamic_cast<cylindrical_surface_type*>(_structure.get()));

            BOOST_ASSERT(structure);

            return add(
                domain.shell().second.position(),
                multiply(structure->shape().unit_z(), domain.a_R()));
        }

        position_type draw_iv(cylindrical_pair_type const& domain,
                              time_type dt, position_type const& old_iv) const
        {
            BOOST_ASSERT(::size(domain.reactions()) == 1);
            length_type const r(
                draw_r(rng_, GreensFunction3DRadAbs(domain.D_tot(),
                    domain.reactions()[0].k(), domain.r0(),
                    domain.sigma(), domain().a_r()),
                   dt, domain.a_r(), domain.sigma()));
            BOOST_ASSERT(r > domain.sigma() && r <= domain.a_r());
            return multiply(normalize(old_iv), r);
        }

        draw_on_single_reaction(rng_type& rng, world_type const& world)
            : rng_(rng), world_(world) {}

        rng_type& rng_;
        world_type const& world_;
    };

    struct draw_on_iv_escape
    {
        position_type draw_com(spherical_pair_type const& domain,
                               time_type dt)
        {
            return add(
                domain.shell().second.position(),
                normalize(
                    create_vector<position_type>(
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.)),
                    draw_r(
                        rng_,
                        GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                        dt, domain.a_R())));
        }

        position_type draw_iv(spherical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            boost::scoped_ptr<PairGreensFunction> const gf(
                choose_pair_greens_function(domain, dt));
            length_type const r(domain.a_r());
            length_type const theta(draw_theta(rng_, *gf, dt, r));
            return adjust_iv_with_old_iv(
                spherical_to_cartesian(
                    array_gen(r, theta, rng_.uniform(0., 1.) * 2 * M_PI)),
                old_iv);
        }

        position_type draw_com(cylindrical_pair_type const& domain,
                               time_type dt)
        {
            boost::shared_ptr<structure_type> const _structure(
                world_.get_structure(
                    world_.get_species(
                        domain.particles()[0].second.sid())
                    .structure_id()));
            
            cylindrical_surface_type const* const structure(
                dynamic_cast<cylindrical_surface_type*>(_structure.get()));

            BOOST_ASSERT(structure);

            length_type const r_R(draw_r(
                rng_,
                GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                dt, domain.a_R()));
            return add(
                domain.shell().second.position(),
                multiply(structure->shape().unit_z(), r_R));
        }

        position_type draw_iv(cylindrical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            return multiply(normalize(old_iv), domain.a_r());
        }

        draw_on_iv_escape(rng_type& rng, world_type const& world)
            : rng_(rng), world_(world) {}

        rng_type& rng_;
        world_type const& world_;
    };

    struct draw_on_iv_reaction
    {
        position_type draw_com(spherical_pair_type const& domain,
                               time_type dt)
        {
            return add(
                domain.shell().second.position(),
                normalize(
                    create_vector<position_type>(
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.)),
                    draw_r(
                        rng_,
                        GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                        dt, domain.a_R())));
        }

        position_type draw_iv(spherical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            boost::scoped_ptr<PairGreensFunction> const gf(
                choose_pair_greens_function(domain, dt));
            length_type const r(domain.sigma());
            length_type const theta(draw_theta(rng_, *gf, dt, r));
            return adjust_iv_with_old_iv(
                spherical_to_cartesian(
                    array_gen(r, theta, rng_.uniform(0., 1.) * 2 * M_PI)),
                old_iv);
        }

        position_type draw_com(cylindrical_pair_type const& domain,
                               time_type dt)
        {
            boost::shared_ptr<structure_type> const _structure(
                world_.get_structure(
                    world_.get_species(
                        domain.particles()[0].second.sid()).structure_id()));
            
            cylindrical_surface_type const* const structure(
                dynamic_cast<cylindrical_surface_type*>(_structure.get()));

            BOOST_ASSERT(structure);

            length_type const r_R(draw_r(
                rng_,
                GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                dt, domain.a_R()));
            return add(
                domain.shell().second.position(),
                multiply(structure->shape().unit_z(), r_R));
        }

        position_type draw_iv(cylindrical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            return multiply(domain.sigma(), normalize(old_iv));
        }

        draw_on_iv_reaction(rng_type& rng, world_type const& world)
            : rng_(rng), world_(world) {}

        rng_type& rng_;
        world_type const& world_;
    };

    struct draw_on_burst
    {
        position_type draw_com(spherical_pair_type const& domain,
                               time_type dt)
        {
            return add(
                domain.shell().second.position(),
                normalize(
                    create_vector<position_type>(
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.),
                        rng_.uniform(-1., 1.)),
                    draw_r(
                        rng_,
                        GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                        dt, domain.a_R())));
        }

        position_type draw_iv(spherical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            boost::scoped_ptr<PairGreensFunction> const gf(
                choose_pair_greens_function(domain, dt));
            length_type const r(draw_r(
                rng_, *gf, dt, domain.a_r(), domain.sigma()));
            length_type const theta(draw_theta(rng_, *gf, dt, r));
            return adjust_iv_with_old_iv(
                spherical_to_cartesian(
                    array_gen(r, theta, rng_.uniform(0., 1.) * 2 * M_PI)),
                old_iv);
        }

        position_type draw_com(cylindrical_pair_type const& domain,
                               time_type dt)
        {
            boost::shared_ptr<structure_type> const _structure(
                world_.get_structure(
                    world_.get_species(
                        domain.particles()[0].second.sid())
                    .structure_id()));

            cylindrical_surface_type const* const structure(
                dynamic_cast<cylindrical_surface_type*>(_structure.get()));

            BOOST_ASSERT(structure);

            length_type const r_R(draw_r(
                rng_,
                GreensFunction3DAbsSym(domain.D_R(), domain.a_R()),
                dt, domain.a_R()));
            return add(
                domain.shell().second.position(),
                multiply(structure->shape().unit_z(), r_R));
        }

        position_type draw_iv(cylindrical_pair_type const& domain,
                              time_type dt, position_type const& old_iv)
        {
            BOOST_ASSERT(::size(domain.reactions()) == 1);
            length_type const r(
                draw_r(rng_,
                    GreensFunction3DRadAbs(
                        domain.D_tot(),
                        domain.reactions()[0].k(), domain.r0(),
                        domain.sigma(), domain.a_r()),
                    dt, domain.a_r(), domain.sigma()));
            return multiply(normalize(old_iv), r);
        }

        draw_on_burst(rng_type& rng, world_type const& world)
            : rng_(rng), world_(world) {}

        rng_type& rng_;
        world_type const& world_;
    };
public:
    typedef abstract_limited_generator<domain_id_pair> domain_id_pair_generator;

public:
    virtual ~EGFRDSimulator()
    {
        //std::for_each(domains_.begin(), domains_.end(),
        //    compose_unary(delete_ptr<domain_type>(),
        //                  select_second<typename domain_map::value_type>()));
    }

    EGFRDSimulator(boost::shared_ptr<world_type> world,
                   boost::shared_ptr<network_rules_type const> network_rules,
                   rng_type& rng, int dissociation_retry_moves = 1,
                   Real bd_dt_factor = 1e-5, 
                   length_type user_max_shell_size =
                    std::numeric_limits<length_type>::infinity())
        : base_type(world, network_rules, rng),
          num_retries_(dissociation_retry_moves),
          bd_dt_factor_(bd_dt_factor),
          user_max_shell_size_(user_max_shell_size),
          ssmat_((*world).world_size(), (*world).matrix_size()),
          csmat_((*world).world_size(), (*world).matrix_size()),
          smatm_(boost::fusion::pair<spherical_shell_type,
                                     spherical_shell_matrix_type&>(ssmat_),
                 boost::fusion::pair<cylindrical_shell_type,
                                     cylindrical_shell_matrix_type&>(csmat_)),
          single_shell_factor_(.1),
          multi_shell_factor_(.05),
          rejected_moves_(0), zero_step_count_(0), dirty_(true)
    {
        std::fill(domain_count_per_type_.begin(), domain_count_per_type_.end(), 0);
        std::fill(single_step_count_.begin(), single_step_count_.end(), 0);
        std::fill(pair_step_count_.begin(), pair_step_count_.end(), 0);
        std::fill(multi_step_count_.begin(), multi_step_count_.end(), 0);
    }

    length_type user_max_shell_size() const
    {
        return user_max_shell_size_;
    }

    length_type max_shell_size() const
    {
        return std::min((*base_type::world_).cell_size() / 2 /
                        traits_type::SAFETY,
                   user_max_shell_size_);
    }

    template<typename Tshape>
    std::pair<const shell_id_type,
              typename traits_type::template shell_generator<Tshape>::type>
    new_shell(domain_id_type const& did, Tshape const& shape)
    {
        typedef typename traits_type::template shell_generator<Tshape>::type shell_type;
        std::pair<const shell_id_type, shell_type> const retval(shidgen_(), shell_type(did, shape));
        boost::fusion::at_key<shell_type>(smatm_).update(retval);
        return retval;
    }

    template<typename T>
    std::pair<const shell_id_type, T> const& get_shell(shell_id_type const& id) const
    {
        typedef typename boost::remove_reference<
            typename boost::fusion::result_of::value_at_key<
                shell_matrix_map_type, T>::type>::type shell_matrix_type;

        shell_matrix_type const& smat(boost::fusion::at_key<T>(smatm_));
        
        typename shell_matrix_type::const_iterator i(smat.find(id));
        if (i == smat.end())
        {
            throw not_found(
                (boost::format("shell id #%s not found") % boost::lexical_cast<std::string>(id)).str());
        }

        return *i;
    }

    std::pair<shell_id_type, shell_variant_type> get_shell(shell_id_type const& id)
    {
        shell_variant_type result;
        boost::fusion::for_each(smatm_, shell_finder(id, result));
        return std::make_pair(id, result);
    }

    boost::shared_ptr<domain_type> get_domain(domain_id_type const& id) const
    {
        typename domain_map::const_iterator i(domains_.find(id));

        if (i == domains_.end())
        {
            throw not_found(
                (boost::format("domain id #%s not found") % boost::lexical_cast<std::string>(id)).str());
        }

        return (*i).second;
    }

    domain_id_pair_generator* get_domains() const
    {
        return make_range_generator<domain_id_pair>(domains_);
    }

    typename domain_map::size_type num_domains() const
    {
        return domains_.size();
    }

    int num_domains_per_type(domain_kind kind) const
    {
        return domain_count_per_type_[kind];
    }

    int num_single_steps_per_type(single_event_kind kind) const
    {
        return single_step_count_[kind];
    }

    int num_pair_steps_per_type(pair_event_kind kind) const
    {
        return pair_step_count_[kind];
    }

    int num_multi_steps_per_type(typename multi_type::event_kind kind) const
    {
        return multi_step_count_[kind];
    }

    std::vector<domain_id_type>*
    get_neighbor_domains(particle_shape_type const& p)
    {
        typedef domain_collector<no_filter> collector_type;
        no_filter f;
        collector_type col((*base_type::world_), p, f);
        boost::fusion::for_each(smatm_, shell_collector_applier<collector_type>(col, p.position()));
        return col.neighbors.container().get();
    }

    std::vector<domain_id_type>*
    get_neighbor_domains(particle_shape_type const& p, domain_id_type const& ignore)
    {
        typedef domain_collector<one_id_filter> collector_type;
        one_id_filter f(ignore);
        collector_type col((*base_type::world_), p, f);
        boost::fusion::for_each(smatm_, shell_collector_applier<collector_type>(col, p.position()));
        return col.neighbors.container().get();
    }

    virtual void initialize()
    {
        domains_.clear();
        ssmat_.clear();
        csmat_.clear();

        BOOST_FOREACH (particle_id_pair const& pp,
                       (*base_type::world_).get_particles_range())
        {
            boost::shared_ptr<single_type> single(create_single(pp));
            add_event(*single, SINGLE_EVENT_ESCAPE);
        }
        dirty_ = false;
    }

    virtual void step()
    {
        _step();
    }

    virtual bool step(time_type upto)
    {
        LOG_INFO(("stop at %g", upto));

        if (upto >= base_type::t_)
        {
            return false;
        }

        if (upto >= scheduler_.top().second->time())
        {
            _step();
            return true;
        }

        base_type::t_ = upto;

        std::vector<domain_id_type> non_singles;

        // first burst all Singles.
        BOOST_FOREACH (event_id_pair_type const& event, scheduler_.events())
        {
            single_event const* single_ev(
                    dynamic_cast<single_event const*>(event.second.get()));
            if (single_ev)
            {
                burst(single_ev->domain());
            }
            else
            {
                domain_event_base const* domain_ev(
                    dynamic_cast<domain_event_base const*>(event.second.get()));
                BOOST_ASSERT(domain_ev);
                non_singles.push_back(domain_ev->domain().id());
            }
        }

        // then burst all Pairs and Multis.
        burst_domains(non_singles);

        base_type::dt_ = 0.;

        return false;
    }

    // {{{ clear_volume
    // called by Multi
    void clear_volume(particle_shape_type const& p)
    {
        boost::scoped_ptr<std::vector<domain_id_type> > domains(
            get_neighbor_domains(p));
        if (domains)
        {
            burst_domains(*domains);
        }
    }

    void clear_volume(particle_shape_type const& p,
                      domain_id_type const& ignore)
    {
        boost::scoped_ptr<std::vector<domain_id_type> > domains(
            get_neighbor_domains(p, ignore));

        if (domains)
        {
            burst_domains(*domains);
        }
    }
    // }}}

    bool check() const
    {
        LOG_INFO(("checking overall consistency"));

        bool retval(true);

        CHECK(base_type::t_ >= 0.0);
        CHECK(base_type::dt_ >= 0.0);

        typedef std::map<domain_id_type, std::set<shell_id_type> >
            domain_shell_association;

        domain_shell_association did_map;

        boost::fusion::for_each(smatm_,
                domain_shell_map_builder<domain_shell_association>(
                    (*base_type::world_), did_map));

        std::set<domain_id_type> scheduled_domains;
        typename domain_type::size_type shells_correspond_to_domains(0);
        std::size_t particles_correspond_to_domains(0);

        BOOST_FOREACH (typename event_scheduler_type::value_type const& value,
                       scheduler_.events())
        {
            domain_type const& domain(dynamic_cast<domain_event_base&>(*value.second).domain());
            CHECK(check_domain(domain));

            if (!scheduled_domains.insert(domain.id()).second)
            {
                LOG_WARNING(("domain id %s is doubly scheduled!", boost::lexical_cast<std::string>(domain.id()).c_str()));
            }

            CHECK(domain.event() == value);

            typename domain_type::size_type const num_shells(domain.num_shells());

            shells_correspond_to_domains += num_shells;
            particles_correspond_to_domains += domain.multiplicity();

            typename std::set<shell_id_type> const& shell_ids(
                did_map[domain.id()]);
            CHECK(static_cast<typename domain_type::size_type>(
                    ::size(shell_ids)) == num_shells);
        }

        CHECK((*base_type::world_).num_particles() == particles_correspond_to_domains);

        {
            std::vector<domain_id_type> diff;
            ::difference(make_select_first_range(did_map), scheduled_domains,
                    std::back_inserter(diff));

            if (diff.size() != 0)
            {
                LOG_WARNING(("domains not scheduled: %s",
                    stringize_and_join(diff, ", ").c_str()));
                BOOST_FOREACH (domain_id_type const& domain_id, diff)
                {
                    LOG_WARNING(("  shells that belong to unscheduled domain %s: %s",
                        boost::lexical_cast<std::string>(domain_id).c_str(),
                        stringize_and_join(did_map[domain_id], ", ").c_str()));
                }
                retval = false;
            }
        }

        std::set<shell_id_type> all_shell_ids;
        boost::fusion::for_each(smatm_,
                shell_id_collector<std::set<shell_id_type> >(all_shell_ids));

        if (shells_correspond_to_domains != static_cast<std::size_t>(::size(all_shell_ids)))
        {
            LOG_WARNING(("shells_correspond_to_domains=%zu, shell_population=%zu", shells_correspond_to_domains, static_cast<std::size_t>(::size(all_shell_ids))));
            dump_events();
            retval = false;
        }
        return retval;
    }

protected:
    template<typename Tshell>
    void move_shell(std::pair<const shell_id_type, Tshell> const& shell)
    {
        typedef Tshell shell_type;
        boost::fusion::at_key<shell_type>(smatm_).update(shell);
    }

    template<typename T>
    void update_shell_matrix(AnalyticalSingle<traits_type, T> const& domain)
    {
        move_shell(domain.shell());
    }

    template<typename T>
    void update_shell_matrix(AnalyticalPair<traits_type, T> const& domain)
    {
        move_shell(domain.shell());
    }

    void update_shell_matrix(shaped_domain_type const& domain)
    {
        {
            spherical_single_type const* _domain(dynamic_cast<spherical_single_type const*>(&domain));
            if (_domain) {
                update_shell_matrix(*_domain);
                return;
            }
        }
        {
            cylindrical_single_type const* _domain(dynamic_cast<cylindrical_single_type const*>(&domain));
            if (_domain) {
                update_shell_matrix(*_domain);
                return;
            }
        }
        {
            spherical_pair_type const* _domain(dynamic_cast<spherical_pair_type const*>(&domain));
            if (_domain) {
                update_shell_matrix(*_domain);
                return;
            }
        }
        {
            cylindrical_pair_type const* _domain(dynamic_cast<cylindrical_pair_type const*>(&domain));
            if (_domain) {
                update_shell_matrix(*_domain);
                return;
            }
        }
        throw not_implemented("unsupported domain type");
    }

    // remove_domain_but_shell {{{
    template<typename T>
    void remove_domain_but_shell(AnalyticalSingle<traits_type, T>& domain)
    {
        --domain_count_per_type_[get_domain_kind(domain)];
        _remove_domain_but_shell(domain);
    }

    template<typename T>
    void remove_domain_but_shell(AnalyticalPair<traits_type, T>& domain)
    {
        --domain_count_per_type_[get_domain_kind(domain)];
        _remove_domain_but_shell(domain);
    }

    void remove_domain_but_shell(multi_type& domain)
    {
        --domain_count_per_type_[get_domain_kind(domain)];
        _remove_domain_but_shell(domain);
    }

    void remove_domain_but_shell(domain_type& domain)
    {
        --domain_count_per_type_[get_domain_kind(domain)];
        _remove_domain_but_shell(domain);
    }

    void _remove_domain_but_shell(domain_type& domain)
    {
        LOG_DEBUG(("remove_domain_but_shell: %s", boost::lexical_cast<std::string>(domain.id()).c_str()));
        event_id_type const event_id(domain.event().first);
        domains_.erase(domain.id());
        try
        {
            remove_event(event_id);
        }
        catch (std::out_of_range const&)
        {
            LOG_DEBUG(("event %s already removed; ignoring.", boost::lexical_cast<std::string>(event_id).c_str()));
        }
    }

    // }}}

    // remove_domain {{{
    template<typename T>
    void remove_domain(AnalyticalSingle<traits_type, T>& domain)
    {
        typedef T shell_type;
        boost::fusion::at_key<shell_type>(smatm_).erase(domain.shell().first);
        remove_domain_but_shell(domain);
    }

    template<typename T>
    void remove_domain(AnalyticalPair<traits_type, T>& domain)
    {
        typedef T shell_type;
        boost::fusion::at_key<shell_type>(smatm_).erase(domain.shell().first);
        remove_domain_but_shell(domain);
    }

    void remove_domain(multi_type& domain)
    {
        typename multi_type::spherical_shell_id_pair_range r(domain.get_shells());
        spherical_shell_matrix_type& mat(
            boost::fusion::at_key<spherical_shell_type>(smatm_));
        std::for_each(boost::begin(r), boost::end(r),
            compose_unary(
                boost::bind(
                    static_cast<
                        bool(spherical_shell_matrix_type::*)(
                            typename spherical_shell_matrix_type::key_type
                            const&)>(&spherical_shell_matrix_type::erase),
                    mat, _1),
                select_first<spherical_shell_id_pair>()));
        remove_domain_but_shell(domain);
    }

    void remove_domain(domain_type& domain)
    {
        {
            spherical_single_type* _domain(dynamic_cast<spherical_single_type*>(&domain));
            if (_domain)
            {
                remove_domain(*_domain);
                return;
            }
        }
        {
            cylindrical_single_type* _domain(dynamic_cast<cylindrical_single_type*>(&domain));
            if (_domain)
            {
                remove_domain(*_domain);
                return;
            }
        }
        {
            spherical_pair_type* _domain(dynamic_cast<spherical_pair_type*>(&domain));
            if (_domain)
            {
                remove_domain(*_domain);
                return;
            }
        }
        {
            cylindrical_pair_type* _domain(dynamic_cast<cylindrical_pair_type*>(&domain));
            if (_domain)
            {
                remove_domain(*_domain);
                return;
            }
        }
        {
            multi_type* _domain(dynamic_cast<multi_type*>(&domain));
            if (_domain)
            {
                remove_domain(*_domain);
                return;
            }
        }
        throw not_implemented(std::string("unsupported domain type"));
    }
    // }}}

    void add_event(single_type& domain, single_event_kind const& kind)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        boost::shared_ptr<event_type> new_event(
            new single_event(base_type::t_ + domain.dt(), domain, kind));
        domain.event() = std::make_pair(scheduler_.add(new_event), new_event);
        LOG_DEBUG(("add_event: #%d - %s", domain.event().first, boost::lexical_cast<std::string>(domain).c_str()));
    }

    void add_event(pair_type& domain, pair_event_kind const& kind)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        boost::shared_ptr<event_type> new_event(
            new pair_event(base_type::t_ + domain.dt(), domain, kind));
        domain.event() = std::make_pair(scheduler_.add(new_event), new_event);
        LOG_DEBUG(("add_event: #%d - %s", domain.event().first, boost::lexical_cast<std::string>(domain).c_str()));
    }

    void add_event(multi_type& domain)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        boost::shared_ptr<event_type> new_event(
            new multi_event(base_type::t_ + domain.dt(), domain));
        domain.event() = std::make_pair(scheduler_.add(new_event), new_event);
        LOG_DEBUG(("add_event: #%d - %s", domain.event().first, boost::lexical_cast<std::string>(domain).c_str()));
    }

    void update_event(single_type& domain, single_event_kind const& kind)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        LOG_DEBUG(("update_event: #%d", domain.event().first));
        boost::shared_ptr<event_type> new_event(
            new single_event(base_type::t_ + domain.dt(), domain, kind));
        domain.event() = std::make_pair(domain.event().first, new_event);
        try
        {
            scheduler_.update(domain.event());
        }
        catch (std::exception const&)
        {
            throw;
        }
    }

    void update_event(pair_type& domain, pair_event_kind const& kind)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        LOG_DEBUG(("update_event: #%d", domain.event().first));
        boost::shared_ptr<event_type> new_event(
            new pair_event(base_type::t_ + domain.dt(), domain, kind));
        domain.event() = std::make_pair(domain.event().first, new_event);
        try
        {
            scheduler_.update(domain.event());
        }
        catch (std::exception const&)
        {
            throw;
        }
    }

    void update_event(multi_type& domain)
    {
        if (base_type::paranoiac_)
            BOOST_ASSERT(domains_.find(domain.id()) != domains_.end());

        LOG_DEBUG(("update_event: #%d", domain.event().first));
        boost::shared_ptr<event_type> new_event(
            new pair_event(base_type::t_ + domain.dt(), domain));
        domain.event() = std::make_pair(domain.event().first, new_event);
        try
        {
            scheduler_.update(domain.event());
        }
        catch (std::exception const&)
        {
            throw;
        }
    }

    void remove_event(event_id_type const& id)
    {
        LOG_DEBUG(("remove_event: #%d", id));
        scheduler_.remove(id);
    }

    // create_single {{{
    boost::shared_ptr<single_type> create_single(particle_id_pair const& p)
    {
        domain_kind kind(NONE);
        single_type* new_single(0);
        domain_id_type did(didgen_());

        struct factory: ImmutativeStructureVisitor<traits_type>
        {
            virtual ~factory() {}

            virtual void operator()(spherical_surface_type const& structure) const
            {
                throw not_implemented(
                    (boost::format("unsupported structure type: %s") %
                        boost::lexical_cast<std::string>(structure)).str());
            }

            virtual void operator()(cylindrical_surface_type const& structure) const
            {
                // Heads up. The cylinder's *size*, not radius, is changed when
                // you make the cylinder bigger, because of the redefinition of
                // set_radius.
                // The radius of a rod is not more than it has to be (namely
                // the radius of the particle), so if the particle undergoes an
                // unbinding reaction, we still have to clear the target volume
                // and the move may be rejected (NoSpace error).
                const cylindrical_shell_id_pair new_shell(
                    _this->new_shell(
                        did, cylinder_type(
                            p.second.position(), p.second.radius(),
                            structure.shape().unit_z(),
                            p.second.radius())));
                new_single = new cylindrical_single_type(did, p, new_shell);
                kind = CYLINDRICAL_SINGLE;
            }

            virtual void operator()(planar_surface_type const& structure) const
            {
                cylindrical_shell_id_pair const new_shell(
                    _this->new_shell(did, cylinder_type(
                        p.second.position(), p.second.radius(),
                        normalize(cross_product(
                            structure.shape().unit_x(),
                            structure.shape().unit_y())),
                        p.second.radius())));
                new_single = new cylindrical_single_type(did, p, new_shell);
                kind = CYLINDRICAL_SINGLE;
            }

            virtual void operator()(cuboidal_region_type const& structure) const
            {
                spherical_shell_id_pair new_shell(
                    _this->new_shell(did, ::shape(p.second)));
                new_single = new spherical_single_type(did, p, new_shell);
                kind = SPHERICAL_SINGLE;
            }

            factory(EGFRDSimulator* _this, particle_id_pair const& p,
                    domain_id_type const& did, single_type*& new_single,
                    domain_kind& kind)
                : _this(_this), p(p), did(did), new_single(new_single),
                  kind(kind) {}

            EGFRDSimulator* _this;
            particle_id_pair const& p;
            domain_id_type const& did;
            single_type*& new_single;
            domain_kind& kind;
        };

        species_type const& species((*base_type::world_).get_species(p.second.sid()));
        dynamic_cast<particle_simulation_structure_type const&>(*(*base_type::world_).get_structure(species.structure_id())).accept(factory(this, p, did, new_single, kind));
        boost::shared_ptr<domain_type> const retval(new_single);
        domains_.insert(std::make_pair(did, retval));
        BOOST_ASSERT(kind != NONE);
        ++domain_count_per_type_[kind];
        return boost::dynamic_pointer_cast<single_type>(retval);
    }
    // }}}

    // create_pair {{{
    boost::shared_ptr<pair_type> create_pair(particle_id_pair const& p0,
                                             particle_id_pair const& p1,
                                             position_type const& com,
                                             position_type const& iv,
                                             length_type shell_size)
    {
        domain_kind kind(NONE);
        pair_type* new_pair(0);
        domain_id_type did(didgen_());

        struct factory: ImmutativeStructureVisitor<traits_type>
        {
            virtual void operator()(spherical_surface_type const& structure) const
            {
                throw not_implemented(
                    (boost::format("unsupported structure type: %s") %
                        boost::lexical_cast<std::string>(structure)).str());
            }

            virtual void operator()(cylindrical_surface_type const& structure) const
            {
                // The radius of a rod is not more than it has to be (namely
                // the radius of the biggest particle), so if the particle
                // undergoes an unbinding reaction we still have to clear the
                // target volume and the move may be rejected (NoSpace error).
                cylindrical_shell_id_pair const new_shell(
                    _this->new_shell(did, cylinder_type(
                        com,
                        shell_size,
                        shape(structure).unit_z(),
                        std::max(p0.second.radius(), p1.second.radius()))));
                new_pair = new cylindrical_pair_type(did, p0, p1, new_shell,
                                                     iv, rules);
                kind = CYLINDRICAL_PAIR;
            }

        
            virtual void operator()(planar_surface_type const& structure) const
            {
                cylindrical_shell_id_pair const new_shell(
                    _this->new_shell(did, cylinder_type(
                        com,
                        shell_size,
                        normalize(cross_product(
                            shape(structure).unit_x(),
                            shape(structure).unit_y())),
                        std::max(p0.second.radius(), p1.second.radius()))));
                new_pair = new cylindrical_pair_type(did, p0, p1, new_shell,
                                                       iv, rules);
                kind = CYLINDRICAL_PAIR;
            }

            virtual void operator()(cuboidal_region_type const& structure) const
            {
                spherical_shell_id_pair new_shell(
                    _this->new_shell(did,
                        sphere_type(com, shell_size)));
                new_pair = new spherical_pair_type(did, p0, p1, new_shell,
                                                   iv, rules);
                kind = SPHERICAL_PAIR;
            }

            factory(EGFRDSimulator* _this, particle_id_pair const& p0,
                    particle_id_pair const& p1, position_type const& com,
                    position_type const& iv, length_type shell_size,
                    domain_id_type const& did, pair_type*& new_pair,
                    domain_kind& kind)
                : _this(_this), p0(p0), p1(p1), com(com), iv(iv),
                  shell_size(shell_size), did(did),
                  rules((*_this->network_rules_).query_reaction_rule(
                        p0.second.sid(), p1.second.sid())),
                  new_pair(new_pair), kind(kind) {}

            EGFRDSimulator* _this;
            particle_id_pair const& p0;
            particle_id_pair const& p1;
            position_type const& com;
            position_type const& iv;
            length_type const& shell_size;
            domain_id_type const& did;
            typename network_rules_type::reaction_rule_vector const& rules;
            pair_type*& new_pair;
            domain_kind& kind;
        };

        species_type const& species((*base_type::world_).get_species(p0.second.sid()));
        dynamic_cast<particle_simulation_structure_type&>(*(*base_type::world_).get_structure(species.structure_id())).accept(factory(this, p0, p1, com, iv, shell_size, did, new_pair, kind));

        boost::shared_ptr<domain_type> const retval(new_pair);
        domains_.insert(std::make_pair(did, retval));
        BOOST_ASSERT(kind != NONE);
        ++domain_count_per_type_[kind];
        return boost::dynamic_pointer_cast<pair_type>(retval);
    }
    // }}}

    // create_multi {{{
    boost::shared_ptr<multi_type> create_multi()
    {
        domain_id_type did(didgen_());
        multi_type* new_multi(new multi_type(did, *this, bd_dt_factor_));
        boost::shared_ptr<domain_type> const retval(new_multi);
        domains_.insert(std::make_pair(did, retval));
        ++domain_count_per_type_[MULTI];
        return boost::dynamic_pointer_cast<multi_type>(retval);
    }
    // }}}

    // draw_r {{{
    template<typename Tgf>
    static length_type draw_r(rng_type& rng,
                              Tgf const& gf,
                              time_type dt,
                              length_type a,
                              length_type sigma = -1.)
    {
        LOG_DEBUG(("draw_r: dt=%g, a=%g, sigma=%g", dt, a, sigma));
        BOOST_ASSERT(a > sigma);
        length_type r(0.);
        double rnd(0.);
        try
        {
            do
            {
                r = gf.drawR(rng.uniform(0., 1.), dt);
            } while (r > a || r <= sigma);
        }
        catch (std::exception const& e)
        {
            throw propagation_error(
                (boost::format(
                    "gf.drawR() failed: %s, rnd=%g, dt=%g, a=%g, sigma=%g") % e.what() % rnd % dt % a % sigma).str());
        }

        return r;
    }
    // }}}

    // draw_theta {{{
    template<typename Tgf>
    static length_type draw_theta(rng_type& rng,
                              Tgf const& gf,
                              time_type dt,
                              length_type r)
    {
        length_type theta(0.);
        double rnd(0.);
        try
        {
            rnd = rng.uniform(0., 1.);
            theta = gf.drawTheta(rnd, r, dt);
        }
        catch (std::exception const& e)
        {
            throw propagation_error(
                (boost::format(
                    "gf.drawTheta() failed: %s, rnd=%g, dt=%g, r=%g") % e.what() % rnd % dt % r).str());
        }

        return theta;
    }
    // }}}

    // draw_displacement {{{
    position_type draw_displacement(
        AnalyticalSingle<traits_type, spherical_shell_type> const& domain,
        length_type r)
    {
        return normalize(
            create_vector<position_type>(
                base_type::rng_.uniform(-1., 1.),
                base_type::rng_.uniform(-1., 1.),
                base_type::rng_.uniform(-1., 1.)), r);
    }

    position_type draw_displacement(
        AnalyticalSingle<traits_type, cylindrical_shell_type> const& domain,
        length_type r)
    {
        return multiply(shape(domain.shell().second).unit_z(), r);
    }
    // }}}

    // draw_new_position {{{
    template<typename Tshell>
    position_type draw_new_position(
            AnalyticalSingle<traits_type, Tshell> const& domain,
            time_type dt)
    {
        typedef Tshell shell_type;
        typedef typename shell_type::shape_type shape_type;
        typedef typename detail::get_greens_function<shape_type>::type greens_function;
        length_type const r(
            draw_r(
                base_type::rng_,
                greens_function(
                    domain.particle().second.D(),
                    domain.mobility_radius()),
                dt,
                domain.mobility_radius()));
        position_type const displacement(draw_displacement(domain, r));
        LOG_DEBUG(("draw_new_position(domain=%s, dt=%g): mobility_radius=%g, r=%g, displacement=%s (%g)",
                boost::lexical_cast<std::string>(domain).c_str(), dt,
                domain.mobility_radius(),
                r, boost::lexical_cast<std::string>(displacement).c_str(),
                length(displacement)));
        if (base_type::paranoiac_)
        {
            length_type const scale(domain.particle().second.radius());
            BOOST_ASSERT(r <= domain.mobility_radius());
            BOOST_ASSERT(feq(length(displacement), std::abs(r), scale));
        }
        return (*base_type::world_).apply_boundary(add(domain.particle().second.position(), displacement));
    }

    position_type draw_new_position(single_type& domain, time_type dt)
    {
        {
            spherical_single_type* _domain(dynamic_cast<spherical_single_type*>(&domain));
            if (_domain)
            {
                return draw_new_position(*_domain, dt);
            }
        }
        {
            cylindrical_single_type* _domain(dynamic_cast<cylindrical_single_type*>(&domain));
            if (_domain)
            {
                return draw_new_position(*_domain, dt);
            }
        }
        throw not_implemented(std::string("unsupported domain type"));
    }
    // }}}

    // draw_new_positions {{{
    template<typename Tdraw, typename T>
    boost::array<position_type, 2> draw_new_positions(
        AnalyticalPair<traits_type, T> const& domain, time_type dt)
    {
        Tdraw d(base_type::rng_, *base_type::world_);
        position_type const new_com(d.draw_com(domain, dt));
        position_type const new_iv(d.draw_iv(domain, dt, domain.iv()));
        D_type const D0(domain.particles()[0].second.D());
        D_type const D1(domain.particles()[1].second.D());
        return array_gen(
            (*base_type::world_).apply_boundary(subtract(new_com, multiply(new_iv, D0 / (D0 + D1)))),
            (*base_type::world_).apply_boundary(add(new_com, multiply(new_iv, D1 / (D0 + D1)))));
    }
    // }}}

    // propagate {{{
    /**
     * The difference between a burst and a propagate is that a burst 
     * always takes place before the actual scheduled event for the single, 
     * while propagate_single can be called for an escape event.
     *
     * Another subtle difference is that burst_single always reschedules 
     * (update_event) the single, while just calling propagate does not. 
     * So whoever calls propagate_single directly should reschedule the single 
     * afterwards.
     */
    //template<typename T>
    //void propagate(AnalyticalSingle<traits_type, T>& domain, position_type const& new_pos)
    void propagate(single_type& domain, position_type const& new_pos,
                   bool do_update_shell_matrix)
    {
        LOG_DEBUG(("propagate: domain=%s, new_pos=%s, do_update_shell_matrix=%d",
                boost::lexical_cast<std::string>(domain).c_str(),
                boost::lexical_cast<std::string>(new_pos).c_str(),
                do_update_shell_matrix));

        if (base_type::paranoiac_)
        {
            particle_shape_type const new_particle(new_pos, domain.particle().second.radius());
            BOOST_ASSERT(check_overlap(new_particle, domain.particle().first));
        }

        particle_type const& old(domain.particle().second);
        domain.particle().second = particle_type(old.sid(),
                particle_shape_type(new_pos, old.radius()), old.D());
        (*base_type::world_).update_particle(domain.particle());

        domain.position() = new_pos;
        domain.size() = domain.particle().second.radius();
        if (do_update_shell_matrix)
            update_shell_matrix(domain);
    }

    template<typename T>
    boost::array<boost::shared_ptr<single_type>, 2>
    propagate(AnalyticalPair<traits_type, T>& domain,
              boost::array<position_type, 2> const& new_pos)
    {
        boost::array<particle_id_pair, 2> const& particles(domain.particles());
        boost::array<particle_id_pair, 2> new_particles(particles);
        new_particles[0].second.position() = new_pos[0];
        new_particles[1].second.position() = new_pos[1];

        if (base_type::paranoiac_)
        {
            BOOST_ASSERT(distance(domain, new_particles[0].second.position()) <= -new_particles[0].second.radius());
            BOOST_ASSERT(distance(domain, new_particles[1].second.position()) <= -new_particles[1].second.radius());
            BOOST_ASSERT(check_overlap(
                shape(new_particles[0].second),
                new_particles[0].first, new_particles[1].first));
            BOOST_ASSERT(check_overlap(
                shape(new_particles[1].second),
                new_particles[0].first, new_particles[1].first));
            BOOST_ASSERT(check_pair_pos(domain, new_particles));
        }

        (*base_type::world_).update_particle(new_particles[0]);
        (*base_type::world_).update_particle(new_particles[1]);

        remove_domain(domain);

        boost::array<boost::shared_ptr<single_type>, 2> const singles = { {
            create_single(new_particles[0]),
            create_single(new_particles[1]) 
        } };

        if (log_.level() == Logger::L_DEBUG)
        {
            for (int i = 0; i < 2; i++)
            {
                LOG_DEBUG(("propagate: #%d: %s => %s", i,
                    boost::lexical_cast<std::string>(particles[i].second.position()).c_str(),
                    boost::lexical_cast<std::string>(*singles[i]).c_str()));
            }
        }

        return singles;
    }
    // }}}


    template<typename Trange>
    void burst_domains(Trange const& domain_ids, boost::optional<std::vector<boost::shared_ptr<domain_type> >&> const& result = boost::optional<std::vector<boost::shared_ptr<domain_type> >&>())
    {
        BOOST_FOREACH(domain_id_type id, domain_ids)
        {
            boost::shared_ptr<domain_type> domain(get_domain(id));
            burst(domain, result);
        }
    }

    // burst {{{
    template<typename T>
    void burst(AnalyticalSingle<traits_type, T>& domain)
    {
        position_type const old_pos(domain.position());
        //length_type const old_shell_size(domain.size()); 
        length_type const particle_radius(domain.particle().second.radius());

        // Override dt, burst happens before single's scheduled event.
        domain.dt() = base_type::t_ - domain.last_time();
        LOG_DEBUG(("t=%g, domain.last_time=%g", base_type::t_, domain.last_time()));

        position_type const new_pos(draw_new_position(domain, domain.dt()));

        propagate(domain, new_pos, true);

        domain.last_time() = base_type::t_;
        try
        {
            update_event(domain, SINGLE_EVENT_ESCAPE);
        }
        catch (std::out_of_range const&)
        {
            // event may have been removed.
            LOG_DEBUG(("event %s already removed; ignoring.", boost::lexical_cast<std::string>(domain.event().first).c_str()));
        }

        // Displacement check is in draw_new_position.
        // BOOST_ASSERT(
        //     (*base_type::world_).distance(new_pos, old_pos)
        //         <= old_shell_size - particle_radius);

        BOOST_ASSERT(domain.size() == particle_radius);
    }

    template<typename T>
    boost::array<boost::shared_ptr<single_type>, 2> burst(AnalyticalPair<traits_type, T>& domain)
    {
        length_type const dt(base_type::t_ - domain.last_time());

        boost::array<boost::shared_ptr<single_type>, 2> const singles(
            propagate(domain, draw_new_positions<draw_on_burst>(domain, dt)));

        add_event(*singles[0], SINGLE_EVENT_ESCAPE);
        add_event(*singles[1], SINGLE_EVENT_ESCAPE);

        return singles;
    }

    void burst(multi_type& domain, boost::optional<std::vector<boost::shared_ptr<domain_type> >&> const& result = boost::optional<std::vector<boost::shared_ptr<domain_type> >&>())
    {
        BOOST_FOREACH(particle_id_pair p, domain.get_particles_range())
        {
            boost::shared_ptr<single_type> s(create_single(p));
            add_event(*s, SINGLE_EVENT_ESCAPE);
            if (result)
            {
                result.get().push_back(boost::dynamic_pointer_cast<domain_type>(s));
            }
        }
        remove_domain(domain);
    }

    void burst(single_type& domain)
    {
        LOG_DEBUG(("burst: bursting %s", boost::lexical_cast<std::string>(domain).c_str()));
        BOOST_ASSERT(base_type::t_ >= domain.last_time());
        BOOST_ASSERT(base_type::t_ <= domain.last_time() + domain.dt());
        {
            spherical_single_type* _domain(dynamic_cast<spherical_single_type*>(&domain));
            if (_domain)
            {
                burst(*_domain);
                return;
            }
        }
        {
            cylindrical_single_type* _domain(dynamic_cast<cylindrical_single_type*>(&domain));
            if (_domain)
            {
                burst(*_domain);
                return;
            }
        }
        throw not_implemented("?");
    }

    void burst(boost::shared_ptr<domain_type> domain, boost::optional<std::vector<boost::shared_ptr<domain_type> >&> const& result = boost::optional<std::vector<boost::shared_ptr<domain_type> >&>())
    {
        LOG_DEBUG(("burst: bursting %s", boost::lexical_cast<std::string>(*domain).c_str()));
        {
            spherical_single_type* _domain(dynamic_cast<spherical_single_type*>(domain.get()));
            if (_domain)
            {
                burst(*_domain);
                if (result)
                    result.get().push_back(domain);
                return;
            }
        }
        {
            cylindrical_single_type* _domain(dynamic_cast<cylindrical_single_type*>(domain.get()));
            if (_domain)
            {
                burst(*_domain);
                if (result)
                    result.get().push_back(domain);
                return;
            }
        }
        {
            spherical_pair_type* _domain(dynamic_cast<spherical_pair_type*>(domain.get()));
            if (_domain)
            {
                boost::array<boost::shared_ptr<single_type>, 2> bursted(burst(*_domain));
                if (result)
                {
                    result.get().push_back(boost::dynamic_pointer_cast<domain_type>(bursted[0]));
                    result.get().push_back(boost::dynamic_pointer_cast<domain_type>(bursted[1]));
                }
                return;
            }
        }
        {
            cylindrical_pair_type* _domain(dynamic_cast<cylindrical_pair_type*>(domain.get()));
            if (_domain)
            {
                boost::array<boost::shared_ptr<single_type>, 2> bursted(burst(*_domain));
                if (result)
                {
                    result.get().push_back(boost::dynamic_pointer_cast<domain_type>(bursted[0]));
                    result.get().push_back(boost::dynamic_pointer_cast<domain_type>(bursted[1]));
                }
                return;
            }
        }
        {
            multi_type* _domain(dynamic_cast<multi_type*>(domain.get()));
            if (_domain)
            {
                burst(*_domain, result);
                return;
            }
        }
        throw not_implemented("?");
    }
    // }}}

    // attempt_single_reaction {{{
    bool attempt_single_reaction(single_type& domain)
    {
        const particle_id_pair reactant(domain.particle());
        const species_type reactant_species((*base_type::world_).get_species(reactant.second.sid()));
        reaction_rules const& rules((*base_type::network_rules_).query_reaction_rule(reactant.second.sid()));
        if (::size(rules) == 0)
        {
            return false;
        }

        reaction_rule_type const& r(draw_reaction_rule(rules));
        LOG_DEBUG(("attempt_single_reaction: reactant=%s, products=[%s]",
                boost::lexical_cast<std::string>(reactant.second.sid()).c_str(),
                stringize_and_join(r.get_products(), ", ").c_str()));

        switch (::size(r.get_products()))
        {
        case 0:
            remove_domain(domain);
            (*base_type::world_).remove_particle(reactant.first);
            if (base_type::rrec_)
            {
                (*base_type::rrec_)(reaction_record_type(
                    r.id(), array_gen<particle_id_type>(), reactant.first));
            }
            break;
        case 1: 
            {
                species_type const& product_species(
                    (*base_type::world_).get_species(r.get_products()[0]));

                if (reactant_species.radius() < product_species.radius())
                    clear_volume(::shape(reactant.second), domain.id());

                if ((*base_type::world_).check_overlap(::shape(reactant.second), reactant.first))
                {
                    LOG_INFO(("no space for product particle."));
                    throw no_space();
                }

                remove_domain(domain);
                (*base_type::world_).remove_particle(reactant.first);
                particle_id_pair product(
                    (*base_type::world_).new_particle(
                        product_species.id(), reactant.second.position()));
                boost::shared_ptr<single_type> new_domain(create_single(product));
                add_event(*new_domain, SINGLE_EVENT_ESCAPE);
                if (base_type::rrec_)
                {
                    (*base_type::rrec_)(reaction_record_type(
                        r.id(), array_gen(product.first), reactant.first));
                }
            }
            break;
        case 2:
            {
                species_type const* const product_species[] = {
                    &(*base_type::world_).get_species(r.get_products()[0]),
                    &(*base_type::world_).get_species(r.get_products()[1])
                };

                D_type const D01(product_species[0]->D() + product_species[1]->D());
                length_type r01(product_species[0]->radius() + product_species[1]->radius());
                Real const rad(std::max(
                        r01 * (product_species[0]->D() / D01) + product_species[0]->radius(),
                        r01 * (product_species[1]->D() / D01) + product_species[1]->radius()));
                clear_volume(particle_shape_type(reactant.second.position(), rad), domain.id());

                particle_shape_type new_particles[2];

                int i = num_retries_;
                while (--i >= 0)
                {
                    boost::shared_ptr<structure_type> structure(
                        (*base_type::world_).get_structure(
                            reactant_species.structure_id()));
                    position_type vector(
                        structure->random_vector(
                            r01 * traits_type::MINIMAL_SEPARATION_FACTOR,
                            base_type::rng_));
                    // place particles according to the ratio D1:D2
                    // this way, species with D=0 doesn't move.
                    // FIXME: what if D1 == D2 == 0?
                    for (;;) {
                        new_particles[0] = particle_shape_type(
                            (*base_type::world_).apply_boundary(
                                add(reactant.second.position(),
                                    multiply(vector, product_species[0]->D() / D01))),
                            product_species[0]->radius());
                        new_particles[1] = particle_shape_type(
                            (*base_type::world_).apply_boundary(
                                add(reactant.second.position(),
                                    multiply(vector, -product_species[1]->D() / D01))),
                            product_species[1]->radius());

                        length_type const distance_between_new_particles(
                            (*base_type::world_).distance(
                                new_particles[0].position(),
                                new_particles[1].position()));
                        if (distance_between_new_particles >= r01)
                            break;

                        vector = multiply(vector, 1.0 + 1e-7);
                    }

                    // accept the new positions if there is enough space.
                    if ((!(*base_type::world_).check_overlap(
                            new_particles[0], reactant.first)) &&
                        (!(*base_type::world_).check_overlap(
                            new_particles[1], reactant.first)))
                        break;
                }
                if (i < 0)
                {
                    LOG_INFO(("no space for product particles."));
                    throw no_space();
                }

                remove_domain(domain);
                (*base_type::world_).remove_particle(reactant.first);

                particle_id_pair const pp[] = {
                    (*base_type::world_).new_particle(
                        product_species[0]->id(), new_particles[0].position()),
                    (*base_type::world_).new_particle(
                        product_species[1]->id(), new_particles[1].position())
                };
                // create domains for two particles and add them to
                // the event queue
                add_event(*create_single(pp[0]), SINGLE_EVENT_ESCAPE);
                add_event(*create_single(pp[1]), SINGLE_EVENT_ESCAPE);

                if (base_type::rrec_)
                {
                    (*base_type::rrec_)(reaction_record_type(
                        r.id(), array_gen(pp[0].first, pp[1].first),
                        reactant.first));
                }
            }
            break;
        default:
            throw not_implemented("reactions that produces more than two products are not supported.");
        }
        return true;
    }
    // }}}

    time_type draw_single_reaction_time(species_id_type const& sid)
    {
        reaction_rules const& rules(
            (*base_type::network_rules_).query_reaction_rule(sid));
        rate_type const k_tot(calculate_k_tot(rules));
        if (k_tot == 0.)
        {
            return std::numeric_limits<time_type>::infinity();
        }
        else if (k_tot == std::numeric_limits<rate_type>::infinity())
        {
            return 0.;
        }
        else
        {
            return (1. / k_tot) * std::log(1. / base_type::rng_.uniform(0., 1.));
        }
    }

    template<typename Tshell>
    time_type draw_escape_or_interaction_time(AnalyticalSingle<traits_type, Tshell> const& domain)
    {
        if (domain.particle().second.D() == 0.)
        {
            return std::numeric_limits<time_type>::infinity();
        }
        else
        {
            typedef Tshell shell_type;
            typedef typename shell_type::shape_type shape_type;
            typedef typename detail::get_greens_function<shape_type>::type greens_function;
            return greens_function(domain.particle().second.D(),
                            domain.mobility_radius())
                .drawTime(base_type::rng_.uniform(0., 1.));
        }
    }

    template<typename Tshell>
    std::pair<time_type, pair_event_kind>
    draw_com_escape_or_iv_event_time(AnalyticalPair<traits_type, Tshell> const& domain)
    {
        typedef Tshell shell_type;
        typedef typename shell_type::shape_type shape_type;
        typedef typename detail::get_pair_greens_function<shape_type> pair_greens_functions;
        typedef typename pair_greens_functions::iv_type iv_greens_function;
        typedef typename pair_greens_functions::com_type com_greens_function;
        BOOST_ASSERT(::size(domain.reactions()) == 1);
        time_type const dt_com(
            com_greens_function(domain.D_R(), domain.a_R()).drawTime(base_type::rng_.uniform(0., 1.)));
        time_type const dt_iv(
            iv_greens_function(domain.D_tot(), domain.reactions()[0].k(),
                           domain.r0(), domain.sigma(), domain.a_r()).drawTime(base_type::rng_.uniform(0., 1.)));
        if (dt_com < dt_iv)
        {
            return std::make_pair(dt_com, PAIR_EVENT_COM_ESCAPE);
        }
        else
        {
            return std::make_pair(dt_iv, PAIR_EVENT_IV_UNDETERMINED);
        }
    }

    template<typename Tshell>
    std::pair<time_type, pair_event_kind>
    draw_single_reaction_time(AnalyticalPair<traits_type, Tshell> const& domain)
    {
        time_type const dt[2] = {
            draw_single_reaction_time(domain.particles()[0].second.sid()),
            draw_single_reaction_time(domain.particles()[1].second.sid())
        };
        if (dt[0] < dt[1])
        {
            return std::make_pair(dt[0], PAIR_EVENT_SINGLE_REACTION_0);
        }
        else
        {
            return std::make_pair(dt[1], PAIR_EVENT_SINGLE_REACTION_1);
        }
    }

    // {{{ determine_next_event
    template<typename Tshell>
    void determine_next_event(AnalyticalSingle<traits_type, Tshell>& domain)
    {
        typedef Tshell shell_type;
        typedef typename shell_type::shape_type shape_type;
        typedef typename detail::get_greens_function<shape_type>::type greens_function;
        time_type const dt_reaction(draw_single_reaction_time(domain.particle().second.sid()));
        time_type const dt_escape_or_interaction(draw_escape_or_interaction_time(domain));
        LOG_DEBUG(("determine_next_event: %s => dt_reaction=%g, "
                   "dt_escape_or_interaction=%g",
                   boost::lexical_cast<std::string>(domain).c_str(),
                   dt_reaction, dt_escape_or_interaction));
        single_event_kind event_kind;
        if (dt_reaction < dt_escape_or_interaction)
        {
            domain.dt() = dt_reaction;
            event_kind = SINGLE_EVENT_REACTION;
        }
        else
        {
            domain.dt() = dt_escape_or_interaction;
            event_kind = SINGLE_EVENT_ESCAPE;
        }

        domain.last_time() = base_type::t_;
        add_event(domain, event_kind);
    }

    void determine_next_event(single_type& domain)
    {
        {
            spherical_single_type* _domain(
                dynamic_cast<spherical_single_type*>(&domain));
            if (_domain)
            {
                determine_next_event(*_domain);
                return;
            }
        }
        {
            cylindrical_single_type* _domain(
                dynamic_cast<cylindrical_single_type*>(&domain));
            if (_domain)
            {
                determine_next_event(*_domain);
                return;
            }
        }
        throw not_implemented("unsupported domain type");
    }

    template<typename Tshell>
    void determine_next_event(AnalyticalPair<traits_type, Tshell>& domain)
    {
        std::pair<time_type, pair_event_kind> const dt_reaction(draw_single_reaction_time(domain));
        std::pair<time_type, pair_event_kind> const dt_com_escape_or_iv_event(draw_com_escape_or_iv_event_time(domain));
        std::pair<time_type, pair_event_kind> const dt_and_event_pair(
            dt_reaction.first < dt_com_escape_or_iv_event.first ?
                dt_reaction: dt_com_escape_or_iv_event);
        domain.dt() = dt_and_event_pair.first;
        domain.last_time() = base_type::t_;
        add_event(domain, dt_and_event_pair.second);
    }

    void determine_next_event(pair_type& domain)
    {
        {
            spherical_pair_type* _domain(
                dynamic_cast<spherical_pair_type*>(&domain));
            if (_domain)
            {
                determine_next_event(*_domain);
                return;
            }
        }
        {
            cylindrical_pair_type* _domain(
                dynamic_cast<cylindrical_pair_type*>(&domain));
            if (_domain)
            {
                determine_next_event(*_domain);
                return;
            }
        }
        throw not_implemented("unsupported domain type");
    }
    // }}}

    // get_intruders {{{ 
    std::pair<std::vector<domain_id_type>*,
              std::pair<domain_id_type, length_type> >
    get_intruders(particle_shape_type const& p,
                  domain_id_type const& ignore) const
    {
        typedef intruder_collector collector_type;

        collector_type col((*base_type::world_), p, ignore);
        boost::fusion::for_each(smatm_, shell_collector_applier<collector_type>(col, p.position()));
        return std::make_pair(col.intruders.container().get(), col.closest);
    }
    // }}}

    template<typename TdidSet>
    std::pair<domain_id_type, length_type>
    get_closest_domain(position_type const& p, TdidSet const& ignore) const
    {
        typedef closest_object_finder<TdidSet> collector_type;

        collector_type col((*base_type::world_), p, ignore);
        boost::fusion::for_each(smatm_, shell_collector_applier<collector_type>(col, p));
        return col.closest;
    }

    void restore_domain(single_type& domain)
    {
        std::pair<domain_id_type, length_type> const closest(
            get_closest_domain(
                domain.position(), 
                array_gen(domain.id())));
        restore_domain(domain, closest);
    }

    template<typename T>
    void restore_domain(AnalyticalSingle<traits_type, T>& domain,
                        std::pair<domain_id_type, length_type> const& closest)
    {
        typedef typename AnalyticalSingle<traits_type, T>::shell_type shell_type;
        domain_type const* closest_domain(
            closest.second == std::numeric_limits<length_type>::infinity() ?
                (domain_type const*)0: get_domain(closest.first).get());
        length_type new_shell_size(0.);

        if (closest_domain)
        {
            single_type const* const _closest_domain(
                dynamic_cast<single_type const*>(closest_domain));
            if (_closest_domain)
            {
                length_type const distance_to_closest(
                    (*base_type::world_).distance(
                        domain.position(), _closest_domain->position()));
                new_shell_size = calculate_single_shell_size(
                        domain, *_closest_domain,
                        distance_to_closest,
                        closest.second);
            } else {
                new_shell_size = closest.second / traits_type::SAFETY;
            }
            new_shell_size = std::min(max_shell_size(), new_shell_size);
        }
        else
        {
            new_shell_size = max_shell_size();
        }
        LOG_DEBUG(("restore domain: %s (shell_size=%g, dt=%g) closest=%s (distance=%g)",
            boost::lexical_cast<std::string>(domain).c_str(),
            new_shell_size,
            domain.dt(),
            closest_domain ?
                boost::lexical_cast<std::string>(*closest_domain).c_str():
                "(none)",
            closest.second));
        if (base_type::paranoiac_)
        {
            BOOST_ASSERT(check_overlap(
                sphere_type(domain.position(), new_shell_size),
                domain.particle().first));
        }
        domain.size() = new_shell_size;
        update_shell_matrix(domain);
        BOOST_ASSERT(domain.size() == new_shell_size);
    }

    void restore_domain(single_type& domain,
                        std::pair<domain_id_type, length_type> const& closest)
    {
        {
            spherical_single_type *_domain(
                dynamic_cast<spherical_single_type*>(&domain));
            if (_domain)
                return restore_domain(*_domain, closest);
        }
        {
            cylindrical_single_type *_domain(
                dynamic_cast<cylindrical_single_type*>(&domain));
            if (_domain)
                return restore_domain(*_domain, closest);
        }
        throw not_implemented(std::string("unsupported domain type"));
    }

    template<typename Trange>
    void burst_non_multis(Trange const& domain_ids,
                          std::vector<boost::shared_ptr<domain_type> >& bursted)
    {
        BOOST_FOREACH (domain_id_type id, domain_ids)
        {
            boost::shared_ptr<domain_type> domain(get_domain(id));
            if (dynamic_cast<multi_type*>(domain.get()))
            {
                bursted.push_back(domain);
            }
            else
            {
                burst(domain, bursted);
            }
        }
    }

    template<typename T>
    length_type distance(AnalyticalSingle<traits_type, T> const& domain,
                         position_type const& pos) const
    {
        return (*base_type::world_).distance(shape(domain.shell().second), pos);
    }

    template<typename T>
    length_type distance(AnalyticalPair<traits_type, T> const& domain,
                         position_type const& pos) const
    {
        return (*base_type::world_).distance(shape(domain.shell().second), pos);
    }

    length_type distance(multi_type const& domain, position_type const& pos) const
    {
        length_type retval(std::numeric_limits<length_type>::infinity());
        BOOST_FOREACH (spherical_shell_id_pair const& shell,
                       domain.get_shells())
        {
            length_type const dist((*base_type::world_).distance(
                    shape(shell.second), pos));
            if (retval > dist)
            {
                retval = dist;
            }
        }
        return retval;
    }

    length_type distance(domain_type const& domain, position_type const& pos) const
    {
        length_type retval;

        struct distance_visitor: ImmutativeDomainVisitor<traits_type>
        {
            virtual ~distance_visitor() {}

            virtual void operator()(multi_type const& domain) const
            {
                retval = outer.distance(domain, pos);
            }

            virtual void operator()(spherical_single_type const& domain) const
            {
                retval = outer.distance(domain, pos);
            }

            virtual void operator()(cylindrical_single_type const& domain) const
            {
                retval = outer.distance(domain, pos);
            }

            virtual void operator()(spherical_pair_type const& domain) const
            {
                retval = outer.distance(domain, pos);
            }

            virtual void operator()(cylindrical_pair_type const& domain) const
            {
                retval = outer.distance(domain, pos);
            }

            distance_visitor(EGFRDSimulator const& outer, position_type const& pos,
                             length_type& retval)
                : outer(outer), pos(pos), retval(retval) {}

            EGFRDSimulator const& outer;
            position_type const& pos;
            length_type& retval;
        };

        domain.accept(distance_visitor(*this, pos, retval));
        return retval;
    }

    boost::optional<pair_type&>
    form_pair(single_type& domain, single_type& possible_partner,
              std::vector<boost::shared_ptr<domain_type> > const& neighbors)
    {
        LOG_DEBUG(("trying to form Pair(%s, %s)",
                    boost::lexical_cast<std::string>(domain).c_str(),
                    boost::lexical_cast<std::string>(possible_partner).c_str()));
        // 1. Determine min shell size.
        length_type const r[] = {
            domain.particle().second.radius(),
            possible_partner.particle().second.radius()
        };
        length_type const sigma(r[0] + r[1]);

        D_type const D[] = {
            domain.particle().second.D(),
            possible_partner.particle().second.D()
        };
        D_type const D01(D[0] + D[1]);

        BOOST_ASSERT(domain.particle().second.position() ==
                     domain.position());

        BOOST_ASSERT(possible_partner.particle().second.position() ==
                     possible_partner.position());

        position_type iv(
                subtract(domain.position(),
                    (*base_type::world_).cyclic_transpose(
                        possible_partner.position(),
                        domain.position())));
        length_type const r0(length(iv));
        length_type const distance_from_sigma(r0 - sigma);
        BOOST_ASSERT(distance_from_sigma >= 0);

        length_type const shell_size[] = {
           r0 * D[0] / D01 + r[0], r0 * D[1] / D01 + r[1]
        };
        length_type const shell_size_margin[] = {
            r[0] * 2,
            r[1] * 2
        };
        size_t const larger_shell_index(
            shell_size[0] + shell_size_margin[0] >=
                shell_size[1] + shell_size_margin[1] ? 0: 1);
        length_type const min_shell_size(shell_size[larger_shell_index]);
        length_type const min_shell_size_margin(shell_size_margin[larger_shell_index]);

        // 2. Check if min shell size not larger than max shell size or 
        // sim cell size.
        position_type com((*base_type::world_).apply_boundary(
            (*base_type::world_).calculate_pair_CoM(
                domain.position(), possible_partner.position(),
                D[0], D[1])));
        length_type const min_shell_size_with_margin(
            min_shell_size + min_shell_size_margin);
        length_type const max_shell_size(
            std::min(this->max_shell_size(),
                     distance_from_sigma * 100
                        + sigma + min_shell_size_margin));

        if (min_shell_size_with_margin >= max_shell_size)
        {
            LOG_DEBUG(("Pair(%s, %s) not formed: min_shell_size %g >="
                       "max_shell_size %g",
                       boost::lexical_cast<std::string>(domain).c_str(),
                       boost::lexical_cast<std::string>(possible_partner).c_str(),
                       min_shell_size_with_margin, max_shell_size));
            return boost::optional<pair_type&>();
        }

        // 3. Check if bursted Singles not too close.
        // The simple check for closest below could miss
        // some of them, because sizes of these Singles for this
        // distance check has to include SINGLE_SHELL_FACTOR, while
        // these burst objects have zero mobility radii.  This is not
        // beautiful, a cleaner framework may be possible.

        domain_type* closest_domain (0);
        length_type closest_shell_distance(std::numeric_limits<length_type>::infinity());
        BOOST_FOREACH (boost::shared_ptr<domain_type> _neighbor, neighbors)
        {
            single_type* const neighbor(
                dynamic_cast<single_type*>(_neighbor.get()));
            if (neighbor && neighbor->id() != possible_partner.id())
            {
                length_type const shell_distance(
                    (*base_type::world_).distance(com, neighbor->position()) -
                        neighbor->particle().second.radius() *
                            (1.0 + traits_type::SINGLE_SHELL_FACTOR));
                if (shell_distance < closest_shell_distance)
                {
                    closest_domain = neighbor;
                    closest_shell_distance = shell_distance;
                }
            }
        }

        if (closest_domain)
        {
            BOOST_ASSERT(closest_shell_distance > 0);

            if (closest_shell_distance <= min_shell_size_with_margin)
            {
                LOG_DEBUG(("Pair(%s, %s) not formed: squeezed by burst neighbor %s",
                           boost::lexical_cast<std::string>(domain).c_str(),
                           boost::lexical_cast<std::string>(possible_partner).c_str(),
                           boost::lexical_cast<std::string>(*closest_domain).c_str()));
                return boost::optional<pair_type&>();
            }
        }

        // 4. Determine shell size and check if closest object not too 
        // close (squeezing).
        {
            std::pair<domain_id_type, length_type> possible_closest(
                get_closest_domain(com, array_gen(domain.id(),
                                                  possible_partner.id())));
            if (possible_closest.second < closest_shell_distance)
            {
                domain_type* const _closest_domain(
                        get_domain(possible_closest.first).get());
                closest_domain = _closest_domain;
                closest_shell_distance = possible_closest.second;
            }
        }

        if (closest_domain)
        {
            LOG_DEBUG(("Pair closest neighbor: %s %g, "
                       "min_shell_with_margin=%g",
                       boost::lexical_cast<std::string>(*closest_domain).c_str(),
                       closest_shell_distance,
                       min_shell_size_with_margin));
            BOOST_ASSERT(closest_shell_distance > 0);
        }

        length_type new_shell_size(0.);

        {
            single_type* const _closest_domain(
                    dynamic_cast<single_type*>(closest_domain));
            if (_closest_domain)
            {
                particle_type const& closest_domain_particle(
                        _closest_domain->particle().second);
                D_type const D_tot(closest_domain_particle.D() + D01);
                length_type const closest_particle_distance(
                    (*base_type::world_).distance(
                        com, closest_domain_particle.position()));
                length_type const closest_min_shell(
                        closest_domain_particle.radius() *
                            (traits_type::SINGLE_SHELL_FACTOR + 1.0));

                // options for shell size:
                // a. ideal shell size
                // b. closest shell is from a bursted single
                // c. closest shell is closer than ideal shell size 
                new_shell_size = std::min(
                    std::min(
                        (D01 / D_tot) * (
                            closest_particle_distance - min_shell_size 
                            - closest_domain_particle.radius())
                        + min_shell_size,
                        closest_particle_distance - closest_min_shell),
                    closest_shell_distance);
            }
            else
            {
                new_shell_size = closest_shell_distance;
            }
            new_shell_size /= traits_type::SAFETY;

            if (new_shell_size <= min_shell_size_with_margin)
            {
                LOG_DEBUG(("Pair(%s, %s) not formed%s%s",
                    boost::lexical_cast<std::string>(domain).c_str(),
                    boost::lexical_cast<std::string>(possible_partner).c_str(),
                    closest_domain ? ": squeezed by ": "",
                    closest_domain ? boost::lexical_cast<std::string>(*closest_domain).c_str(): ""));
                return boost::optional<pair_type&>();
            }
        }

        // 5. Check if singles would not be better.
        {
            length_type const dist[] = {
                (*base_type::world_).distance(com, domain.position()),
                (*base_type::world_).distance(com, domain.position())
            };

            if (new_shell_size < std::max(
                    dist[0] + r[0] *
                        (1.0 + traits_type::SINGLE_SHELL_FACTOR),
                    dist[1] + r[1] *
                        (1.0 + traits_type::SINGLE_SHELL_FACTOR)) * 1.3)
            {
                LOG_DEBUG(("Pair(%s, %s) not formed: leaving singles are better",
                            boost::lexical_cast<std::string>(domain).c_str(),
                            boost::lexical_cast<std::string>(possible_partner).c_str()));
                return boost::optional<pair_type&>();
            }
        }

        // 6. Ok, Pair makes sense. Create one.
        new_shell_size = std::min(new_shell_size, max_shell_size);

        boost::shared_ptr<pair_type> new_pair(
            create_pair(
                domain.particle(),
                possible_partner.particle(),
                com, iv, new_shell_size));

        determine_next_event(*new_pair);
        BOOST_ASSERT(new_pair->dt() >= 0);

        new_pair->last_time() = base_type::t_;

        remove_domain(domain);
        remove_domain(possible_partner);

        BOOST_ASSERT(
                (closest_domain && closest_shell_distance ==
                    std::numeric_limits<length_type>::infinity())
                || new_shell_size < closest_shell_distance);
        BOOST_ASSERT(new_shell_size >= min_shell_size_with_margin);
        BOOST_ASSERT(new_shell_size <= max_shell_size);

        LOG_INFO(("new_pair=%s, closest_shell_distance=%g, closest=%s",
                  boost::lexical_cast<std::string>(*new_pair).c_str(),
                  closest_shell_distance,
                  closest_domain ? boost::lexical_cast<std::string>(closest_domain).c_str(): "(none)"));

        return *new_pair;
    }

    boost::optional<multi_type&>
    form_multi(single_type& domain,
               std::vector<boost::shared_ptr<domain_type> > const& neighbors,
               std::pair<domain_type&, length_type> closest)
    {
        LOG_DEBUG(("form multi: neighbors=[%s], closest=%s",
                stringize_and_join(
                    make_transform_iterator_range(neighbors,
                        dereference<boost::shared_ptr<domain_type> >()),
                    ", ").c_str(),
                boost::lexical_cast<std::string>(closest.first).c_str()));
        length_type const min_shell_size(
                domain.particle().second.radius() *
                    (1.0 + multi_shell_factor_));

        // Multis shells need to be contiguous.
        if (closest.second > min_shell_size)
        {
            LOG_DEBUG(("multi shells aren't close enough to each other (closest distance=%g, min_shell_size=%g)", closest.second, min_shell_size));
            return boost::optional<multi_type&>();
        }

        // If there's a multi neighbor, merge others into it.
        // Otherwise, create a new multi and let it hold them all.
        multi_type* retval(0);
        retval = dynamic_cast<multi_type*>(&closest.first);
        if (!retval)
        {
            retval = create_multi().get();
            add_event(*retval);
            LOG_DEBUG(("form multi: created a new multi %s",
                    boost::lexical_cast<std::string>(*retval).c_str()));
        }

        position_type const single_pos(domain.position());
        add_to_multi(*retval, domain);

        BOOST_FOREACH (boost::shared_ptr<domain_type> neighbor, neighbors)
        {
            length_type const dist(distance(*neighbor, single_pos));
            if (dist < min_shell_size)
                add_to_multi_recursive(*retval, *neighbor); 
        }

        return *retval;
    }

    bool add_to_multi(multi_type& multi, single_type& single)
    {
        LOG_DEBUG(("add to multi: %s => %s",
                boost::lexical_cast<std::string>(single).c_str(),
                boost::lexical_cast<std::string>(multi).c_str()));

        if (!multi.add_particle(single.particle()))
        {
            LOG_DEBUG(("particle %s is already added to %s",
                boost::lexical_cast<std::string>(single.particle().first).c_str(),
                boost::lexical_cast<std::string>(multi).c_str()));
            return false;
        }

        spherical_shell_id_pair sid_shell_pair(
            new_shell(
                multi.id(),
                sphere_type(
                    single.particle().second.position(),
                    single.particle().second.radius() *
                        (1. + multi_shell_factor_))));
        multi.add_shell(sid_shell_pair);
        remove_domain(single);
        return true;
    }

    void add_to_multi(multi_type& multi, multi_type& other_multi)
    {
        if (multi.id() == other_multi.id())
        {
            LOG_DEBUG(("add to multi: given two multis are the same; do nothing"));
            return;
        }

        LOG_DEBUG(("add to multi: %s => %s",
                boost::lexical_cast<std::string>(other_multi).c_str(),
                boost::lexical_cast<std::string>(multi).c_str()));

        // merge other_multi into multi. other_multi will be removed.
        spherical_shell_matrix_type& mat(
            boost::fusion::at_key<spherical_shell_type>(smatm_));
        BOOST_FOREACH (spherical_shell_id_pair const& _shell,
                       other_multi.get_shells())
        {
            typename spherical_shell_matrix_type::iterator const i(
                mat.find(_shell.first));
            BOOST_ASSERT(i != mat.end());
            spherical_shell_type& shell((*i).second);
            shell.did() = multi.id();
            multi.add_shell(spherical_shell_id_pair(_shell.first, shell));
        }

        BOOST_FOREACH (particle_id_pair const& particle,
                       other_multi.get_particles_range())
        {
            multi.add_particle(particle);
        }

        remove_domain_but_shell(other_multi);
    }

    void add_to_multi_recursive(multi_type& multi, domain_type& domain)
    {
        LOG_DEBUG(("add_to_multi_recursive: multi=%s, domain=%s",
                boost::lexical_cast<std::string>(multi).c_str(),
                boost::lexical_cast<std::string>(domain).c_str()));
        {
            single_type* single(dynamic_cast<single_type*>(&domain));
            if (single)
            {
                particle_shape_type const new_shell(
                    single->particle().second.position(),
                    single->particle().second.radius() *
                        (1.0 + multi_shell_factor_));

                if (!add_to_multi(multi, *single))
                {
                    return;
                }

                boost::scoped_ptr<std::vector<domain_id_type> > neighbors(
                    get_neighbor_domains(new_shell, single->id()));

                std::vector<boost::shared_ptr<domain_type> > bursted;
                burst_non_multis(*neighbors, bursted);

                LOG_DEBUG(("add_to_multi_recursive: bursted=[%s]",
                        stringize_and_join(
                            make_transform_iterator_range(
                                bursted,
                                dereference<boost::shared_ptr<domain_type> >()),
                            ", ").c_str()));

                BOOST_FOREACH (boost::shared_ptr<domain_type> neighbor, bursted)
                {
                    length_type const dist(distance(*neighbor, single->position()));
                    if (dist < new_shell.radius())
                        add_to_multi_recursive(multi, *neighbor); 
                }
                return;
            }
        }
        {
            multi_type* other_multi(dynamic_cast<multi_type*>(&domain));
            if (other_multi)
            {
                add_to_multi(multi, *other_multi);
            }
        }
    }

    boost::optional<domain_type&> form_pair_or_multi(
        single_type& domain,
        std::vector<boost::shared_ptr<domain_type> > const& neighbors)
    {
        BOOST_ASSERT(!neighbors.empty());

        domain_type* possible_partner(0);
        length_type length_to_possible_partner(
                std::numeric_limits<length_type>::infinity());
        BOOST_FOREACH (boost::shared_ptr<domain_type> neighbor, neighbors)
        {
            length_type const dist(distance(*neighbor, domain.position()));
            if (dist < length_to_possible_partner)
            {
                possible_partner = neighbor.get();
                length_to_possible_partner = dist;
            }
        }

        // First, try forming a Pair.
        {
            single_type* const _possible_partner(
                    dynamic_cast<single_type*>(possible_partner));
            if (_possible_partner)
            {
                boost::optional<pair_type&> new_pair(
                    form_pair(domain, *_possible_partner, neighbors));
                if (new_pair)
                {
                    return new_pair.get();
                }
            }
        }

        // If a Pair is not formed, then try forming a Multi.
        {
            boost::optional<multi_type&> new_multi(
                    form_multi(domain, neighbors,
                               std::pair<domain_type&, length_type>(
                                    *possible_partner,
                                    length_to_possible_partner)));
            if (new_multi)
            {
                return new_multi.get();
            }
        }
        return boost::optional<domain_type&>();
    }

    void fire_event(single_event const& event)
    {
        single_type& domain(event.domain());
#if 0
        BOOST_ASSERT(
            std::abs(domain.dt() + domain.last_time() - base_type::t_)
                <= 1e-18 * base_type::t_);
#endif
        ++single_step_count_[event.kind()];
        switch (event.kind())
        {
        default: /* never get here */ BOOST_ASSERT(0); break;
        case SINGLE_EVENT_REACTION:
            LOG_DEBUG(("fire_single: single reaction (%s)", boost::lexical_cast<std::string>(domain).c_str()));
            propagate(domain, draw_new_position(domain, domain.dt()), false);
            try
            {
                attempt_single_reaction(domain);
            }
            catch (no_space const&)
            {
                LOG_DEBUG(("single reaction rejected"));
            }
            break;

        case SINGLE_EVENT_ESCAPE:
            LOG_DEBUG(("fire_single: single escape (%s)", boost::lexical_cast<std::string>(domain).c_str()));

            // handle immobile case
            if (domain.D() == 0.)
            {
                determine_next_event(domain);
                domain.last_time() = base_type::t_;
                return;
            }

            if (domain.dt() != 0.)
                // Heads up: shell matrix will be updated later in restore_domain().
                propagate(domain, draw_new_position(domain, domain.dt()), false);
            length_type const min_shell_radius(domain.particle().second.radius() * (1. + single_shell_factor_));
            {
                std::vector<domain_id_type>* intruders;
                std::pair<domain_id_type, length_type> closest;
                boost::tie(intruders, closest) = get_intruders(
                    particle_shape_type(domain.position(), min_shell_radius),
                    domain.id());
                boost::scoped_ptr<std::vector<domain_id_type> > _(intruders);

                LOG_DEBUG(("intruders: %s, closest: %s (dist=%g)",
                    intruders ?
                        stringize_and_join(*intruders, ", ").c_str():
                        "(none)",
                    boost::lexical_cast<std::string>(closest.first).c_str(),
                    closest.second));
                if (intruders)
                {
                    std::vector<boost::shared_ptr<domain_type> > bursted;
                    burst_non_multis(*intruders, bursted);
                    if (form_pair_or_multi(domain, bursted))
                        return;
                    // if nothing was formed, recheck closest and restore shells.
                    restore_domain(domain);
                    BOOST_FOREACH (boost::shared_ptr<domain_type> _single, bursted)
                    {
                        boost::shared_ptr<single_type> single(
                            boost::dynamic_pointer_cast<single_type>(_single));
                        if (!single)
                            continue;
                        restore_domain(*single);
                    }
                } else {
                    restore_domain(domain, closest);
                }
                determine_next_event(domain);
                LOG_DEBUG(("%s (dt=%g)",
                    boost::lexical_cast<std::string>(domain).c_str(),
                    domain.dt()));
            }
        }
    }

    template<typename Tshell>
    GreensFunction3DRadAbs::EventKind
    draw_iv_event_type(AnalyticalPair<traits_type, Tshell> const& domain)
    {
        typedef Tshell shell_type;
        typedef typename shell_type::shape_type shape_type;
        typedef typename detail::get_pair_greens_function<shape_type>::iv_type iv_greens_function;
        // Draw actual pair event for iv at very last minute.
        BOOST_ASSERT(::size(domain.reactions()) == 1);
        reaction_rule_type const& r(domain.reactions()[0]);
        iv_greens_function const gf(domain.D_tot(), r.k(), domain.r0(), domain.sigma(), domain.a_r());

        double const rnd(base_type::rng_.uniform(0, 1.));
        return gf.drawEventType(rnd, domain.dt());
    }

    void fire_event(pair_event const& event)
    {
        {
            spherical_pair_type* _domain(dynamic_cast<spherical_pair_type*>(&event.domain()));
            if (_domain)
            {
                fire_event(*_domain, event.kind());
                return;
            }
        }
        {
            cylindrical_pair_type* _domain(dynamic_cast<cylindrical_pair_type*>(&event.domain()));
            if (_domain)
            {
                fire_event(*_domain, event.kind());
                return;
            }
        }
    }

    template<typename T>
    void fire_event(AnalyticalPair<traits_type, T>& domain, pair_event_kind kind)
    {
        typedef AnalyticalSingle<traits_type, T> corresponding_single_type;

        if (kind == PAIR_EVENT_IV_UNDETERMINED)
        {
            // Draw actual pair event for iv at very last minute.
            switch (draw_iv_event_type(domain))
            {
            case GreensFunction3DRadAbs::IV_ESCAPE:
                kind = PAIR_EVENT_IV_ESCAPE;
                break;
            case GreensFunction3DRadAbs::IV_REACTION:
                kind = PAIR_EVENT_IV_REACTION;
                break;
            }
        }

        ++pair_step_count_[kind];
        LOG_DEBUG(("fire_pair: %s", stringize_event_kind(kind).c_str()));

        //  1. Single reaction
        //  2. Pair reaction
        //  3a. IV escape
        //  3b. com escape

        switch (kind)
        {
        default: /* never get here */ BOOST_ASSERT(0); break;
        case PAIR_EVENT_SINGLE_REACTION_0: 
        case PAIR_EVENT_SINGLE_REACTION_1:
            {
                int const index(kind == PAIR_EVENT_SINGLE_REACTION_0 ? 0 : 1);
                // TODO.
                //int const theother_index(1 - index);
                position_type const old_CoM(domain.position());
                LOG_DEBUG(("pair: single reaction %s", boost::lexical_cast<std::string>(domain.particles()[index].first).c_str()));

                boost::array<boost::shared_ptr<single_type>, 2> const new_single(burst(domain));

                try
                {
                    attempt_single_reaction(*new_single[index]);
                }
                catch (no_space const&)
                {
                    LOG_DEBUG(("single reaction rejected"));
                }
            }
            break;

        case PAIR_EVENT_COM_ESCAPE:
            {
                LOG_DEBUG(("=> com_escape"));
                time_type const dt(domain.dt());
                boost::array<position_type, 2> const new_pos(
                    draw_new_positions<draw_on_com_escape>(
                        domain, dt));
                boost::array<boost::shared_ptr<single_type>, 2> const new_single(
                    propagate(domain, new_pos));

                add_event(*new_single[0], SINGLE_EVENT_ESCAPE);
                add_event(*new_single[1], SINGLE_EVENT_ESCAPE);
            }
            break;
        
        case PAIR_EVENT_IV_REACTION:
            {
                LOG_DEBUG(("=> iv_reaction"));
                BOOST_ASSERT(::size(domain.reactions()) == 1);
                reaction_rule_type const& r(domain.reactions()[0]);

                switch (::size(r.get_products()))
                {
                case 1:
                    {
                        species_type const& new_species(
                            (*base_type::world_).get_species(
                                r.get_products()[0]));

                        // calculate new R
                        position_type const new_com(
                            (*base_type::world_).apply_boundary(
                                draw_on_iv_reaction(
                                    base_type::rng_,
                                    *base_type::world_).draw_com(
                                        domain, domain.dt())));
                   
                        BOOST_ASSERT(
                            (*base_type::world_).distance(
                                domain.shell().second.position(),
                                new_com) + new_species.radius()
                            < shape(domain.shell().second).radius());

                        (*base_type::world_).remove_particle(domain.particles()[0].first);
                        (*base_type::world_).remove_particle(domain.particles()[1].first);

                        particle_id_pair const new_particle(
                            (*base_type::world_).new_particle(
                                new_species.id(), new_com));
                        boost::shared_ptr<single_type> new_single(
                            create_single(new_particle));
                        add_event(*new_single, SINGLE_EVENT_ESCAPE);

                        if (base_type::rrec_)
                        {
                            (*base_type::rrec_)(reaction_record_type(
                                r.id(),
                                array_gen(new_particle.first),
                                domain.particles()[0].first,
                                domain.particles()[1].first));
                        }
                    }
                    break;
                default:
                    throw not_implemented("num products >= 2 not supported.");
                }
                remove_domain(domain);
            }
            break;
        case PAIR_EVENT_IV_ESCAPE:
            {
                LOG_DEBUG(("=> iv_escape"));
                time_type const dt(domain.dt());
                boost::array<position_type, 2> const new_pos(
                    draw_new_positions<draw_on_iv_escape>(
                        domain, dt));
                boost::array<boost::shared_ptr<single_type>, 2> const new_single(
                    propagate(domain, new_pos));

                add_event(*new_single[0], SINGLE_EVENT_ESCAPE);
                add_event(*new_single[1], SINGLE_EVENT_ESCAPE);
            }
            break;
        }
    }

    void fire_event(multi_event& event)
    {
        multi_type& domain(event.domain());
        domain.step();
        LOG_DEBUG(("fire_multi: last_event=%s", boost::lexical_cast<std::string>(domain.last_event()).c_str()));
        multi_step_count_[domain.last_event()]++; 
        switch (domain.last_event())
        {
        default: /* never get here */ BOOST_ASSERT(0); break;
        case multi_type::REACTION:
            if (base_type::rrec_)
                (*base_type::rrec_)(domain.last_reaction());
            burst(domain);
            break;
        case multi_type::ESCAPE:
            burst(domain);
            break;
        case multi_type::NONE:
            add_event(domain);
            break;
        }
    }

    void fire_event(event_type& event)
    {
        {
            single_event* _event(dynamic_cast<single_event*>(&event));
            if (_event)
            {
                fire_event(*_event);
                return;
            }
        }
        {
            pair_event* _event(dynamic_cast<pair_event*>(&event));
            if (_event)
            {
                fire_event(*_event);
                return;
            }
        }
        {
            multi_event* _event(dynamic_cast<multi_event*>(&event));
            if (_event)
            {
                fire_event(*_event);
                return;
            }
        }
        throw not_implemented(std::string("unsupported domain type"));
    }

    void _step()
    {
        if (dirty_)
            initialize();

        if (base_type::paranoiac_)
            BOOST_ASSERT(check());

        ++base_type::num_steps_;

        event_id_pair_type ev(scheduler_.pop());
        base_type::t_ = ev.second->time();

        LOG_INFO(("%d: t=%g dt=%g domain=%s rejectedmoves=%d",
                  base_type::num_steps_, base_type::t_, base_type::dt_,
                  boost::lexical_cast<std::string>(dynamic_cast<domain_event_base const*>(ev.second.get())->domain()).c_str(),
                  rejected_moves_));

        fire_event(*ev.second);

        time_type const next_time(scheduler_.top().second->time());
        base_type::dt_ = next_time - base_type::t_; 

        if (base_type::dt_ == 0.)
        {
            ++zero_step_count_;
            if (zero_step_count_ >= std::max(scheduler_.size() * 3, static_cast<std::size_t>(10u)))
            {
                throw illegal_state("too many dt=zero steps. simulator halted?");
            }
        }
        else
        {
            zero_step_count_ = 0;
        }
    }

    static domain_kind get_domain_kind(domain_type const& domain)
    {
        struct domain_kind_visitor: ImmutativeDomainVisitor<traits_type>
        {
            virtual ~domain_kind_visitor() {}

            virtual void operator()(multi_type const&) const
            {
                retval = MULTI;
            }

            virtual void operator()(spherical_single_type const&) const
            {
                retval = SPHERICAL_SINGLE;
            }

            virtual void operator()(cylindrical_single_type const&) const
            {
                retval = CYLINDRICAL_SINGLE;
            }

            virtual void operator()(spherical_pair_type const&) const
            {
                retval = SPHERICAL_PAIR;
            }

            virtual void operator()(cylindrical_pair_type const&) const
            {
                retval = CYLINDRICAL_PAIR;
            }

            domain_kind_visitor(domain_kind& retval): retval(retval) {}

            domain_kind& retval;
        };

        domain_kind retval = NONE;
        domain.accept(domain_kind_visitor(retval));
        return retval;
    }

    static domain_kind get_domain_kind(spherical_single_type const&)
    {
        return SPHERICAL_SINGLE;
    }

    static domain_kind get_domain_kind(cylindrical_single_type const&)
    {
        return CYLINDRICAL_SINGLE;
    }

    static domain_kind get_domain_kind(spherical_pair_type const&)
    {
        return SPHERICAL_PAIR;
    }

    static domain_kind get_domain_kind(cylindrical_pair_type const&)
    {
        return CYLINDRICAL_PAIR;
    }

    static domain_kind get_domain_kind(multi_type const&)
    {
        return MULTI;
    }

    void dump_events() const
    {
        LOG_INFO(("QUEUED EVENTS:"));
        BOOST_FOREACH (event_id_pair_type const& ev, scheduler_.events())
        {
            LOG_INFO(("  #%d: %s", ev.first, stringize_event(*ev.second).c_str()));
        }
    }

    static std::string stringize_event(event_type const& ev)
    {
        {
            single_event const* _ev(dynamic_cast<single_event const*>(&ev));
            if (_ev)
            {
                return stringize_event(*_ev);
            }
        }
        {
            pair_event const* _ev(dynamic_cast<pair_event const*>(&ev));
            if (_ev)
            {
                return stringize_event(*_ev);
            }
        }
        {
            multi_event const* _ev(dynamic_cast<multi_event const*>(&ev));
            if (_ev)
            {
                return stringize_event(*_ev);
            }
        }
        return (boost::format("Event(t=%g)") % ev.time()).str();
    }

    static std::string stringize_event_kind(enum single_event_kind kind)
    {
        switch (kind)
        {
        default: /* never get here */ BOOST_ASSERT(0); break;
        case SINGLE_EVENT_ESCAPE:
            return "escape";

        case SINGLE_EVENT_REACTION:
            return "reaction";
        }
    }

    static std::string stringize_event_kind(enum pair_event_kind kind)
    {
        switch (kind)
        {
        default: /* never get here */ BOOST_ASSERT(0); break;
        case PAIR_EVENT_SINGLE_REACTION_0:
            return "reaction(0)";

        case PAIR_EVENT_SINGLE_REACTION_1:
            return "reaction(1)";

        case PAIR_EVENT_COM_ESCAPE:
            return "com_escape";

        case PAIR_EVENT_IV_UNDETERMINED:
            return "iv_undetermined";

        case PAIR_EVENT_IV_ESCAPE:
            return "iv_escape";

        case PAIR_EVENT_IV_REACTION:
            return "iv_reaction";
        }
    }

    static std::string stringize_event(single_event const& ev)
    {
        return (boost::format("SingleEvent(t=%g, kind=%s, domain=%s)") %
            ev.time() % stringize_event_kind(ev.kind()) %
            boost::lexical_cast<std::string>(ev.domain())).str();
    }

    static std::string stringize_event(pair_event const& ev)
    {
        return (boost::format("PairEvent(t=%g, kind=%s, domain=%s)") %
            ev.time() % stringize_event_kind(ev.kind()) %
            boost::lexical_cast<std::string>(ev.domain())).str();
    }

    static std::string stringize_event(multi_event const& ev)
    {
        return (boost::format("MultiEvent(t=%g, domain=%s)") %
            ev.time() % boost::lexical_cast<std::string>(ev.domain())).str();
    }

    template<typename T>
    bool check_domain(AnalyticalSingle<traits_type, T> const& domain) const
    {
        LOG_DEBUG(("checking domain %s", boost::lexical_cast<std::string>(domain).c_str()));
        bool retval(true);
        std::pair<domain_id_type, length_type> closest(
            get_closest_domain(domain.position(), array_gen(domain.id())));
        CHECK(shape_size(shape(domain.shell().second)) <= user_max_shell_size_);
        CHECK(shape_size(shape(domain.shell().second)) <= max_shell_size());
        CHECK(closest.second > shape_size(shape(domain.shell().second)));
        return retval;
    }

    template<typename T>
    bool check_domain(AnalyticalPair<traits_type, T> const& domain) const
    {
        LOG_DEBUG(("checking domain %s", boost::lexical_cast<std::string>(domain).c_str()));
        bool retval(true);
        std::pair<domain_id_type, length_type> closest(
            get_closest_domain(domain.position(), array_gen(domain.id())));
        CHECK(shape_size(shape(domain.shell().second)) <= user_max_shell_size_);
        CHECK(shape_size(shape(domain.shell().second)) <= max_shell_size());
        CHECK(closest.second > shape_size(shape(domain.shell().second)));
        return retval;
    }

    bool check_domain(multi_type const& domain) const
    {
        LOG_DEBUG(("checking domain %s", boost::lexical_cast<std::string>(domain).c_str()));
        bool retval(true);
        BOOST_FOREACH (typename multi_type::spherical_shell_id_pair const& shell,
                       domain.get_shells())
        {
            std::pair<domain_id_type, length_type> closest(
                get_closest_domain(shape_position(shape(shell.second)),
                                   array_gen(domain.id())));
            CHECK(shape_size(shape(shell.second)) <= user_max_shell_size_);
            CHECK(shape_size(shape(shell.second)) <= max_shell_size());
            CHECK(closest.second > shape_size(shape(shell.second)));
        }
        return retval;
    }

    bool check_domain(domain_type const& domain) const
    {
        struct visitor: public ImmutativeDomainVisitor<traits_type>
        {
            virtual ~visitor() {}

            virtual void operator()(multi_type const& domain) const
            {
                retval = self.check_domain(domain);
            }

            virtual void operator()(spherical_single_type const& domain) const
            {
                retval = self.check_domain(domain);
            }

            virtual void operator()(cylindrical_single_type const& domain) const
            {
                retval = self.check_domain(domain);
            }

            virtual void operator()(spherical_pair_type const& domain) const
            {
                retval = self.check_domain(domain);
            }

            virtual void operator()(cylindrical_pair_type const& domain) const
            {
                retval = self.check_domain(domain);
            }

            visitor(EGFRDSimulator const& self, bool& retval)
                : self(self), retval(retval) {}

            EGFRDSimulator const& self;
            bool& retval;
        };

        bool retval;
        domain.accept(visitor(*this, retval));
        return retval;
    }

    bool check_overlap(particle_shape_type const& s) const
    {
        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(
            (*base_type::world_).check_overlap(s));

        if (overlapped && ::size(*overlapped))
        {
            LOG_DEBUG(("check_overlap %s failed:",
                boost::lexical_cast<std::string>(s).c_str()));
            dump_overlapped(*overlapped);
            return false;
        }
        return true;
    }

    bool check_overlap(particle_shape_type const& s, particle_id_type const& ignore) const
    {
        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(
            (*base_type::world_).check_overlap(s, ignore));

        if (overlapped && ::size(*overlapped))
        {
            LOG_DEBUG(("check_overlap %s failed:",
                boost::lexical_cast<std::string>(s).c_str());
            dump_overlapped(*overlapped));
            return false;
        }
        return true;
    }

    bool check_overlap(particle_shape_type const& s, particle_id_type const& ignore1, particle_id_type const& ignore2) const
    {
        boost::scoped_ptr<particle_id_pair_and_distance_list> overlapped(
            (*base_type::world_).check_overlap(s, ignore1, ignore2));

        if (overlapped && ::size(*overlapped))
        {
            LOG_DEBUG(("check_overlap %s failed:",
                boost::lexical_cast<std::string>(s).c_str()));
            dump_overlapped(*overlapped);
            return false;
        }
        return true;
    }

    void dump_overlapped(particle_id_pair_and_distance_list const& list)const
    {
        if (log_.level() == Logger::L_DEBUG)
        {
            BOOST_FOREACH (particle_id_pair_and_distance const& i, list)
            {
                log_.debug("  (%s:%s) %g",
                    boost::lexical_cast<std::string>(i.first.first).c_str(),
                    boost::lexical_cast<std::string>(i.first.second).c_str(),
                    i.second);
            }
        }
    }

    static rate_type calculate_k_tot(reaction_rules const& rules)
    {
        using namespace boost::lambda;
        using boost::lambda::_1;
        using boost::lambda::bind;
        rate_type k_tot(0.);
        std::for_each(boost::begin(rules), boost::end(rules),
            var(k_tot) += bind(&reaction_rule_type::k, _1));
        return k_tot;
    }

    reaction_rule_type const& draw_reaction_rule(reaction_rules const& rules)
    {
        const rate_type k_tot(calculate_k_tot(rules));
        const rate_type t(base_type::rng_.uniform(0., 1.) * k_tot);
        rate_type a(0.);
        BOOST_FOREACH(reaction_rule_type const& r, rules)
        {
            a += r.k();
            if (a > t)
                return r;
        }
        throw std::exception(); // should never happen
    }

    template<typename T1, typename T2>
    static position_type
    adjust_iv_with_old_iv(T1 const& new_iv, T2 const& old_iv)
    {
        length_type const angle(std::acos(old_iv[2] / length(old_iv)));
        if (std::fmod(angle, M_PI) != 0.0)
        {
            position_type const rotation_axis(
                normalize(position_type(-old_iv[1], old_iv[0], 0.)));
            return rotate_vector(new_iv, rotation_axis, angle);
        }
        else if (angle == 0.)
        {
            return new_iv;
        }
        else
        {
            return position_type(new_iv[0], new_iv[1], -new_iv[1]); 
        }
    }

    template<typename T>
    bool check_pair_pos(AnalyticalPair<traits_type, T> const& domain,
                        boost::array<particle_id_pair, 2> const& new_particles)
    {
        length_type const new_distance(
            (*base_type::world_).distance(new_particles[0].second.position(),
                                          new_particles[1].second.position()));
        length_type const r01(new_particles[0].second.radius() +
                              new_particles[1].second.radius());

        if (new_distance <= r01)
        {
            log_.warn(
                "rejected move: pair=%s, radii=%g, particle_distance=%g",
                boost::lexical_cast<std::string>(domain).c_str(),
                r01, new_distance);
            return false;
        }

        // particles within mobility radius.
        position_type const& com(shape(domain.shell().second).position());
        length_type const radius(shape(domain.shell().second).radius());
        length_type const d[2] = {
            (*base_type::world_).distance(com, new_particles[0].second.position()) + new_particles[0].second.radius(),
            (*base_type::world_).distance(com, new_particles[1].second.position()) + new_particles[1].second.radius()
        };
        if (d[0] > radius || d[1] > radius)
        {
            log_.warn(
                "rejected move: new particle(s) out of protective sphere: pair=%s, radii=%g, d0=%g, d1=%g",
                boost::lexical_cast<std::string>(domain).c_str(),
                d[0], d[1]);
            return false;
        }
        return true;
    }

    template<typename T>
    static PairGreensFunction* choose_pair_greens_function(
            AnalyticalPair<traits_type, T> const& domain, time_type t)
    {
        length_type const r0(domain.r0());
        length_type const distance_from_sigma(r0 - domain.sigma());
        length_type const distance_from_shell(domain.a_r() - r0);
        length_type const threshold_distance(
            traits_type::CUTOFF_FACTOR * std::sqrt(6. * domain.D_tot() * t));

        BOOST_ASSERT(::size(domain.reactions()) == 1);
        if (distance_from_sigma < threshold_distance)
        {
            if (distance_from_shell < threshold_distance)
            {
                // near both a and sigma;
                // use GreensFunction3DRadAbs
                LOG_DEBUG(("GF: normal"));
                return new GreensFunction3DRadAbs(
                    domain.D_tot(), domain.reactions()[0].k(),
                    r0, domain.sigma(), domain.a_r());
            }
            else
            {
                // near sigma; use GreensFunction3DRadInf
                LOG_DEBUG(("GF: only sigma"));
                return new GreensFunction3DRadInf(
                    domain.D_tot(), domain.reactions()[0].k(),
                    r0, domain.sigma());
            }
        }
        else
        {
            if (distance_from_shell < threshold_distance)
            {
                // near a;
                LOG_DEBUG(("GF: only a"));
                return new GreensFunction3DAbs(
                    domain.D_tot(), r0, domain.a_r());
            }
            else
            {
                // distant from both a and sigma; 
                LOG_DEBUG(("GF: free"));
                return new GreensFunction3D(domain.D_tot(), r0);
            }
        }
    }

    static length_type calculate_single_shell_size(
            single_type const& single,
            single_type const& closest,
            length_type distance,
            length_type shell_distance)
    {
        length_type const min_radius0(single.particle().second.radius());
        D_type const D0(single.particle().second.D());
        if (D0 == 0)
            return min_radius0;
        length_type const min_radius1(closest.particle().second.radius());
        D_type const D1(closest.particle().second.D());
        length_type const min_radius01(min_radius0 + min_radius1);
        length_type const sqrtD0(std::sqrt(D0));

        return std::max(std::min(sqrtD0 / (sqrtD0 + std::sqrt(D1))
                            * (distance - min_radius01) + min_radius0,
                            shell_distance / traits_type::SAFETY),
                        min_radius0);
    }

protected:
    int const num_retries_;
    double const bd_dt_factor_;
    length_type const user_max_shell_size_;

    domain_map domains_;
    spherical_shell_matrix_type ssmat_;
    cylindrical_shell_matrix_type csmat_;
    shell_matrix_map_type smatm_;
    shell_id_generator shidgen_;
    domain_id_generator didgen_;
    event_scheduler_type scheduler_;
    boost::array<int, NUM_SINGLE_EVENT_KINDS> single_step_count_;
    boost::array<int, NUM_PAIR_EVENT_KINDS> pair_step_count_;
    boost::array<int, multi_type::NUM_MULTI_EVENT_KINDS> multi_step_count_;
    boost::array<int, NUM_DOMAIN_KINDS> domain_count_per_type_;
    length_type single_shell_factor_;
    length_type multi_shell_factor_;
    unsigned int rejected_moves_;
    unsigned int zero_step_count_;
    bool dirty_;
    static Logger& log_;
};
#undef CHECK

template<typename Ttraits>
inline char const* retrieve_domain_type_name(
    typename EGFRDSimulator<Ttraits>::spherical_single_type const&)
{
    return "SphericalSingle";
}

template<typename Ttraits>
inline char const* retrieve_domain_type_name(
    typename EGFRDSimulator<Ttraits>::cylindrical_single_type const&)
{
    return "CylindricalSingle";
}

template<typename Ttraits>
inline char const* retrieve_domain_type_name(
    typename EGFRDSimulator<Ttraits>::spherical_pair_type const&)
{
    return "SphericalPair";
}

template<typename Ttraits>
inline char const* retrieve_domain_type_name(
    typename EGFRDSimulator<Ttraits>::cylindrical_pair_type const&)
{
    return "CylindricalPair";
}



template<typename Ttraits_>
Logger& EGFRDSimulator<Ttraits_>::log_(Logger::get_logger("ecell.EGFRDSimulator"));

#endif /* EGFRDSIMULATOR_HPP */
 </xmp> 
<h3> EventScheduler.hpp </h3> <xmp>

#ifndef __EVENTSCHEDULER_HPP
#define __EVENTSCHEDULER_HPP
//
// written by Koichi Takahashi <shafi@e-cell.org>,
// E-Cell Project.
//

#include <boost/range/iterator_range.hpp>
#include <boost/shared_ptr.hpp>
#include <stdexcept>
#include "DynamicPriorityQueue.hpp"

/**
   Event scheduler.

   This class works as a sequential
   event scheduler with a heap-tree based priority queue.

*/

template<typename Ttime_>
class EventScheduler
{
public:
    typedef Ttime_ time_type;

    struct Event
    {
        typedef Ttime_ time_type;

        Event(time_type const& time): time_(time) {}

        virtual ~Event() {}

        time_type const& time() const
        {
            return time_;
        }

    protected:
        const time_type time_;
    };

protected:
    struct event_comparator
    {
        bool operator()(boost::shared_ptr<Event> const& lhs,
                        boost::shared_ptr<Event> const& rhs) const
        {
            return lhs->time() <= rhs->time();
        }
    };

    typedef DynamicPriorityQueue<boost::shared_ptr<Event>, event_comparator> EventPriorityQueue;

public:
    typedef typename EventPriorityQueue::size_type size_type;
    typedef typename EventPriorityQueue::identifier_type identifier_type;
    typedef typename EventPriorityQueue::value_type value_type;
    typedef boost::iterator_range<typename EventPriorityQueue::const_iterator> events_range;

public:


    EventScheduler(): time_( 0.0 ) {}

    ~EventScheduler() {}

    time_type time() const
    {
        return time_;
    }

    size_type size() const
    {
        return eventPriorityQueue_.size();
    }

    value_type const& top() const
    {
        return eventPriorityQueue_.top();
    }

    value_type pop()
    {
        if (eventPriorityQueue_.empty())
        {
            throw std::out_of_range("queue is empty");
        }
        const value_type top(eventPriorityQueue_.top());
        eventPriorityQueue_.pop();
        time_ = top.second->time();
        return top;
    }

    value_type const& second() const
    {
        return eventPriorityQueue_.second();
    }

    boost::shared_ptr<Event> get(identifier_type const& id) const
    {
        return eventPriorityQueue_.get(id);
    }

    void clear()
    {
        time_ = 0.0;
        eventPriorityQueue_.clear();
    }

    identifier_type add(boost::shared_ptr<Event> const& event)
    {
        return eventPriorityQueue_.push(event);
    }

    void remove(identifier_type const& id)
    {
        eventPriorityQueue_.pop(id);
    }

    void update(value_type const& pair)
    {
        eventPriorityQueue_.replace(pair);
    }

    bool check() const
    {
        return eventPriorityQueue_.check();
    }

    events_range events() const
    {
        return boost::make_iterator_range(eventPriorityQueue_.begin(),
                                          eventPriorityQueue_.end());
    }

private:
    EventPriorityQueue eventPriorityQueue_;
    time_type time_;
};

#endif /* __EVENTSCHEDULER_HPP */
 </xmp> 
<h3> exceptions.hpp </h3> <xmp>

#ifndef EXCEPTIONS_HPP
#define EXCEPTIONS_HPP

#include <string>
#include <exception>
#include <stdexcept>

class illegal_state: public std::exception
{
public:
    illegal_state(std::string const& str): str_(str) {}

    virtual ~illegal_state() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class illegal_argument: public std::exception
{
public:
    illegal_argument(std::string const& str): str_(str) {}

    virtual ~illegal_argument() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class not_found: public std::exception
{
public:
    not_found(std::string const& str): str_(str) {}

    virtual ~not_found() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class already_exists: public std::exception
{
public:
    already_exists(std::string const& str): str_(str) {}

    virtual ~already_exists() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class unsupported: public std::exception
{
public:
    unsupported(std::string const& str): str_(str) {}

    virtual ~unsupported() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class propagation_error: public std::runtime_error
{
public:
    propagation_error(std::string const& msg): std::runtime_error(msg) {}

    virtual ~propagation_error() throw() {}

private:
    std::string str_;
};

class not_implemented: public std::exception
{
public:
    not_implemented(std::string const& str): str_(str) {}

    virtual ~not_implemented() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

class no_space: public std::exception
{
public:
    no_space(std::string const& str = ""): str_(str) {}

    virtual ~no_space() throw() {}

    virtual const char* what() const throw()
    {
        return str_.c_str();
    }

private:
    std::string str_;
};

#endif /* EXCEPTIONS_HPP */
 </xmp> 
<h3> factorial.hpp </h3> <xmp>

#ifndef FACTORIAL_HPP
#define FACTORIAL_HPP



// Table adopted and modified from GNU Scientific Library Version 1.9 
// (gamma.c).
const int FACTORIAL_NMAX( 170 );

static const double factorials[FACTORIAL_NMAX+1] = 
{
    1.0,
    1.0,
    2.0,
    6.0,
    24.0,
    120.0,
    720.0,
    5040.0,
    40320.0,

    362880.0,
    3628800.0,
    39916800.0,
    479001600.0,

    6227020800.0,
    87178291200.0,
    1307674368000.0,
    20922789888000.0,
    355687428096000.0,
    6402373705728000.0,
    121645100408832000.0,
    2432902008176640000.0,
    51090942171709440000.0,
    1124000727777607680000.0,
    25852016738884976640000.0,
    620448401733239439360000.0,
    15511210043330985984000000.0,
    403291461126605635584000000.0,
    10888869450418352160768000000.0,
    304888344611713860501504000000.0,
    8841761993739701954543616000000.0,
    265252859812191058636308480000000.0,
    8222838654177922817725562880000000.0,
    263130836933693530167218012160000000.0,
    8683317618811886495518194401280000000.0,
    2.95232799039604140847618609644e38,
    1.03331479663861449296666513375e40,
    3.71993326789901217467999448151e41,
    1.37637530912263450463159795816e43,
    5.23022617466601111760007224100e44,
    2.03978820811974433586402817399e46,
    8.15915283247897734345611269600e47,
    3.34525266131638071081700620534e49,
    1.40500611775287989854314260624e51,
    6.04152630633738356373551320685e52,
    2.65827157478844876804362581101e54,
    1.19622220865480194561963161496e56,
    5.50262215981208894985030542880e57,
    2.58623241511168180642964355154e59,
    1.24139155925360726708622890474e61,
    6.08281864034267560872252163321e62,
    3.04140932017133780436126081661e64,
    1.55111875328738228022424301647e66,
    8.06581751709438785716606368564e67,
    4.27488328406002556429801375339e69,
    2.30843697339241380472092742683e71,
    1.26964033536582759259651008476e73,
    7.10998587804863451854045647464e74,
    4.05269195048772167556806019054e76,
    2.35056133128287857182947491052e78,
    1.38683118545689835737939019720e80,
    8.32098711274139014427634118320e81,
    5.07580213877224798800856812177e83,
    3.14699732603879375256531223550e85,
    1.982608315404440064116146708360e87,
    1.268869321858841641034333893350e89,
    8.247650592082470666723170306800e90,
    5.443449390774430640037292402480e92,
    3.647111091818868528824985909660e94,
    2.480035542436830599600990418570e96,
    1.711224524281413113724683388810e98,
    1.197857166996989179607278372170e100,
    8.504785885678623175211676442400e101,
    6.123445837688608686152407038530e103,
    4.470115461512684340891257138130e105,
    3.307885441519386412259530282210e107,
    2.480914081139539809194647711660e109,
    1.885494701666050254987932260860e111,
    1.451830920282858696340707840860e113,
    1.132428117820629783145752115870e115,
    8.946182130782975286851441715400e116,
    7.156945704626380229481153372320e118,
    5.797126020747367985879734231580e120,
    4.753643337012841748421382069890e122,
    3.945523969720658651189747118010e124,
    3.314240134565353266999387579130e126,
    2.817104114380550276949479442260e128,
    2.422709538367273238176552320340e130,
    2.107757298379527717213600518700e132,
    1.854826422573984391147968456460e134,
    1.650795516090846108121691926250e136,
    1.485715964481761497309522733620e138,
    1.352001527678402962551665687590e140,
    1.243841405464130725547532432590e142,
    1.156772507081641574759205162310e144,
    1.087366156656743080273652852570e146,
    1.032997848823905926259970209940e148,
    9.916779348709496892095714015400e149,
    9.619275968248211985332842594960e151,
    9.426890448883247745626185743100e153,
    9.332621544394415268169923885600e155,
    9.33262154439441526816992388563e157,
    9.42594775983835942085162312450e159,
    9.61446671503512660926865558700e161,
    9.90290071648618040754671525458e163,
    1.02990167451456276238485838648e166,
    1.08139675824029090050410130580e168,
    1.146280563734708354534347384148e170,
    1.226520203196137939351751701040e172,
    1.324641819451828974499891837120e174,
    1.443859583202493582204882102460e176,
    1.588245541522742940425370312710e178,
    1.762952551090244663872161047110e180,
    1.974506857221074023536820372760e182,
    2.231192748659813646596607021220e184,
    2.543559733472187557120132004190e186,
    2.925093693493015690688151804820e188,
    3.393108684451898201198256093590e190,
    3.96993716080872089540195962950e192,
    4.68452584975429065657431236281e194,
    5.57458576120760588132343171174e196,
    6.68950291344912705758811805409e198,
    8.09429852527344373968162284545e200,
    9.87504420083360136241157987140e202,
    1.21463043670253296757662432419e205,
    1.50614174151114087979501416199e207,
    1.88267717688892609974376770249e209,
    2.37217324288004688567714730514e211,
    3.01266001845765954480997707753e213,
    3.85620482362580421735677065923e215,
    4.97450422247728744039023415041e217,
    6.46685548922047367250730439554e219,
    8.47158069087882051098456875820e221,
    1.11824865119600430744996307608e224,
    1.48727070609068572890845089118e226,
    1.99294274616151887673732419418e228,
    2.69047270731805048359538766215e230,
    3.65904288195254865768972722052e232,
    5.01288874827499166103492629211e234,
    6.91778647261948849222819828311e236,
    9.61572319694108900419719561353e238,
    1.34620124757175246058760738589e241,
    1.89814375907617096942852641411e243,
    2.69536413788816277658850750804e245,
    3.85437071718007277052156573649e247,
    5.55029383273930478955105466055e249,
    8.04792605747199194484902925780e251,
    1.17499720439091082394795827164e254,
    1.72724589045463891120349865931e256,
    2.55632391787286558858117801578e258,
    3.80892263763056972698595524351e260,
    5.71338395644585459047893286526e262,
    8.62720977423324043162318862650e264,
    1.31133588568345254560672467123e267,
    2.00634390509568239477828874699e269,
    3.08976961384735088795856467036e271,
    4.78914290146339387633577523906e273,
    7.47106292628289444708380937294e275,
    1.17295687942641442819215807155e278,
    1.85327186949373479654360975305e280,
    2.94670227249503832650433950735e282,
    4.71472363599206132240694321176e284,
    7.59070505394721872907517857094e286,
    1.22969421873944943411017892849e289,
    2.00440157654530257759959165344e291,
    3.28721858553429622726333031164e293,
    5.42391066613158877498449501421e295,
    9.00369170577843736647426172359e297,
    1.50361651486499904020120170784e300,
    2.52607574497319838753801886917e302,
    4.26906800900470527493925188890e304,
    7.25741561530799896739672821113e306,

    /*
      1.24101807021766782342484052410e309,
      2.13455108077438865629072570146e311,
      3.69277336973969237538295546352e313,
      6.42542566334706473316634250653e315,
      1.12444949108573632830410993864e318,
      1.97903110431089593781523349201e320,
      3.50288505463028580993296328086e322,
      6.23513539724190874168067463993e324,
      1.11608923610630166476084076055e327,
      2.00896062499134299656951336898e329,
      3.63621873123433082379081919786e331,
      6.61791809084648209929929094011e333,
      1.21107901062490622417177024204e336,
      2.22838537954982745247605724535e338,
      4.12251295216718078708070590390e340,
      7.66787409103095626397011298130e342,
      1.43389245502278882136241112750e345,
      2.69571781544284298416133291969e347,
      5.09490667118697324006491921822e349,
      9.68032267525524915612334651460e351,
      1.84894163097375258881955918429e354,
      3.54996793146960497053355363384e356,
      6.85143810773633759312975851330e358,
      1.32917899290084949306717315158e361,
      2.59189903615665651148098764559e363,
      5.08012211086704676250273578535e365,
      1.00078405584080821221303894971e368,
      1.98155243056480026018181712043e370,
      3.94328933682395251776181606966e372,
      7.88657867364790503552363213932e374,
    */
};


static const double factorials_r[FACTORIAL_NMAX+1] = 
{
    1.0 / 1.0,
    1.0 / 1.0,
    1.0 / 2.0,
    1.0 / 6.0,
    1.0 / 24.0,
    1.0 / 120.0,
    1.0 / 720.0,
    1.0 / 5040.0,
    1.0 / 40320.0,
    1.0 /  362880.0,
    1.0 / 3628800.0,
    1.0 / 39916800.0,
    1.0 / 479001600.0,
    1.0 /  6227020800.0,
    1.0 / 87178291200.0,
    1.0 / 1307674368000.0,
    1.0 / 20922789888000.0,
    1.0 / 355687428096000.0,
    1.0 / 6402373705728000.0,
    1.0 / 121645100408832000.0,
    1.0 / 2432902008176640000.0,
    1.0 / 51090942171709440000.0,
    1.0 / 1124000727777607680000.0,
    1.0 / 25852016738884976640000.0,
    1.0 / 620448401733239439360000.0,
    1.0 / 15511210043330985984000000.0,
    1.0 / 403291461126605635584000000.0,
    1.0 / 10888869450418352160768000000.0,
    1.0 / 304888344611713860501504000000.0,
    1.0 / 8841761993739701954543616000000.0,
    1.0 / 265252859812191058636308480000000.0,
    1.0 / 8222838654177922817725562880000000.0,
    1.0 / 263130836933693530167218012160000000.0,
    1.0 / 8683317618811886495518194401280000000.0,
    1.0 / 2.95232799039604140847618609644e38,
    1.0 / 1.03331479663861449296666513375e40,
    1.0 / 3.71993326789901217467999448151e41,
    1.0 / 1.37637530912263450463159795816e43,
    1.0 / 5.23022617466601111760007224100e44,
    1.0 / 2.03978820811974433586402817399e46,
    1.0 / 8.15915283247897734345611269600e47,
    1.0 / 3.34525266131638071081700620534e49,
    1.0 / 1.40500611775287989854314260624e51,
    1.0 / 6.04152630633738356373551320685e52,
    1.0 / 2.65827157478844876804362581101e54,
    1.0 / 1.19622220865480194561963161496e56,
    1.0 / 5.50262215981208894985030542880e57,
    1.0 / 2.58623241511168180642964355154e59,
    1.0 / 1.24139155925360726708622890474e61,
    1.0 / 6.08281864034267560872252163321e62,
    1.0 / 3.04140932017133780436126081661e64,
    1.0 / 1.55111875328738228022424301647e66,
    1.0 / 8.06581751709438785716606368564e67,
    1.0 / 4.27488328406002556429801375339e69,
    1.0 / 2.30843697339241380472092742683e71,
    1.0 / 1.26964033536582759259651008476e73,
    1.0 / 7.10998587804863451854045647464e74,
    1.0 / 4.05269195048772167556806019054e76,
    1.0 / 2.35056133128287857182947491052e78,
    1.0 / 1.38683118545689835737939019720e80,
    1.0 / 8.32098711274139014427634118320e81,
    1.0 / 5.07580213877224798800856812177e83,
    1.0 / 3.14699732603879375256531223550e85,
    1.0 / 1.982608315404440064116146708360e87,
    1.0 / 1.268869321858841641034333893350e89,
    1.0 / 8.247650592082470666723170306800e90,
    1.0 / 5.443449390774430640037292402480e92,
    1.0 / 3.647111091818868528824985909660e94,
    1.0 / 2.480035542436830599600990418570e96,
    1.0 / 1.711224524281413113724683388810e98,
    1.0 / 1.197857166996989179607278372170e100,
    1.0 / 8.504785885678623175211676442400e101,
    1.0 / 6.123445837688608686152407038530e103,
    1.0 / 4.470115461512684340891257138130e105,
    1.0 / 3.307885441519386412259530282210e107,
    1.0 / 2.480914081139539809194647711660e109,
    1.0 / 1.885494701666050254987932260860e111,
    1.0 / 1.451830920282858696340707840860e113,
    1.0 / 1.132428117820629783145752115870e115,
    1.0 / 8.946182130782975286851441715400e116,
    1.0 / 7.156945704626380229481153372320e118,
    1.0 / 5.797126020747367985879734231580e120,
    1.0 / 4.753643337012841748421382069890e122,
    1.0 / 3.945523969720658651189747118010e124,
    1.0 / 3.314240134565353266999387579130e126,
    1.0 / 2.817104114380550276949479442260e128,
    1.0 / 2.422709538367273238176552320340e130,
    1.0 / 2.107757298379527717213600518700e132,
    1.0 / 1.854826422573984391147968456460e134,
    1.0 / 1.650795516090846108121691926250e136,
    1.0 / 1.485715964481761497309522733620e138,
    1.0 / 1.352001527678402962551665687590e140,
    1.0 / 1.243841405464130725547532432590e142,
    1.0 / 1.156772507081641574759205162310e144,
    1.0 / 1.087366156656743080273652852570e146,
    1.0 / 1.032997848823905926259970209940e148,
    1.0 / 9.916779348709496892095714015400e149,
    1.0 / 9.619275968248211985332842594960e151,
    1.0 / 9.426890448883247745626185743100e153,
    1.0 / 9.332621544394415268169923885600e155,
    1.0 / 9.33262154439441526816992388563e157,
    1.0 / 9.42594775983835942085162312450e159,
    1.0 / 9.61446671503512660926865558700e161,
    1.0 / 9.90290071648618040754671525458e163,
    1.0 / 1.02990167451456276238485838648e166,
    1.0 / 1.08139675824029090050410130580e168,
    1.0 / 1.146280563734708354534347384148e170,
    1.0 / 1.226520203196137939351751701040e172,
    1.0 / 1.324641819451828974499891837120e174,
    1.0 / 1.443859583202493582204882102460e176,
    1.0 / 1.588245541522742940425370312710e178,
    1.0 / 1.762952551090244663872161047110e180,
    1.0 / 1.974506857221074023536820372760e182,
    1.0 / 2.231192748659813646596607021220e184,
    1.0 / 2.543559733472187557120132004190e186,
    1.0 / 2.925093693493015690688151804820e188,
    1.0 / 3.393108684451898201198256093590e190,
    1.0 / 3.96993716080872089540195962950e192,
    1.0 / 4.68452584975429065657431236281e194,
    1.0 / 5.57458576120760588132343171174e196,
    1.0 / 6.68950291344912705758811805409e198,
    1.0 / 8.09429852527344373968162284545e200,
    1.0 / 9.87504420083360136241157987140e202,
    1.0 / 1.21463043670253296757662432419e205,
    1.0 / 1.50614174151114087979501416199e207,
    1.0 / 1.88267717688892609974376770249e209,
    1.0 / 2.37217324288004688567714730514e211,
    1.0 / 3.01266001845765954480997707753e213,
    1.0 / 3.85620482362580421735677065923e215,
    1.0 / 4.97450422247728744039023415041e217,
    1.0 / 6.46685548922047367250730439554e219,
    1.0 / 8.47158069087882051098456875820e221,
    1.0 / 1.11824865119600430744996307608e224,
    1.0 / 1.48727070609068572890845089118e226,
    1.0 / 1.99294274616151887673732419418e228,
    1.0 / 2.69047270731805048359538766215e230,
    1.0 / 3.65904288195254865768972722052e232,
    1.0 / 5.01288874827499166103492629211e234,
    1.0 / 6.91778647261948849222819828311e236,
    1.0 / 9.61572319694108900419719561353e238,
    1.0 / 1.34620124757175246058760738589e241,
    1.0 / 1.89814375907617096942852641411e243,
    1.0 / 2.69536413788816277658850750804e245,
    1.0 / 3.85437071718007277052156573649e247,
    1.0 / 5.55029383273930478955105466055e249,
    1.0 / 8.04792605747199194484902925780e251,
    1.0 / 1.17499720439091082394795827164e254,
    1.0 / 1.72724589045463891120349865931e256,
    1.0 / 2.55632391787286558858117801578e258,
    1.0 / 3.80892263763056972698595524351e260,
    1.0 / 5.71338395644585459047893286526e262,
    1.0 / 8.62720977423324043162318862650e264,
    1.0 / 1.31133588568345254560672467123e267,
    1.0 / 2.00634390509568239477828874699e269,
    1.0 / 3.08976961384735088795856467036e271,
    1.0 / 4.78914290146339387633577523906e273,
    1.0 / 7.47106292628289444708380937294e275,
    1.0 / 1.17295687942641442819215807155e278,
    1.0 / 1.85327186949373479654360975305e280,
    1.0 / 2.94670227249503832650433950735e282,
    1.0 / 4.71472363599206132240694321176e284,
    1.0 / 7.59070505394721872907517857094e286,
    1.0 / 1.22969421873944943411017892849e289,
    1.0 / 2.00440157654530257759959165344e291,
    1.0 / 3.28721858553429622726333031164e293,
    1.0 / 5.42391066613158877498449501421e295,
    1.0 / 9.00369170577843736647426172359e297,
    1.0 / 1.50361651486499904020120170784e300,
    1.0 / 2.52607574497319838753801886917e302,
    1.0 / 4.26906800900470527493925188890e304,
    1.0 / 7.25741561530799896739672821113e306,

    /*
      1.0 /   1.24101807021766782342484052410e309,
      1.0 /   2.13455108077438865629072570146e311,
      1.0 /   3.69277336973969237538295546352e313,
      1.0 /   6.42542566334706473316634250653e315,
      1.0 /   1.12444949108573632830410993864e318,
      1.0 /   1.97903110431089593781523349201e320,
      1.0 /   3.50288505463028580993296328086e322,
      1.0 /   6.23513539724190874168067463993e324,
      1.0 /   1.11608923610630166476084076055e327,
      1.0 /   2.00896062499134299656951336898e329,
      1.0 /   3.63621873123433082379081919786e331,
      1.0 /   6.61791809084648209929929094011e333,
      1.0 /   1.21107901062490622417177024204e336,
      1.0 /   2.22838537954982745247605724535e338,
      1.0 /   4.12251295216718078708070590390e340,
      1.0 /   7.66787409103095626397011298130e342,
      1.0 /   1.43389245502278882136241112750e345,
      1.0 /   2.69571781544284298416133291969e347,
      1.0 /   5.09490667118697324006491921822e349,
      1.0 /   9.68032267525524915612334651460e351,
      1.0 /   1.84894163097375258881955918429e354,
      1.0 /   3.54996793146960497053355363384e356,
      1.0 /   6.85143810773633759312975851330e358,
      1.0 /   1.32917899290084949306717315158e361,
      1.0 /   2.59189903615665651148098764559e363,
      1.0 /   5.08012211086704676250273578535e365,
      1.0 /   1.00078405584080821221303894971e368,
      1.0 /   1.98155243056480026018181712043e370,
      1.0 /   3.94328933682395251776181606966e372,
      1.0 /   7.88657867364790503552363213932e374,
    */
};


inline const double factorial( const unsigned int n )
{
    // assert( n <= FACTORIAL_NMAX );
    return factorials[n];
}


inline const double factorial_r( const unsigned int n )
{
    // assert( n <= FACTORIAL_NMAX );
    return factorials_r[n];
}

#endif /* FACTORIAL_HPP */
 </xmp> 
<h3> filters.hpp </h3> <xmp>

#ifndef ALGORITHM_HPP
#define ALGORITHM_HPP

#include <functional>
#include <cmath>
#include <boost/range/iterator.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits/is_const.hpp>
#include "Shape.hpp"
#include "geometry.hpp"

template<typename Toc_, typename Tfun_, typename Tsphere_>
class neighbor_filter
        : public std::binary_function<
            typename boost::range_iterator<Toc_>::type,
            typename Toc_::position_type,
            void>
{
    typedef typename boost::range_iterator<Toc_>::type first_argument_type;
    typedef typename Toc_::position_type second_argument_type;
    typedef void result_type;
    typedef Tsphere_ sphere_type;

public:
    inline neighbor_filter(Tfun_& next,
            const sphere_type& cmp)
        : next_(next), cmp_(cmp) {}

    inline result_type operator()(first_argument_type i,
            second_argument_type const& off) const {
        typename first_argument_type::reference item(*i);

        const typename sphere_type::length_type dist(
            distance(shape(offset(item.second, off)), cmp_.position()));
        if (dist < cmp_.radius())
        {
            next_(i, dist);
        }
    }

private:
    Tfun_& next_;
    const sphere_type cmp_;
};

template<typename Toc_, typename Tfun_, typename Tsphere_>
inline void take_neighbor(Toc_& oc, Tfun_& fun, const Tsphere_& cmp)
{
    oc.each_neighbor(oc.index(cmp.position()),
                     neighbor_filter<Toc_, Tfun_, Tsphere_>(fun, cmp));
}

template<typename Toc_, typename Tfun_, typename Tsphere_>
inline void take_neighbor(Toc_ const& oc, Tfun_& fun, const Tsphere_& cmp)
{
    oc.each_neighbor(oc.index(cmp.position()),
                     neighbor_filter<Toc_ const, Tfun_, Tsphere_>(fun, cmp));
}

template<typename Toc_, typename Tfun_, typename Tsphere_>
inline void take_neighbor_cyclic(Toc_& oc, Tfun_& fun, const Tsphere_& cmp)
{
    oc.each_neighbor_cyclic(oc.index(cmp.position()),
            neighbor_filter<Toc_, Tfun_, Tsphere_>(fun, cmp));
}

template<typename Toc_, typename Tfun_, typename Tsphere_>
inline void take_neighbor_cyclic(Toc_ const& oc, Tfun_& fun, const Tsphere_& cmp)
{
    oc.each_neighbor_cyclic(oc.index(cmp.position()),
            neighbor_filter<Toc_ const, Tfun_, Tsphere_>(fun, cmp));
}

#endif /* ALGORITHM_HPP */
 </xmp> 
<h3> findRoot.hpp </h3> <xmp>

#ifndef FIND_ROOT_HPP
#define FIND_ROOT_HPP

#include <gsl/gsl_roots.h>

#include "Defs.hpp"


Real findRoot(gsl_function const& F, gsl_root_fsolver* solver, Real low,
              Real high, Real tol_abs, Real tol_rel, char const* funcName);

#endif /* FIND_ROOT_HPP */
 </xmp> 
<h3> freeFunctions.hpp </h3> <xmp>

#ifndef FREE_FUNTIONS_HPP
#define FREE_FUNTIONS_HPP

#include "Defs.hpp"

Real expxsq_erfc(Real x);

Real W(Real a, Real b);

Real p_irr(Real r, Real r0, Real t, Real kf, Real D, Real sigma);

Real __p_irr(Real r, Real r0, Real t, Real kf, Real D, Real sigma, Real alpha);

Real p_free(Real r, Real r0, Real theta, Real t); 

Real p_survival_irr(Real t, Real r0, Real kf, Real D, Real sigma);

Real __p_reaction_irr(Real t, Real r0, Real kf, Real D, Real sigma, Real alpha, Real kD);

Real __p_reaction_irr_t_inf(Real r0, Real kf, Real sigma, Real kD);

Real p_survival_nocollision(Real t, Real r0, Real D, Real a);

Real dp_survival_nocollision(Real t, Real r0, Real D, Real a);

Real p_theta_free(Real theta, Real r, Real r0, Real t, Real D);

Real ip_theta_free(Real theta, Real r, Real r0, Real t, Real D);

Real g_bd(Real r0, Real sigma, Real t, Real D);

Real I_bd(Real sigma, Real t, Real D);

Real I_bd_r(Real r, Real sigma, Real t, Real D);

Real drawR_gbd(Real rnd, Real sigma, Real t, Real D);

#endif /* FREE_FUNTIONS_HPP */
 </xmp> 
<h3> funcSum.hpp </h3> <xmp>

#if !defined( __FUNCSUM_HPP )
#define __FUNCSUM_HPP

#include <boost/function.hpp>
#include <cstddef>

#include "Defs.hpp"

static const Real TOLERANCE( 1e-8 );

Real funcSum_all(boost::function<Real(unsigned int i)> f, std::size_t max_i);

Real funcSum_all_accel(boost::function<Real(unsigned int i)> f,
                       std::size_t max_i, Real tolerance = TOLERANCE);

Real funcSum(boost::function<Real(unsigned int i)> f,
             std::size_t max_i, Real tolerance = TOLERANCE);


#endif /* __FUNCSUM_HPP */
 </xmp> 
<h3> generator.hpp </h3> <xmp>

#ifndef GENERATOR_HPP
#define GENERATOR_HPP

#include <cstddef>
#include <stdexcept>
#include <functional>

#include <boost/utility/enable_if.hpp>
#include <boost/call_traits.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/optional.hpp>
#include <boost/range/value_type.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/size.hpp>
#include <boost/range/size_type.hpp>
#include <boost/range/iterator.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/iterator_range.hpp>
#include <boost/mpl/or.hpp>
#include <boost/iterator/iterator_categories.hpp>
#include <boost/iterator/iterator_traits.hpp>
#include <boost/iterator/iterator_facade.hpp>
#include <boost/iterator/is_readable_iterator.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/type_traits/is_convertible.hpp>
#include <boost/type_traits/remove_reference.hpp>
#include <boost/type_traits/remove_const.hpp>
#include "utils/range.hpp"
#include "utils/reset.hpp"
#include "utils/reference_or_instance.hpp"

template<typename Tgen_>
bool valid(Tgen_ const& t)
{
    return true;
}


template<typename Tgen_>
std::size_t count(Tgen_ const& t)
{
    throw std::runtime_error("generation is not limited");
}

template<typename Tgen_, typename Tpred_>
bool drop_while(Tgen_& gen, Tpred_& pred)
{
    do
    {
        if (!valid(gen))
            return false;
    } while (pred(gen()));
    return true;
}

template<typename Tgen_, typename Tpred_>
bool drop_until(Tgen_& gen, Tpred_& pred)
{
    do
    {
        if (!valid(gen))
            return false;
    } while (!pred(gen()));
    return true;
}

template<typename Tgen_>
bool cue(Tgen_& gen,
    typename boost::call_traits<typename Tgen_::result_type>::param_type val)
{
    do
    {
        if (!valid(gen))
            return false;
    } while (val != gen());

    return true;
}

template<typename Tretval_>
struct abstract_generator
{
    typedef Tretval_ result_type;

    virtual ~abstract_generator() {}

    virtual Tretval_ operator()() = 0;
};


template<typename Tretval_>
struct abstract_limited_generator: public abstract_generator<Tretval_>
{
    virtual ~abstract_limited_generator() {}

    virtual std::size_t count() const
    {
        throw std::runtime_error("indetermined");
    }

    virtual bool valid() const = 0;

    virtual Tretval_ operator()() = 0;
};


template<typename Tretval_>
bool valid(abstract_limited_generator<Tretval_> const& gen)
{
    return gen.valid();
}

template<typename Tretval_>
std::size_t count(abstract_limited_generator<Tretval_> const& gen)
{
    return gen.count();
}

template<typename Tgen_, typename Tpointer_>
class ptr_generator
{
public:
    typedef Tgen_ generator_type;
    typedef Tpointer_ pointer_type;
    typedef typename generator_type::result_type result_type;

public:
    ptr_generator(Tpointer_ const& impl): impl_(impl)
    {
        BOOST_ASSERT(&*impl_);
    }

    explicit ptr_generator(Tpointer_& impl): impl_(impl)
    {
        BOOST_ASSERT(&*impl_);
    }

    ptr_generator(ptr_generator const& that)
        : impl_(const_cast<ptr_generator&>(that).impl_) {}

    explicit ptr_generator(ptr_generator& that): impl_(that.impl_) {}

    bool valid() const
    {
        return ::valid(*impl_);
    }

    std::size_t count() const
    {
        return ::count(*impl_);
    }

    result_type operator()()
    {
        return (*impl_)();
    }

    Tpointer_ const& ptr() const
    {
        return impl_;
    }

private:
    ptr_generator const& operator=(ptr_generator const& rhs)
    {
        impl_ = rhs.impl_;
        return *this;
    }

private:
    Tpointer_ impl_;
};

template<typename Tgen, typename Tpointer>
bool valid(ptr_generator<Tgen, Tpointer> const& gen)
{
    return gen.valid();
}

template<typename Tgen, typename Tpointer>
bool count(ptr_generator<Tgen, Tpointer> const& gen)
{
    return gen.count();
}


template<typename Trange_,
         typename Titer_ = typename boost::range_iterator<Trange_>::type,
         typename Tresult_ = typename boost::iterator_reference<Titer_>::type,
         bool Bra_ =
            boost::is_convertible<
                typename boost::iterator_category_to_traversal<
                    typename boost::BOOST_ITERATOR_CATEGORY<Titer_>::type
                    >::type,
                boost::random_access_traversal_tag>::value>
class range_generator: public abstract_limited_generator<Tresult_>
{
    template<typename Trange, typename Titer, typename Tresult, bool Bra>
    friend bool valid(range_generator<Trange, Titer, Tresult, Bra> const& gen);
    template<typename Trange, typename Titer, typename Tresult, bool Bra>
    friend std::size_t count(range_generator<Trange, Titer, Tresult, Bra> const& gen);

public:
    typedef Titer_ range_iterator;
    typedef Tresult_ result_type;

public:
    template<typename Tanother_range_>
    range_generator(Tanother_range_ const& range)
        : i_(boost::begin(range)), end_(boost::end(range)),
          count_(::size(range)) {}

    template<typename Tanother_range_>
    range_generator(Tanother_range_& range)
        : i_(boost::begin(range)), end_(boost::end(range)),
          count_(::size(range)) {}

    range_generator(range_iterator const& begin, range_iterator const& end)
        : i_(begin), end_(end), count_(::size(std::make_pair(begin, end))) {}

    virtual ~range_generator() {}

    virtual result_type operator()()
    {
        --count_;
        return *i_++;
    }

    virtual std::size_t count() const
    {
        return count_;
    }

    virtual bool valid() const
    {
        return i_ != end_;
    }

private:
    range_iterator i_, end_;
    std::size_t count_;
};

template<typename Trange_, typename Titer_, typename Tresult_>
class range_generator<Trange_, Titer_, Tresult_, false>
    : public abstract_limited_generator<Tresult_>
{
    template<typename Trange, typename Titer, typename Tresult, bool Bra>
    friend bool valid(range_generator<Trange, Titer, Tresult, Bra> const& gen);
    template<typename Trange, typename Titer, typename Tresult, bool Bra>
    friend std::size_t count(range_generator<Trange, Titer, Tresult, Bra> const& gen);

public:
    typedef Titer_ range_iterator;
    typedef Tresult_ result_type;

public:
    template<typename Tanother_range_>
    range_generator(Tanother_range_ const& range)
        : i_(boost::begin(range)), end_(boost::end(range)) {}

    template<typename Tanother_range_>
    range_generator(Tanother_range_& range)
        : i_(boost::begin(range)), end_(boost::end(range)) {}

    range_generator(range_iterator const& begin, range_iterator const& end)
        : i_(begin), end_(end) {}

    template<typename Tanother_range_>
    range_generator(Tanother_range_ const& range, std::size_t count)
        : i_(boost::begin(range)), end_(boost::end(range)),
          count_(count) {}

    template<typename Tanother_range_>
    range_generator(Tanother_range_& range, std::size_t count)
        : i_(boost::begin(range)), end_(boost::end(range)),
          count_(count) {}

    range_generator(range_iterator const& begin, range_iterator const& end,
                    std::size_t count)
        : i_(begin), end_(end), count_(count) {}

    virtual ~range_generator() {}

    virtual result_type operator()()
    {
        if (count_.is_initialized())
        {
            --boost::get(count_);
        }
        return *i_++;
    }

    virtual std::size_t count() const
    {
        if (count_.is_initialized())
        {
            return boost::get(count_);
        }
        throw std::runtime_error("count not given through the constructor");
    }

    virtual bool valid() const
    {
        return i_ != end_;
    }

private:
    range_iterator i_, end_;
    boost::optional<std::size_t> count_;
};

template<bool, typename T_>
inline abstract_limited_generator<typename boost::iterator_reference<typename boost::range_iterator<T_>::type>::type >*
make_range_generator(T_& range)
{
    return new range_generator<T_, typename boost::range_iterator<T_>::type, typename boost::iterator_reference<typename boost::range_iterator<T_>::type>::type>(range);
}

template<typename Tresult_, typename T_>
inline abstract_limited_generator<Tresult_>*
make_range_generator(T_& range)
{
    return new range_generator<T_, typename boost::range_iterator<T_>::type, Tresult_>(range);
}

template<bool, typename T_>
inline abstract_limited_generator<typename boost::iterator_reference<typename boost::range_const_iterator<T_>::type>::type >*
make_range_generator(T_ const& range)
{
    return new range_generator<T_, typename boost::range_const_iterator<T_>::type, typename boost::iterator_reference<typename boost::range_const_iterator<T_>::type>::type>(range);
}

template<typename Tresult_, typename T_>
inline abstract_limited_generator<Tresult_>*
make_range_generator(T_ const& range)
{
    return new range_generator<T_, typename boost::range_const_iterator<T_>::type, Tresult_>(range);
}

template<typename Tgen_, typename Tfun_, typename Tpointer_ = Tgen_*>
struct transform_generator: public abstract_limited_generator<typename Tfun_::result_type>
{
    typedef Tgen_ generator_type;
    typedef Tpointer_ pointer_type;
    typedef typename boost::remove_reference<Tfun_>::type transformer_type;
    typedef typename transformer_type::result_type result_type;

    virtual ~transform_generator() {}

    virtual std::size_t count() const
    {
        return ::count(*gen_);
    }

    virtual bool valid() const
    {
        return ::valid(*gen_);
    }

    virtual result_type operator()()
    {
        return fun_((*gen_)());
    }

    transformer_type const& functor() const
    {
        return fun_;
    }
 
    transformer_type& functor()
    {
        return fun_;
    }

    transform_generator(Tgen_* gen,
                        typename boost::call_traits<Tfun_>::param_type fun)
        : gen_(gen), fun_(fun) {}

public:
    Tfun_ fun_;
    Tpointer_ gen_;
};

template<typename Tgen_, typename Tfun_>
inline transform_generator<Tgen_, Tfun_, boost::shared_ptr<Tgen_> >
make_transform_generator(Tgen_* gen, Tfun_ const& fun)
{
    return transform_generator<Tgen_, Tfun_, boost::shared_ptr<Tgen_> >(gen, fun);
}

template<typename Tgen1_, typename Tgen2_,
         bool Bvalid_ = boost::is_same<
            typename Tgen1_::result_type,
            typename Tgen2_::result_type>::value >
struct chained_generator
{
    struct two_generators_return_different_types;
    enum { _ = sizeof(two_generators_return_different_types) };
};

template<typename Tgen1_, typename Tgen2_>
struct chained_generator<Tgen1_, Tgen2_, true>
    : abstract_limited_generator<typename Tgen1_::result_type>
{
    typedef Tgen1_ first_generator_type;
    typedef Tgen2_ second_generator_type;
    typedef typename Tgen1_::result_type result_type;

    virtual ~chained_generator() {}

    chained_generator(Tgen1_& gen1, Tgen2_& gen2)
        : gen1_(gen1), gen2_(gen2) {}

    virtual std::size_t count() const
    {
        return ::count(gen1_) + ::count(gen2_);
    }

    virtual bool valid() const
    {
        return ::valid(gen1_) || ::valid(gen2_);
    }

    virtual result_type operator()()
    {
        if (::valid(gen1_))
            return gen1_();
        return gen2_();
    }

private:
    Tgen1_& gen1_;
    Tgen2_& gen2_;
};

template<typename Tgen1, typename Tgen2>
bool valid(chained_generator<Tgen1, Tgen2, true> const& gen)
{
    return gen.valid();
}

template<typename Tgen_, typename Tpointer_ = Tgen_*>
class generator_iterator:
    public boost::iterator_facade<
        generator_iterator<Tgen_, Tpointer_>,
        typename boost::remove_reference<typename Tgen_::result_type>::type,
        boost::single_pass_traversal_tag,
        typename Tgen_::result_type>
{
    typedef boost::iterator_facade<
        generator_iterator<Tgen_, Tpointer_>,
        typename boost::remove_reference<typename Tgen_::result_type>::type,
        boost::single_pass_traversal_tag,
        typename Tgen_::result_type> base_type;

public:
    typedef Tgen_ generator_type;
    typedef Tpointer_ pointer_type;
    typedef typename generator_type::result_type reference;

public:
    generator_iterator(): gen_(), advanced_(false) {}

    generator_iterator(Tpointer_ const& gen)
        : gen_(valid(*gen) ? gen: Tpointer_()),
          advanced_(false) {}

    void fetch()
    {
        if (gen_ && !advanced_)
        {
            if (valid(*gen_))
            {
                last_ = (*gen_)();
            }
            else
            {
                ::reset(gen_);
                last_.reset();
            }
            advanced_ = true;
        }
    }

    void increment()
    {
        fetch();
        advanced_ = false;
    }

    reference dereference() const
    {
        const_cast<generator_iterator*>(this)->fetch();
        return last_.get();
    }

    bool equal(generator_iterator const& rhs) const
    {
        const_cast<generator_iterator*>(this)->fetch();
        return (!gen_ && !rhs.gen_) || (gen_ && rhs.gen_ && *gen_ == *rhs.gen_);
    }

    typename base_type::difference_type distance_to(
            generator_iterator const& rhs) const
    {
        return (gen_ ? ::count(*gen_): 0) - (rhs.gen_ ? ::count(*rhs.gen_): 0);
    }

protected:
    Tpointer_ gen_;
    bool advanced_;
    boost::optional<reference> last_;
};

template<typename Tgen_, typename Tpointer_>
class generator_range
{
    template<typename T_> friend typename std::iterator_traits<T_>::difference_type std::distance(T_, T_);

public:
    typedef Tgen_ generator_type;
    typedef typename boost::remove_reference<typename generator_type::result_type>::type value_type;
    typedef typename generator_type::result_type reference;
    typedef const reference const_reference;

    typedef generator_iterator<Tgen_, Tpointer_> iterator;
    typedef iterator const_iterator;

public:
    iterator begin() const
    {
        return iterator(gen_);
    }

    iterator end() const
    {
        return iterator();
    }

    generator_range(Tpointer_ const& gen): gen_(gen) {}

private:
    Tpointer_ gen_;
};

template<typename Tgen, typename Tpointer>
inline generator_range<Tgen, Tpointer>
make_generator_range(Tpointer const& gen)
{
    return generator_range<Tgen, Tpointer>(gen);
}

#endif /* GENERATOR_HPP */
 </xmp> 
<h3> geometry.hpp </h3> <xmp>

#ifndef GEOMETRY_HPP
#define GEOMETRY_HPP

#include <boost/type_traits/is_arithmetic.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/mpl/and.hpp>
#include "linear_algebra.hpp"

template< typename T1_, typename T2_ >
inline typename element_type_of< T1_ >::type distance(
        T1_ const& p1, T2_ const p2,
        typename boost::enable_if<
            typename boost::mpl::and_<
                is_vector3<T1_>,
                is_vector3<T2_> > >::type* = 0)
{
    return std::sqrt(
        gsl_pow_2( p1[0] - p2[0] )
        + gsl_pow_2( p1[1] - p2[1] ) 
        + gsl_pow_2( p1[2] - p2[2] ) );
}

template<typename T_>
inline typename element_type_of<T_>::type distance(T_ const& p1, T_ const& p2)
{
    return distance(p1, p2, (void*)0);
}

template<typename T_>
inline T_ normalize(T_ const& p)
{
    return divide(p, length(p));
}

template<typename T_>
inline T_ normalize(T_ const& p, 
                     typename element_type_of< T_ >::type const& r)
{
    return multiply(p, r / length(p));
}


/**
 * Transpose the position pos1 so that it can be used with another 
 * position pos2.
 *
 * pos1 is transposed into one of mirror images of the cyclic boundary
 * condition so that the distance between pos1 and pos2 is smallest.
 *
 * Both of given pos1 and pos2 must be within the cyclic boundary.  However,
 * note that the returned transposed pos1 may not be within the cyclic boundary.
 */
template<typename T_>
inline T_ cyclic_transpose(T_ const& p0, T_ const& p1, T_ const& world_size, typename boost::enable_if<is_scalar<T_> >::type*)
{
    const T_ diff(p1 - p0), half(world_size / 2);
    if (diff > half)
    {
        return p0 + world_size;
    }
    else if (diff < -half)
    {
        return p0 - world_size;
    }
    else
    {
        return p0;
    }
}

template<typename T_>
inline T_ cyclic_transpose(T_ const& p0, T_ const& p1, typename element_type_of<T_>::type const& world_size, typename boost::enable_if<is_vector3<T_> >::type*)
{
    T_ retval;
    retval[0] = cyclic_transpose(p0[0], p1[0], world_size, (void*)0);
    retval[1] = cyclic_transpose(p0[1], p1[1], world_size, (void*)0);
    retval[2] = cyclic_transpose(p0[2], p1[2], world_size, (void*)0);
    return retval;
}

template<typename T1_, typename T2_>
inline T1_ cyclic_transpose(T1_ const& p0, T1_ const& p1, T2_ const& world_size)
{
    return cyclic_transpose(p0, p1, world_size, (void*)0);
}

template<typename T_>
inline T_ apply_boundary(T_ const& p1, T_ const& world_size, typename boost::enable_if<is_scalar<T_> >::type*)
{
    return modulo(p1, world_size);
}

template<typename T_>
inline T_ apply_boundary(T_ const& p1, 
                         typename element_type_of<T_>::type const& world_size,
                         typename boost::enable_if<is_vector3<T_> >::type*)
{
    return modulo(p1, world_size);
}

template<typename T1_, typename T2_>
inline T1_ apply_boundary(T1_ const& p1, T2_ const& world_size)
{
    return apply_boundary(p1, world_size, (void*)0);
}

template<typename T1_, typename T2_>
inline typename element_type_of<T1_>::type distance_cyclic(
        T1_ const& p1, T2_ const& p2,
        typename element_type_of<T1_>::type const& world_size,
        typename boost::enable_if<
            typename boost::mpl::and_<
                is_vector3<T1_>,
                is_vector3<T2_> > >::type* = 0)
{
    return distance(p1, cyclic_transpose(p2, p1, world_size));
}

template<typename T_>
inline typename element_type_of<T_>::type
distance_cyclic(T_ const& p1, T_ const& p2,
                typename element_type_of<T_>::type const& world_size)
{
    return distance_cyclic(p1, p2, world_size, (void*)0);
}

template<typename T>
inline T spherical_to_cartesian(T const& s)
{
    typename element_type_of<T>::type const sintheta(std::sin(s[1]));
    T retval;
    retval[0] = s[0] * std::cos(s[2]) * sintheta;
    retval[1] = s[0] * std::sin(s[2]) * sintheta;
    retval[2] = s[0] * std::cos(s[1]);
    return retval;
}

template<typename T1, typename T2>
inline T1 rotate_vector(T1 const& v, T2 const& axis, double angle)
{
    double const c(std::cos(angle)), s(std::sin(angle)), cc(1. - c);
    double const mat[3][3] = {
        {
            c + cc * axis[0] * axis[0],
            cc * axis[0] * axis[1] - axis[2] * s,
            cc * axis[0] * axis[2] + axis[1] * s
        },
        {
            cc * axis[0] * axis[1] + axis[2] * s,
            c + cc * axis[1] * axis[1],
            cc * axis[1] * axis[2] - axis[0] * s
        },
        {
            cc * axis[0] * axis[2] - axis[1] * s,
            cc * axis[1] * axis[2] + axis[0] * s,
            c + cc * axis[2] * axis[2]
        }
    };

    return multiply(mat, v);
}

#endif /* GEOMETRY_HPP */
 </xmp> 
<h3> GreensFunction1DAbsAbs.hpp </h3> <xmp>

#if !defined( __FIRSTPASSAGEGREENSFUNCTION1D_HPP )
#define __FIRSTPASSAGEGREENSFUNCTION1D_HPP

#include <sstream>
#include <iostream>
#include <cstdlib>
#include <exception>
#include <vector>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_trig.h>
#include <gsl/gsl_sum.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_roots.h>

#include <math.h>

#include "findRoot.hpp"
#include "Defs.hpp"
#include "OldDefs.hpp"			// TODO: this must be removed at some point!

#include "GreensFunction.hpp"
#include "PairGreensFunction.hpp"	// needed to declare EventType


class GreensFunction1DAbsAbs: public GreensFunction
{
private:
    // This is a typical length scale of the system, may not be true!
    static const Real L_TYPICAL = 1E-8;
    // The typical timescale of the system, may also not be true!!
    static const Real T_TYPICAL = 1E-6;
    // measure of 'sameness' when comparing floating points numbers
    static const Real EPSILON = 1E-12;
    //E3; Is 1E3 a good measure for the probability density?!
    static const Real PDENS_TYPICAL = 1;
    // The maximum number of terms in the sum
    static const int MAX_TERMS = 500;
    // The minimum
    static const int MIN_TERMS = 20;

public:
    enum EventKind
    {
        IV_ESCAPE,
        IV_REACTION
    };

public:
    GreensFunction1DAbsAbs(Real D, Real r0, Real sigma, Real a)
	: GreensFunction(D), v(0.0), sigma(sigma), a(a), r0(r0), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
    {
	;   // do nothing
    }

    // The constructor is overloaded and can be called with or without drift v
    GreensFunction1DAbsAbs(Real D, Real v, Real r0, Real sigma, Real a) // copy constructor including drift variable v
	: GreensFunction(D), v(v), sigma(sigma), a(a), r0(r0), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
    {
	;   // do nothing
    }

    ~GreensFunction1DAbsAbs()
    { 
	;   // empty
    }

    // This also sets the scale
    void seta(Real a)
    {
	Real L( a - this->sigma );
	
	THROW_UNLESS( std::invalid_argument, L >= 0.0 && (this->r0 - sigma) <= L);

	// Use a typical domain size to determine if we are here
	// defining a domain of size 0.
	if ( L <= EPSILON * l_scale )
	{
	    // just some random value to show that the domain is zero
	    this->a = -INT_MAX;
	}
	else
	{   
	    // set the typical time scale (msd = sqrt(2*d*D*t) )
	    // this is needed by drawTime_f, do not get rid of it!
	    this->t_scale = (L*L)/this->getD();
	    // set a
	    this->a = a;
	}
    }

    Real getsigma() const
    {
	return this->sigma;
    }
 
    Real geta() const
    {
	return this->a;
    }

    Real getv() const
    {
	return this->v;
    }

    void setr0(Real r0)
    {
	if ( this->a - this->sigma < 0.0 )
	{
	    // if the domain had zero size    
	    THROW_UNLESS( std::invalid_argument,
	                  0.0 <= (r0-sigma) && (r0-sigma) <= EPSILON * l_scale );
	    this->r0 = 0.0;
	}
	else
	{
	    // The normal case
	    THROW_UNLESS( std::invalid_argument,
	                  0.0 <= (r0-sigma) && r0 <= this->a);
	    this->r0 = r0;
	}
    }

    Real getr0() const
    {
	return this->r0;
    }

    // Draws the first passage time from the propensity function
    Real drawTime (Real rnd) const;

    // Draws the position of the particle at a given time, assuming that 
    // the particle is still in the
    // domain
    Real drawR (Real rnd, Real t) const;

    // Calculates the amount of flux leaving the left boundary at time t
    Real leaves(Real t) const;

    // Calculates the amount of flux leaving the right boundary at time t
    Real leavea(Real t) const;

    // Determines based on the flux ratios if the particle left the left 
    // or right boundary
    EventKind drawEventType( Real rnd, Real t ) const;

    // Calculates the probability of finding the particle inside the 
    // domain at time t so, the survival probability
    Real p_survival (Real t) const;

    // Calculates the probability density of finding the particle at 
    // location z at timepoint t, given that the particle is still in the 
    // domain.
    Real calcpcum (Real r, Real t) const;
    
    // Calculates the probability density of finding the particle at 
    // location r at time t.
    Real prob_r (Real r, Real t) const;

    std::string dump() const;

private:
    struct drawT_params
    {
	// use 10 terms in the summation for now
	double exponent[MAX_TERMS];
	double Xn[MAX_TERMS];
	double prefactor;
	int    terms;
	Real tscale;
	// random number
	double rnd;
    };

    static double drawT_f (double t, void *p);

    struct drawR_params
    {
	double S_Cn_An[MAX_TERMS];
	double n_L[MAX_TERMS];
	// variables H: for additional terms appearing as multiplicative factors etc.
	double H[5];
	int terms;
	// random number
	double rnd;
    };

    static double drawR_f (double z, void *p);

private:
    // The diffusion constant and drift velocity
    Real v;
    // These are the dimensions of our domain; L is calculated as a-sigma
    Real sigma;
    Real a;
    Real r0;
    // This is the 'length scale' of your system (1e-14 or 1e6)
    // Although rescaling is discontinued, we use it to check whether a is well-chosen
    Real l_scale;
    // This is the time scale of the system, used by drawTime_f
    Real t_scale;
};
#endif // __FIRSTPASSAGEGREENSFUNCTION1D_HPP
 </xmp> 
<h3> GreensFunction1DRadAbs.hpp </h3> <xmp>

#if !defined( __FIRSTPASSAGEGREENSFUNCTION1DRAD_HPP )
#define __FIRSTPASSAGEGREENSFUNCTION1DRAD_HPP

#include <sstream>
#include <iostream>
#include <cstdlib>
#include <exception>
#include <vector>

#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_trig.h>
#include <gsl/gsl_sum.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_sf_elljac.h>
#include <gsl/gsl_roots.h>

#include <math.h>

#include "findRoot.hpp"
#include "Defs.hpp"
#include "OldDefs.hpp"			// TODO: this must be removed at some point!
#include "GreensFunction.hpp"

class GreensFunction1DRadAbs: public GreensFunction
{
private:
    // This is a typical length scale of the system, may not be true!
    static const Real L_TYPICAL = 1E-8;
    // The typical timescale of the system, may also not be true!!
    static const Real T_TYPICAL = 1E-6;
    // measure of 'sameness' when comparing floating points numbers
    static const Real EPSILON = 1E-10;
    // Is 1E3 a good measure for the probability density?!
    static const Real PDENS_TYPICAL = 1;
    // The maximum number of terms used in calculating the sum
    static const int MAX_TERMS = 500;
    // The minimum number of terms
    static const int MIN_TERMS = 20;

public:
    GreensFunction1DRadAbs(Real D, Real k, Real r0, Real sigma, Real a)
	: GreensFunction(D), v(0.0), k(k), r0(r0), sigma(sigma), a(a), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
    {
	// do nothing
    }

    // The constructor is overloaded and can be called with or without drift v
    // copy constructor including drift variable v
    GreensFunction1DRadAbs(Real D, Real k, Real v, Real r0, Real sigma, Real a)
	: GreensFunction(D), v(v), k(k), r0(r0), sigma(sigma), a(a), l_scale(L_TYPICAL), t_scale(T_TYPICAL)
    {
	// do nothing
    }

    ~GreensFunction1DRadAbs()
    {
	;   // empty
    }

    // This also sets the scale
    void seta(Real a)
    {
	THROW_UNLESS( std::invalid_argument, (a-this->sigma) >= 0.0 && this->r0 <= a);

	// Use a typical domain size to determine if we are here 
	// defining a domain of size 0.
	if ( (a-this->sigma) < EPSILON*this->l_scale )
	{
	    // just some random value to show that the domain is zero
	    this->a = -1.0;
	}
	else
	{
	    // set the l_scale to the given one
	    this->l_scale = a-sigma;
	    // set the typical time scale (MSD = sqrt(2*d*D*t) )
	    this->t_scale = (l_scale*l_scale)/this->getD();
	    this->a = a;
	}
    }

    Real geta() const
    {
	return this->a;
    }
    
    Real getsigma() const
    {
	return this->sigma;
    }

    void setr0(Real r0)
    {
	if ( this->a - this->sigma < 0.0 )
	{
	    // if the domain had zero size
	    THROW_UNLESS( std::invalid_argument,
	                  0.0 <= (r0-sigma) && (r0-sigma) <= EPSILON * l_scale );
	    this->r0 = 0.0;
	}
	else
	{
	    // The normal case
	    THROW_UNLESS( std::invalid_argument,
	                  0.0 <= (r0-sigma) && r0 <= this->a);
	    this->r0 = r0;
	}
    }

    Real getr0() const
    {
	return r0;
    }

    Real getk() const
    {
	return this->k;
    }

    Real getv() const
    {
	return this->v;
    }

    // Calculates the probability density of finding the particle at 
    // location z at timepoint t, given that the particle is still in the 
    // domain.
    Real calcpcum (Real r, Real t) const;

    // Determine which event has occured, an escape or a reaction. Based 
    // on the fluxes through the boundaries at the given time. Beware: if 
    // t is not a first passage time you still get an answer!
    EventKind drawEventType( Real rnd, Real t ) const;

    // Draws the first passage time from the propensity function
    Real drawTime (Real rnd) const;

    // Draws the position of the particle at a given time, assuming that 
    // the particle is still in the domain
    Real drawR (Real rnd, Real t) const;


// These methods are both public and private, they are used by public methods 
// but can also be called from the 'outside'. This is mainly because of 
// debugging purposes.


    // Calculates the probability of finding the particle inside the 
    // domain at time t -> the survival probability
    Real p_survival (Real t) const;

    // Calculates the total probability flux leaving the domain at time t
    Real flux_tot (Real t) const;

    // Calculates the probability flux leaving the domain through the 
    // radiative boundary at time t
    Real flux_rad (Real t) const;

    // Calculates the flux leaving the domain through the radiative 
    // boundary as a fraction of the total flux. This is the probability 
    // that the particle left the domain through the radiative
    // boundary instead of the absorbing boundary.
    Real fluxRatioRadTot (Real t) const;

    // Calculates the probability density of finding the particle at 
    // location r at time t.
    Real prob_r (Real r, Real t) const;
    
// End of public/private mix methods

//private:	// method made public for testing

    std::string dump() const;

    // Calculates the roots of tan(a*x)=-xk/h
    Real root_n(int n) const;
    
private:

    Real An (Real a_n) const;

    Real Bn (Real a_n) const;

    Real Cn (Real a_n, Real t) const;

    struct tan_f_params
    {
	Real a;
	Real h;
    };

    static double tan_f (double x, void *p);
    // this is the appropriate definition of the function in gsl

    struct drawT_params
    {
	double exponent[MAX_TERMS];
	double Xn[MAX_TERMS];
	double prefactor;
	int    terms;
	// the timescale used for convergence
	Real   tscale;
	// the random number associated with the time
	double rnd;
    };

    static double drawT_f (double t, void *p);

    struct drawR_params
    {
	double root_n[MAX_TERMS];
	double S_Cn_root_n[MAX_TERMS];
	// variables H: for additional terms appearing as multiplicative factors etc.
	double H[5];
	int terms;
	// the random number associated with the time
	double rnd;
    };

    static double drawR_f (double z, void *p);

    // The diffusion constant and drift velocity
    Real v;
    // The reaction constant
    Real k;
    Real r0;
    // The left and right boundary of the domain (sets the l_scale, see below)
    Real sigma;
    Real a;
    // This is the length scale of the system
    Real l_scale;
    // This is the time scale of the system.
    Real t_scale;
};
#endif // __FIRSTPASSAGEGREENSFUNCTION1DRAD_HPP
 </xmp> 
<h3> GreensFunction3DAbs.hpp </h3> <xmp>

#if !defined( __FIRSTPASSAGENOCOLLISIONPAIRGREENSFUNCTION )
#define __FIRSTPASSAGENOCOLLISIONPAIRGREENSFUNCTION 

#include <vector>
#include <boost/tuple/tuple.hpp>
#include <boost/function.hpp>
#include <boost/array.hpp>

#include <gsl/gsl_roots.h>

#include "Logger.hpp"
#include "GreensFunction3DRadAbsBase.hpp"

class GreensFunction3DAbs: public GreensFunction3DRadAbsBase
{
public:
    typedef std::vector<Real> RealVector;

private:
    // Error tolerance used by default.
    static const Real TOLERANCE = 1e-8;

    // SphericalBesselGenerator's accuracy, used by some
    // theta-related calculations.
    static const Real THETA_TOLERANCE = 1e-5;

    static const Real MIN_T = 1e-18;

    static const unsigned int MAX_ORDER = 50;
    static const unsigned int MAX_ALPHA_SEQ = 1005;


public:
    
    GreensFunction3DAbs(Real D, Real r0, Real a); 
    
    virtual ~GreensFunction3DAbs();

    Real geta() const
    {
        return this->a;
    }

    virtual Real drawTime(Real rnd) const;

    virtual EventKind drawEventType(Real rnd, Real t) const;
    
    virtual Real drawR(Real rnd, Real t) const;
    
    virtual Real drawTheta(Real rnd, Real r, Real t) const;
    
    Real p_survival(Real t) const;

    Real dp_survival(Real t) const;

    Real p_int_r(Real r, Real t) const;

    Real p_theta(Real theta, Real r, Real t) const;

    Real ip_theta(Real theta, Real r, Real t) const;

    Real dp_theta(Real theta, Real r, Real t) const;

    Real idp_theta(Real theta, Real r, Real t) const;


    Real p_n(Integer n, Real r, Real t) const;

    Real dp_n(Integer n, Real t ) const;


    Real p_n_alpha(unsigned int i, unsigned int n, Real r, Real t ) const;

    Real dp_n_alpha(unsigned int i, unsigned int n, Real t) const;

    // methods below are kept public for debugging purpose.

    std::string dump() const;

protected:

    Real p_theta_table(Real theta, Real r, Real t, 
                       RealVector const& p_nTable ) const;

    Real ip_theta_table(Real theta, Real r, Real t,
                        RealVector const& p_nTable ) const;

    void makep_nTable(RealVector& p_nTable, Real r, Real t) const;
    
    void makedp_nTable(RealVector& p_nTable, Real t) const;

    struct ip_theta_params;
    static Real ip_theta_F(Real theta, ip_theta_params const* params);

private:
    
    mutable boost::array<Integer,MAX_ORDER+1> alphaOffsetTable;
    mutable boost::array<RealVector,MAX_ORDER+1> alphaTable;
    //mutable std::vector<RealVector> alphaTable;

    Real a;

    static Logger& log_;
};

#endif // __FIRSTPASSAGEPAIRGREENSFUNCTION 
 </xmp> 
<h3> GreensFunction3DAbsSym.hpp </h3> <xmp>

#if !defined( __FIRSTPASSAGEGREENSFUNCTION_HPP)
#define __FIRSTPASSAGEGREENSFUNCTION_HPP

#include "Defs.hpp"
#include "Logger.hpp"
#include "GreensFunction.hpp"
#include <ostream>

class GreensFunction3DAbsSym: public GreensFunction
{
public:
    GreensFunction3DAbsSym(Real D, Real a)
        : GreensFunction(D), a(a) {}

    ~GreensFunction3DAbsSym() {}

    Real getD() const
    {
        return this->D;
    }

    Real geta() const
    {
        return this->a;
    }

    Real p_survival(Real t) const; 

    Real drawTime(Real rnd) const;

    Real drawR(Real rnd, Real t) const;

    Real p_int_r(Real r, Real t) const;
    Real p_int_r_free(Real r, Real t) const;

    Real p_r_fourier(Real r, Real t) const;

private:
    static Real ellipticTheta4Zero(Real q);

private:

    static const Real CUTOFF = 1e-10;

    // H = 4.0: ~3e-5, 4.26: ~1e-6, 5.0: ~3e-7, 5.2: ~1e-7,
    // 5.6: ~1e-8, 6.0: ~1e-9
    static const Real CUTOFF_H = 6.0;

    const Real a;

    static Logger& log_;
};

template<typename Tstrm, typename Ttraits>
inline std::basic_ostream<Tstrm, Ttraits>&
operator <<(std::basic_ostream<Tstrm, Ttraits>& strm,
            GreensFunction3DAbsSym const& gf)
{
    strm << "GreensFunction3DAbsSym("
         << "D=" << gf.getD() << ", "
         << "a=" << gf.geta() << ")";
    return strm;
}

#endif // __PAIRGREENSFUNCTION_HPP
 </xmp> 
<h3> GreensFunction3D.hpp </h3> <xmp>

#if !defined( __FREEPAIRGREENSFUNCTION )
#define __FREEPAIRGREENSFUNCTION 

#include "compat.h"

#include <gsl/gsl_integration.h>

#include "Logger.hpp"
#include "PairGreensFunction.hpp"

/**
   Pair Green's function for the case where the pair never interact.

   Therefore, drawTime() always returns +INFINITY.
   kf == sigma == 0.
*/

class GreensFunction3D: public PairGreensFunction
{
    
private:

    static const Real TOLERANCE = 1e-8;

    static const Real H = 7;
    
public:
    
    GreensFunction3D(Real D, Real r0)
        : PairGreensFunction(D, 0.0, r0, 0.0)
    {
        ; // do nothing
    }
    
    
    virtual ~GreensFunction3D();
    
    virtual Real drawTime(Real rnd) const;

    Real drawR(Real rnd, Real t) const;
    
    Real drawTheta(Real rnd, Real r, Real t) const;

    Real p_r(Real r, Real t) const;

    Real ip_r(Real r, Real t ) const;
    

    Real p_theta(Real theta, Real r, Real t) const;

    Real ip_theta(Real theta, Real r, Real t ) const;

    std::string dump() const;

private:
    static Logger& log_;
};


#endif // __PLAINPAIRGREENSFUNCTION 
 </xmp> 
<h3> GreensFunction3DRadAbsBase.hpp </h3> <xmp>

#ifndef FIRST_PASSAGE_PAIR_GREENS_FUNCTION_BASE_HPP
#define FIRST_PASSAGE_PAIR_GREENS_FUNCTION_BASE_HPP

#include "PairGreensFunction.hpp"

class GreensFunction3DRadAbsBase: public PairGreensFunction
{
public:
    GreensFunction3DRadAbsBase(Real D, Real kf, Real r0, Real Sigma)
        : PairGreensFunction(D, kf, r0, Sigma) {}

    virtual ~GreensFunction3DRadAbsBase();

    virtual Real drawTime(Real rnd) const = 0;

    virtual EventKind drawEventType(Real rnd, Real t) const = 0;
    
    virtual Real drawR(Real rnd, Real t) const = 0;
    
    virtual Real drawTheta(Real rnd, Real r, Real t) const = 0;
}; 

#endif /* FIRST_PASSAGE_PAIR_GREENS_FUNCTION_BASE_HPP */
 </xmp> 
<h3> GreensFunction3DRadAbs.hpp </h3> <xmp>

#if !defined( __FIRSTPASSAGEPAIRGREENSFUNCTION_HPP )
#define __FIRSTPASSAGEPAIRGREENSFUNCTION_HPP 

#include <vector>
#include <boost/tuple/tuple.hpp>
#include <boost/function.hpp>
#include <boost/array.hpp>

#include <gsl/gsl_roots.h>

#include "Logger.hpp"

#include "GreensFunction3DRadAbsBase.hpp"

class GreensFunction3DRadAbs: public GreensFunction3DRadAbsBase
{
public:
    typedef std::vector<Real> RealVector;

private:
    // Error tolerance used by default.
    static const Real TOLERANCE = 1e-8;

    // SphericalBesselGenerator's accuracy, used by some
    // theta-related calculations.
    static const Real THETA_TOLERANCE = 1e-5;

    static const Real MIN_T_FACTOR = 1e-8;

    static const unsigned int MAX_ORDER = 50;
    static const unsigned int MAX_ALPHA_SEQ = 2000;


public:
    
    GreensFunction3DRadAbs(Real D, Real kf, Real r0, Real Sigma, Real a);
    
    virtual ~GreensFunction3DRadAbs();

    Real geth() const
    {
        return this->h;
    }

    Real geta() const
    {
        return this->a;
    }
    
    virtual Real drawTime(Real rnd) const;

    std::pair<Real, EventKind> 
    drawTime2(Real rnd1, Real rnd2) const;

    virtual EventKind drawEventType(Real rnd, Real t) const;

    virtual Real drawR(Real rnd, Real t) const;
    
    virtual Real drawTheta(Real rnd, Real r, Real t) const;
    
    Real f_alpha0(Real alpha) const;
    Real f_alpha0_aux(Real alpha) const;
  
    Real f_alpha(Real alpha, Integer n) const;
    Real f_alpha_aux(Real alpha, Integer n) const;

    Real p_0(Real t, Real r) const;
    
    Real p_survival(Real t) const;

    Real p_survival_table(Real t, RealVector& table) const;

    Real p_leave_table(Real t, RealVector const& table) const;


    Real dp_survival(Real t) const;

    Real leaves(Real t) const;

    Real leavea(Real t) const;

    Real p_leaves(Real t) const;

    Real p_leavea(Real t) const;

    Real p_int_r(Real r, Real t) const;

    Real p_theta(Real theta, Real r, Real t) const;

    Real ip_theta(Real theta, Real r, Real t) const;

    Real dp_theta(Real theta, Real r, Real t) const;

    Real idp_theta(Real theta, Real r, Real t) const;

    Real p_n(Integer n, Real r, Real t, Real max_alpha) const;

    Real dp_n_at_a(Integer n, Real t, Real max_alpha) const;


    Real p_n_alpha(unsigned int i, unsigned int n, Real r, Real t) const;

    Real dp_n_alpha_at_a(unsigned int i, unsigned int n, Real t) const;

    // methods below are kept public for debugging purpose.

    std::string dump() const;

    unsigned int alphaOffset(unsigned int n) const;

    Real alpha0_i(Integer i) const;

    Real alpha_i(Integer i, Integer n, gsl_root_fsolver* solver ) const;

    Real p_survival_i(Real alpha) const;

    Real p_0_i(Real alpha, Real r) const;

    Real dp_survival_i(Real alpha) const;

    Real leavea_i(Real alpha) const;

    Real leaves_i(Real alpha) const;

    Real p_leavea_i(Real alpha, Real pleave_factor) const;

    Real p_leaves_i(Real alpha, Real pleave_factor) const;

    Real p_survival_den(Real alpha) const;

    Real p_int_r_i(Real r, Real alpha, Real num_r0) const;

    Real p_0_i_exp(unsigned int i, Real t, Real r) const;

    Real p_survival_i_exp(unsigned int i, Real t) const;

    Real p_survival_i_alpha(Real alpha, Real t) const;


    Real p_survival_2i_exp(unsigned int i, Real t) const;


protected:

    void clearAlphaTable() const;

    RealVector& getAlphaTable(size_t n) const
    {
        return this->alphaTable[n];
    }

    Real getAlpha(size_t n, RealVector::size_type i) const
    {
        RealVector& alphaTable( this->alphaTable[n] );
        RealVector::size_type oldSize( alphaTable.size() );

        if( oldSize <= i )
        {
            alphaTable.resize( i+1 );
            unsigned int offset( alphaOffset( n ) );

            gsl_root_fsolver* solver(
                gsl_root_fsolver_alloc(gsl_root_fsolver_brent));

            for( RealVector::size_type m( oldSize ); m <= i; ++m )
            {
                alphaTable[m] = alpha_i( m + offset, n, solver );
            }

            gsl_root_fsolver_free( solver );
        }

        return alphaTable[i];

    }

    Real getAlpha0(RealVector::size_type i) const
    {
        RealVector& alphaTable( this->alphaTable[0] );
        
        RealVector::size_type oldSize( alphaTable.size() );

        if( oldSize <= i )
        {
            alphaTable.resize( i+1 );

            for( RealVector::size_type m( oldSize ); m <= i; ++m )
            {
                alphaTable[m] = alpha0_i( m );
            }
        }

        return alphaTable[i];
    }


    Real p_int_r_table(Real r, Real t,
                       RealVector const& num_r0Table) const;

    Real ip_theta_table(Real theta, Real r, Real t,
                        RealVector const& p_nTable) const;

    Real dp_theta_at_a(Real theta, Real t ) const;


    Real p_theta_table(Real theta, Real r, Real t, 
                       RealVector const& p_nTable ) const;

    void make_p_thetaTable( RealVector& pTable, Real r, Real t,
                            unsigned int n, RealVector const& p_nTable ) const;

    Real p_survival_i_exp_table(unsigned int i, Real t,
                                RealVector const& table ) const;

    Real p_leave_i_exp_table(unsigned int i, Real t,
                             RealVector const& table ) const;


    Real dp_survival_i_exp(unsigned int i, Real alpha) const;

    Real leavea_i_exp(unsigned int i, Real alpha) const;

    Real leaves_i_exp(unsigned int i, Real alpha) const;

    Real p_leavea_i_exp(unsigned int i, Real alpha) const;

    Real p_leaves_i_exp(unsigned int i, Real alpha) const;

    Real p_int_r_i_exp(unsigned int i, Real t, Real r) const;

    Real p_int_r_i_exp_table(unsigned int i, Real t, Real r,
                             RealVector& num_r0Table ) const;

    void initializeAlphaTable(unsigned int n) const;
    void updateAlphaTable0(Real t) const;
    void updateAlphaTable(unsigned int n, Real t) const; 

    void createPsurvTable(RealVector& table) const; 
    void createNum_r0Table(RealVector& table) const;

    void createPleaveFactorTable(RealVector& table) const;
    void createPleavesTable(RealVector& table,
                            RealVector const& pleaveFactorTable) const;
    void createPleaveaTable(RealVector& table,
                            RealVector const& pleaveFactorTable) const;

    void makep_nTable(RealVector& p_nTable, Real r, Real t) const;
    
    void makedp_n_at_aTable(RealVector& p_nTable, Real t) const;

    unsigned int guess_maxi(Real t) const;

    Real 
    drawPleaves(gsl_function const& F,
                gsl_root_fsolver* solver,
                Real t_guess,
                RealVector& pleaveFactorTable,
                RealVector& pleavesTable) const;

    Real 
    drawPleavea(gsl_function const& F,
                gsl_root_fsolver* solver,
                Real t_guess,
                RealVector& pleaveFactorTable,
                RealVector& pleavesTable) const;

    
    Real num_r0(Real alpha) const;

    Real pleaveFactor(Real alpha) const;

    struct ip_theta_params;
    static Real ip_theta_F(Real, ip_theta_params const*);


private:
    
    const Real h;
    const Real hsigma_p_1;

    mutable boost::array<Integer, MAX_ORDER+1> alphaOffsetTable;
    mutable boost::array<RealVector, MAX_ORDER+1> alphaTable;

    const Real a;

    static Logger& log_;
};



#endif // __FIRSTPASSAGEPAIRGREENSFUNCTION_HPP
 </xmp> 
<h3> GreensFunction3DRadInf.hpp </h3> <xmp>

#if !defined(__PLAINPAIRGREENSFUNCTION)
#define __PLAINPAIRGREENSFUNCTION 

#include <cmath>
#include <vector>
#include <gsl/gsl_integration.h>

#include "Logger.hpp"
#include "PairGreensFunction.hpp"

class GreensFunction3DRadInf: public PairGreensFunction
{
public:
    typedef std::vector<Real> RealVector;

private:
    struct p_corr_R_params;
    struct p_theta_params;

private:
    // Error tolerance used by default.
    static const Real TOLERANCE = 1e-8;

    // SphericalBesselGenerator's accuracy, used by some
    // theta-related calculations.
    static const Real THETA_TOLERANCE = 1e-5;

    static const Real MIN_T = 1e-12;

    static const unsigned int MAX_ORDER = 70;

    static const Real H = 4.0;
    

    
public:
    
    GreensFunction3DRadInf(Real D, Real kf, Real r0, Real Sigma);

    virtual ~GreensFunction3DRadInf();
 
    virtual Real drawTime(Real rnd) const;
    
    virtual Real drawR(Real rnd, Real t) const;
    
    virtual Real drawTheta(Real rnd, Real r, Real t) const;
    
    Real getkD() const
    {
        return this->kD;
    }
    
    Real getalpha() const
    {
        return this->alpha;
    }
    
    Real p_reaction(Real t) const;
    Real p_survival(Real t) const;
    Real p_int_r(Real r, Real t) const;
    
    Real p_theta(Real theta, Real r, Real time) const;

    Real ip_theta(Real theta, Real r, Real time) const;

    Real p_free(Real theta, Real r, Real t) const;

    Real ip_free(Real theta, Real r, Real t) const;
    
    Real p_corr(Real theta, Real r, Real t) const;

    Real ip_corr(Real theta, Real r, Real t) const;

    std::string dump() const;

private:
    Real p_corr_R(Real alpha, unsigned int n, Real r, Real t) const;

    
    Real p_corr_n(unsigned int n, RealVector const& RnTable, RealVector const& lgndTable) const;

    Real ip_corr_n(unsigned int n, RealVector const& RnTable, RealVector const& lgndTable) const;

    Real p_corr_table(Real theta, Real r, Real t, RealVector const& RnTable) const;

    Real 
    ip_corr_table(Real theta, Real r, Real t, RealVector const& RnTable) const;
    
    Real p_theta_table(Real r, Real theta, Real time,
                       RealVector const& RnTable) const;

    Real ip_theta_table(Real r, Real theta, Real time,
                        RealVector const& RnTable) const;

    Real 
    p_corr_table(Real theta, Real r, Real t, RealVector const& RnTable);
    

    void makeRnTable(RealVector& RnTable, Real r, Real t) const;

    Real Rn(unsigned int order, Real r, Real t,
            gsl_integration_workspace* workspace, Real tol) const;

private:
    static Real p_corr_R_F(Real, p_corr_R_params*);
    static Real ip_theta_F(Real theta, p_theta_params* params);
    
private:
    const Real kD;
    const Real alpha;
   
    static Logger& log_;
};



#endif // __PLAINPAIRGREENSFUNCTION 
 </xmp> 
<h3> GreensFunction3DSym.hpp </h3> <xmp>

#if !defined( __FREEGREENSFUNCTION )
#define __FREEGREENSFUNCTION 

#include "compat.h"

#include <gsl/gsl_integration.h>

#include "Logger.hpp"
#include "GreensFunction.hpp"

/**
  Green's Function for a free diffusion particle.
*/

class GreensFunction3DSym
    :
    public GreensFunction
{
    
private:

    static const Real TOLERANCE = 1e-8;

    static const Real H = 6;
    
public:
    
    GreensFunction3DSym( const Real D )
        :
        GreensFunction( D )
    {
        ; // do nothing
    }
    
    
    ~GreensFunction3DSym()
    {
        ; // do nothing
    }

    Real drawTime( const Real ) const
    {
        return INFINITY;
    }
    
    Real drawR( const Real rnd, const Real t ) const;
    
    Real p_r( const Real r, const Real t ) const;

    Real ip_r( const Real r, const Real t ) const;
    

    std::string dump() const;

private:

    static Logger& log_;
};



#endif // __FREEGREENSFUNCTION 
 </xmp> 
<h3> GreensFunction.hpp </h3> <xmp>

#if !defined( __GREENSFUNCTION_HPP )
#define __GREENSFUNCTION_HPP

#include "Defs.hpp"

class GreensFunction
{
public:
    enum EventKind
    {
        IV_ESCAPE,
        IV_REACTION
    };

public:
    GreensFunction( const Real D )
      : D( D ) {}
  
    ~GreensFunction() {}
  
    Real getD() const
    {
        return this->D;
    }

protected:
    const Real D;
};

#endif // __GREENSFUNCTION_HPP
 </xmp> 
<h3> GSLRandomNumberGenerator.hpp </h3> <xmp>

#ifndef GSLRANDOMNUMBERGENERATOR_HPP
#define GSLRANDOMNUMBERGENERATOR_HPP

#include <boost/shared_ptr.hpp>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>

class GSLRandomNumberGenerator
{
public:
    typedef boost::shared_ptr<gsl_rng> rng_handle;

    double normal(double loc, double scale)
    {
        return gsl_ran_gaussian(rng_.get(), scale) + loc;
    }

    unsigned long int get_raw()
    {
        return gsl_rng_get(rng_.get());
    }

    double uniform(double min, double max)
    {
        return gsl_rng_uniform(rng_.get()) * (max - min) + min;
    }

    int uniform_int(int min, int max)
    {
        return gsl_rng_uniform_int(rng_.get(), max - min + 1) + min;
    }

    double operator()()
    {
        return gsl_rng_uniform(rng_.get());
    }

    void seed(unsigned long int val)
    {
        gsl_rng_set(rng_.get(), val);
    }

    GSLRandomNumberGenerator(rng_handle hdl): rng_(hdl)
    {
    }

    GSLRandomNumberGenerator(gsl_rng* rng = gsl_rng_alloc(gsl_rng_mt19937)): rng_(rng, &gsl_rng_free) {}

    rng_handle rng_;
};

#endif /* GSLRANDOMNUMBERGENERATOR_HPP */
 </xmp> 
<h3> gsl_rng_base.hpp </h3> <xmp>

#ifndef GSL_RNG_BASE_HPP
#define GSL_RNG_BASE_HPP

#include <gsl/gsl_rng.h>

template<typename Tderived_>
struct gsl_rng_base: public gsl_rng
{
    static double _get_double(void *state)
    {
        return reinterpret_cast<Tderived_*>(state)->get_double();
    }

    static unsigned long int _get(void *state)
    {
        return reinterpret_cast<Tderived_*>(state)->get();
    }

    static void _set(void *state, unsigned long int seed)
    {
        reinterpret_cast<Tderived_*>(state)->set(seed);
    }

    gsl_rng_base()
    {
        type = &rng_type;
        state = this;
    }

    static gsl_rng_type rng_type;
};

template<typename Tderived_>
gsl_rng_type gsl_rng_base<Tderived_>::rng_type = {
    Tderived_::name,
    Tderived_::max,
    Tderived_::min,
    sizeof(Tderived_),
    &gsl_rng_base::_set,
    &gsl_rng_base::_get,
    &gsl_rng_base::_get_double
};

#endif /* GSL_RNG_BASE_HPP */
 </xmp> 
<h3> HalfOrderBesselGenerator.hpp </h3> <xmp>

#ifndef __HALFORDERBESSEL_HPP
#define __HALFORDERBESSEL_HPP

#include <cmath>

#include <gsl/gsl_sf_bessel.h>



class HalfOrderBesselGenerator
{

public:

    HalfOrderBesselGenerator( const double x, const int nmin, const int nmax )
        :
        nmin( nmin ),
        x( x ),
        x_r( 1.0 / x ),
        factor( sqrt( ( x + x ) * M_1_PI ) ),
        factorp( sqrt( 1.0 / ( 2.0 * M_PI * x ) ) ),
        //    sjArray( nmax-nmin+2 ),
        //    syArray( nmax-nmin+2 ),
        sjArray( new double[nmax-nmin+2] ),
        syArray( new double[nmax-nmin+2] )
    {
        // nmax+1 order is needed to calculate derivatives.
        fillArrays( nmin, nmax+1 );
    }

    ~HalfOrderBesselGenerator()
    {
        delete[] syArray;
        delete[] sjArray;
    }

    const double j( const int order ) const
    {
        return sjArray[order-nmin] * factor;
    }

    const double y( const int order ) const
    {
        return syArray[order-nmin] * factor;
    }

    const double jp( const int order ) const
    {
        const int index( order-nmin );
        const double sj( sjArray[index] );
        const double sjp( ( order * x_r ) * sj - sjArray[index+1] );

        return sjp * factor + sj * factorp;
    }

    const double yp( const int order ) const
    {
        const int index( order-nmin );
        const double sy( syArray[index] );
        const double syp( ( order * x_r ) * sy - syArray[index+1] );

        return syp * factor + sy * factorp;
    }


    static const double j_0( const double x )
    {
        return std::sin( x ) / x;
    }
    
    static const double y_0( const double x )
    {
        return - std::cos( x ) / x;
    }


private:

    void fillArrays( const int nmin, const int nmax )
    {
        {
            double jp1( gsl_sf_bessel_jl( nmax+1, x ) );
            double j( gsl_sf_bessel_jl( nmax, x ) );

            sjArray[nmax-nmin] = j;

            for( int n( nmax ); n >= nmin+1; --n )
            {
                const double jm1( ( n + n + 1.0 ) * x_r * j - jp1 );

                sjArray[n-nmin-1] = jm1;
                jp1 = j;
                j = jm1;
            }
        }

        {
            double y( gsl_sf_bessel_yl( nmin+1, x ) );
            double ym1( gsl_sf_bessel_yl( nmin, x ) );
            syArray[0] = ym1;
            syArray[1] = y;


            for( int n( nmin+1 ); n < nmax; ++n )
            {
                const double yp1( ( n + n + 1.0 ) * x_r * y - ym1 );

                syArray[n-nmin+1] = yp1;
                ym1 = y;
                y = yp1;
            }
        }
    }


private:

    const int nmin;
    const double x;
    const double x_r;
    const double factor;
    const double factorp;

    //  DoubleVector sjArray;
    //  DoubleVector syArray;
    double* const sjArray;
    double* const syArray;


};



#endif /* __HALFORDERBESSEL_HPP */
 </xmp> 
<h3> Identifier.hpp </h3> <xmp>

#ifndef IDENTIFIER_HPP
#define IDENTIFIER_HPP

#include <utility>

struct DefaultLot
{
    DefaultLot& operator=(DefaultLot const&) {
        return *this;
    }

    operator bool() const { return false; }

    bool operator!() const { return true; }

    DefaultLot& operator++()
    {
        return *this;
    }

    DefaultLot operator++(int)
    {
        return DefaultLot();
    }

    DefaultLot& operator--()
    {
        return *this;
    }

    DefaultLot operator--(int)
    {
        return DefaultLot();
    }

    bool operator==(DefaultLot const& rhs) const
    {
        return true;
    }

    bool operator!=(DefaultLot const& rhs) const
    {
        return false;
    }

    bool operator<(DefaultLot const& rhs) const
    {
        return false;
    }

    bool operator>=(DefaultLot const& rhs) const
    {
        return false;
    }

    bool operator>(DefaultLot const& rhs) const
    {
        return false;
    }

    bool operator<=(DefaultLot const& rhs) const
    {
        return false;
    }
};

template<typename Tbase_, typename Tserial_, typename Tlot_ = DefaultLot>
struct Identifier
{
    typedef Tlot_ lot_type;
    typedef Tserial_ serial_type;
    typedef std::pair<lot_type, serial_type> value_type;

    Identifier(value_type const& value)
        : value_(value) {}

    Tbase_ lot_add(lot_type const& rhs) const
    {
        return value_type(value_.first + rhs, value_.second);
    }

    Tbase_ lot_subtract(lot_type const& rhs) const
    {
        return value_type(value_.first - rhs, value_.second);
    }

    Tbase_& lot_advance(lot_type const& rhs)
    {
        value_.first += rhs;
        return static_cast<Tbase_&>(*this);
    }

    Tbase_& lot_retrace(lot_type const& rhs)
    {
        value_.first -= rhs;
        return static_cast<Tbase_&>(*this);
    }

    Tbase_ serial_add(serial_type const& rhs) const
    {
        return value_type(value_.first, value_.second + rhs);
    }

    Tbase_ seral_subtract(serial_type const& rhs) const
    {
        return value_type(value_.first, value_.second - rhs);
    }

    Tbase_& serial_advance(serial_type const& rhs)
    {
        value_.second += rhs;
        return static_cast<Tbase_&>(*this);
    }

    Tbase_& serial_retrace(serial_type const& rhs)
    {
        value_.second -= rhs;
        return static_cast<Tbase_&>(*this);
    }

    Tbase_& operator=(Tbase_ const& rhs)
    {
        value_.first = rhs.value_.first;
        value_.second = rhs.value_.second;
    }

    operator bool() const
    {
        return value_.second != 0;
    }

    bool operator!() const
    {
        return value_.second == 0;
    }

    bool operator==(Tbase_ const& rhs) const
    {
        return value_.first == rhs.value_.first &&
                value_.second == rhs.value_.second;
    }

    bool operator!=(Tbase_ const& rhs) const
    {
        return value_.first != rhs.value_.first
                || value_.second != rhs.value_.second;
    }

    bool operator<(Tbase_ const& rhs) const
    {
        return value_.second < rhs.value_.second
            || (value_.second == rhs.value_.second &&
                value_.first < rhs.value_.first);
    }

    bool operator>=(Tbase_ const& rhs) const
    {
        return value_.second > rhs.value_.second
            || (value_.second == rhs.value_.second &&
                value_.first >= rhs.value_.first);
    }

    bool operator>(Tbase_ const& rhs) const
    {
        return value_.second > rhs.value_.second
            || (value_.second == rhs.value_.second &&
                value_.first > rhs.value_.first);
    }

    bool operator<=(Tbase_ const& rhs) const
    {
        return value_.second < rhs.value_.second
            || (value_.second == rhs.value_.second &&
                value_.first <= rhs.value_.first);
    }

    operator value_type() const
    {
        return value_;
    }

    value_type const& operator()() const
    {
        return value_;
    }

    lot_type& lot()
    {
        return value_.first;
    }

    lot_type const& lot() const
    {
        return value_.first;
    }

    serial_type& serial()
    {
        return value_.second;
    }

    serial_type const& serial() const
    {
        return value_.second;
    }

    value_type& operator()()
    {
        return value_;
    }

protected:
    value_type value_;
};

#endif /* IDENTIFIER_HPP */
 </xmp> 
<h3> linear_algebra.hpp </h3> <xmp>

#ifndef LINEAR_ALGEBRA_HPP
#define LINEAR_ALGEBRA_HPP

#include <algorithm>
#include <cmath>
#include <gsl/gsl_pow_int.h>
#include <boost/preprocessor/tuple/elem.hpp>
#include <boost/preprocessor/repetition/repeat.hpp>
#include <boost/preprocessor/repetition/enum_params.hpp>
#include <boost/preprocessor/repetition/enum_trailing_params.hpp>
#include <boost/mpl/bool.hpp>
#include <boost/mpl/and.hpp>
#include <boost/type_traits/is_arithmetic.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/array.hpp>
#include <boost/multi_array.hpp>

#include "utils/array_traits.hpp"

#define CREATE_VECTOR_LIMIT_REPEAT 16
#define POPULATE_MATRIX_BY_VECTORS_LIMIT_REPEAT 16

template<typename T_, std::size_t N_>
struct is_vector: public boost::mpl::false_ {};

template<typename T_, std::size_t N_>
struct is_vector<boost::array<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix: public boost::mpl::false_ {};

template<typename T_, std::size_t N_, typename Talloc_>
struct is_matrix<boost::multi_array<T_, N_, Talloc_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix<boost::detail::multi_array::sub_array<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix<boost::detail::multi_array::const_sub_array<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix<boost::detail::multi_array::multi_array_view<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix<boost::detail::multi_array::const_multi_array_view<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_>
struct is_matrix<boost::multi_array_ref<T_, N_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N_, typename Tptr_>
struct is_matrix<boost::const_multi_array_ref<T_, N_, Tptr_>, N_>: public boost::mpl::true_ {};

template<typename T_, std::size_t N1_, std::size_t N2_>
struct is_matrix<boost::array<boost::array<T_, N1_>, N2_>, 2>: public boost::mpl::true_ {};

template<typename T_, std::size_t N1_, std::size_t N2_>
struct is_matrix<T_[N1_][N2_], 2>: public boost::mpl::true_ {};

template<typename T_>
struct is_scalar: public boost::is_arithmetic<T_> {};

template<typename T_>
struct is_vector2: public is_vector<T_, 2> {};

template<typename T_>
struct is_vector3: public is_vector<T_, 3> {};

template<typename T_>
struct matrix_adapter
{
};

template<typename T_, std::size_t N_, typename Talloc_>
struct matrix_adapter<boost::multi_array<T_, N_, Talloc_> >
{
    typedef boost::multi_array<T_, N_, Talloc_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_>
struct matrix_adapter<boost::detail::multi_array::sub_array<T_, N_> >
{
    typedef boost::detail::multi_array::sub_array<T_, N_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_>
struct matrix_adapter<boost::detail::multi_array::const_sub_array<T_, N_> >
{
    typedef boost::detail::multi_array::const_sub_array<T_, N_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_>
struct matrix_adapter<boost::detail::multi_array::multi_array_view<T_, N_> >
{
    typedef boost::detail::multi_array::multi_array_view<T_, N_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_>
struct matrix_adapter<boost::detail::multi_array::const_multi_array_view<T_, N_> >
{
    typedef boost::detail::multi_array::const_multi_array_view<T_, N_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    matrix_size_type get_extent(matrix_type const& first,
                                std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_>
struct matrix_adapter<boost::multi_array_ref<T_, N_> >
{
    typedef boost::multi_array_ref<T_, N_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N_, typename Tptr_>
struct matrix_adapter<boost::const_multi_array_ref<T_, N_, Tptr_> >
{
    typedef boost::const_multi_array_ref<T_, N_, Tptr_> matrix_type;
    typedef typename matrix_type::size_type matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        return first.shape()[idx];
    }
};

template<typename T_, std::size_t N1_, std::size_t N2_>
struct matrix_adapter<T_[N1_][N2_]>
{
    typedef T_ matrix_type[N1_][N2_];
    typedef std::size_t matrix_size_type;

    static matrix_size_type get_extent(matrix_type const& first,
                                       std::size_t idx)
    {
        switch (idx)
        {
        case 0:
            return N1_;
        case 1:
            return N2_;
        default:
            throw std::out_of_range("index out of range");
        }
    }
};

template<typename Tmat>
inline std::size_t matrix_extent(Tmat const& mat, std::size_t dim)
{
    return matrix_adapter<Tmat>::get_extent(mat, dim);
}

template<typename T_>
inline T_ add( T_ const& p1, T_ const& p2, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return p1 + p2;
}

template<typename T_>
inline T_ subtract( T_ const& p1, T_ const& p2, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return p1 - p2;
}

template<typename T_>
inline T_ multiply( T_ const& p1, T_ const& p2, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return p1 * p2;
}

template<typename T_>
inline T_ divide( T_ const& p1, T_ const& p2, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return p1 / p2;
}

template<typename T_>
inline T_ modulo( T_ const& p1, T_ const& p2 )
{
    T_ r = p1 % p2;
    if (r != 0 && (r > 0) == (p2 < 0))
        r += p2;
    return r;
}

template<>
inline float modulo( float const& p1, float const& p2 )
{
    float r = std::fmod(p1, p2);
    if (r != 0 && (r > 0) == (p2 < 0))
        r += p2;
    return r;
}

template<>
inline double modulo( double const& p1, double const& p2 )
{
    double r = std::fmod(p1, p2);
    if (r != 0 && (r > 0) == (p2 < 0))
        r += p2;
    return r;
}

template<typename T_>
inline T_ negate(T_ const& v, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return -v;
}

template<typename T_>
inline T_ abs(T_ const& v, typename boost::enable_if<is_scalar<T_> >::type* = 0)
{
    return std::fabs(v);
}

template<typename T1_, typename T2_>
inline T1_ add(T1_ const& p1, T2_ const& p2, typename boost::enable_if<boost::mpl::and_<is_vector3<T1_>, is_vector3<T2_> > >::type* = 0)
{
    T1_ retval;
    retval[0] = add(p1[0], p2[0]);
    retval[1] = add(p1[1], p2[1]);
    retval[2] = add(p1[2], p2[2]);
    return retval;
}

template<typename T1_, typename T2_>
inline T1_ subtract(T1_ const& p1, T2_ const& p2, typename boost::enable_if<boost::mpl::and_<is_vector3<T1_>, is_vector3<T2_> > >::type* = 0)
{
    T1_ retval;
    retval[0] = subtract(p1[0], p2[0]);
    retval[1] = subtract(p1[1], p2[1]);
    retval[2] = subtract(p1[2], p2[2]);
    return retval;
}

template<typename T_>
inline T_ divide(T_ const& p1, typename element_type_of<T_>::type const& p2, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = divide(p1[0], p2);
    retval[1] = divide(p1[1], p2);
    retval[2] = divide(p1[2], p2);
    return retval;
}

template<typename T_>
inline T_ multiply(T_ const& p1, typename element_type_of<T_>::type const& p2, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = multiply(p1[0], p2);
    retval[1] = multiply(p1[1], p2);
    retval[2] = multiply(p1[2], p2);
    return retval;
}

template<typename T_, typename M_>
inline T_ multiply(T_ const& p1, M_ const& p2, typename boost::enable_if<
    boost::mpl::and_<is_vector3<T_>, is_matrix<M_, 2> > >::type* = 0)
{
    BOOST_ASSERT(matrix_extent(p2, 0) == 3 && matrix_extent(p2, 1) == 3);
    T_ retval;
    retval[0] = multiply(p1[0], p2[0][0])
                + multiply(p1[1], p2[1][0])
                + multiply(p1[2], p2[2][0]);
    retval[1] = multiply(p1[0], p2[0][1])
                + multiply(p1[1], p2[1][1])
                + multiply(p1[2], p2[2][1]);
    retval[2] = multiply(p1[0], p2[0][2])
                + multiply(p1[1], p2[1][2])
                + multiply(p1[2], p2[2][2]);
    return retval;
}

template<typename M_, typename T_>
inline T_ multiply(M_ const& p1, T_ const& p2, typename boost::enable_if<
    boost::mpl::and_<is_matrix<M_, 2>, is_vector3<T_> > >::type* = 0)
{
    BOOST_ASSERT(matrix_extent(p1, 0) == 3 && matrix_extent(p1, 1) == 3);
    T_ retval;
    retval[0] = multiply(p1[0][0], p2[0])
                + multiply(p1[0][1], p2[1])
                + multiply(p1[0][2], p2[2]);
    retval[1] = multiply(p1[1][0], p2[0])
                + multiply(p1[1][1], p2[1])
                + multiply(p1[1][2], p2[2]);
    retval[2] = multiply(p1[2][0], p2[0])
                + multiply(p1[2][1], p2[1])
                + multiply(p1[2][2], p2[2]);
    return retval;
}

template<typename T_>
inline T_ modulo(T_ const& p1, typename element_type_of<T_>::type const& p2, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = modulo(p1[0], p2);
    retval[1] = modulo(p1[1], p2);
    retval[2] = modulo(p1[2], p2);
    return retval;
}

template<typename T_>
inline T_ negate(T_ const& v, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = -v[0];
    retval[1] = -v[1];
    retval[2] = -v[2];
    return retval;
}

template<typename T_>
inline T_ abs(T_ const& v, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = abs(v[0]);
    retval[1] = abs(v[1]);
    retval[2] = abs(v[2]);
    return retval;
}

template<typename T_>
inline typename element_type_of<T_>::type dot_product(T_ const& p1, T_ const& p2, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    return multiply(p1[0], p2[0])
           + multiply(p1[1], p2[1])
           + multiply(p1[2], p2[2]);
}

template<typename T_>
inline T_ cross_product(T_ const& p1, T_ const& p2, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    T_ retval;
    retval[0] = subtract(multiply(p1[1], p2[2]), multiply(p1[2], p2[1]));
    retval[1] = subtract(multiply(p1[2], p2[0]), multiply(p1[0], p2[2]));
    retval[2] = subtract(multiply(p1[0], p2[1]), multiply(p1[1], p2[0]));
    return retval;
}

template<typename T_>
inline typename element_type_of<T_>::type length_sq(T_ const& r, typename boost::enable_if<is_vector2<T_> >::type* = 0)
{
    return gsl_pow_2(r[0]) + gsl_pow_2(r[1]);
}

template< typename T_ >
inline typename element_type_of< T_ >::type length_sq(T_ const& r, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    return gsl_pow_2(r[0]) + gsl_pow_2(r[1]) + gsl_pow_2(r[2]);
}

template< typename T_ >
inline typename element_type_of< T_ >::type length(T_ const& r)
{
    return std::sqrt(length_sq(r));
}

#define CREATE_VECTOR_INNER_TPL(__z__, __n__, __d__) \
    __d__[__n__] = BOOST_PP_CAT(p, __n__);

#define CREATE_VECTOR_TPL(__z__, __n__, __d__) \
template<typename T_> \
inline T_ create_vector(\
        BOOST_PP_ENUM_PARAMS(__n__, typename element_type_of<T_>::type const& p), \
        typename boost::enable_if<is_vector<T_, __n__> >::type* = 0) \
{ \
    T_ retval; \
    BOOST_PP_REPEAT_ ## __z__(__n__, CREATE_VECTOR_INNER_TPL, retval) \
    return retval; \
}

BOOST_PP_REPEAT_FROM_TO(2, CREATE_VECTOR_LIMIT_REPEAT, CREATE_VECTOR_TPL, )

#undef CREATE_VECTOR_TPL
#undef CREATE_VECTOR_INNER_TPL

template<typename T_>
inline bool is_cartesian_versor(T_ const& vector, typename boost::enable_if<is_vector3<T_> >::type* = 0)
{
    return (vector == create_vector<T_>(1, 0, 0) ||
            vector == create_vector<T_>(0, 1, 0) ||
            vector == create_vector<T_>(0, 0, 1) ||
            vector == create_vector<T_>(-1, 0, 0) ||
            vector == create_vector<T_>(0, -1, 0) ||
            vector == create_vector<T_>(0, 0, -1));
}

#endif /* LINEAR_ALGEBRA_HPP */
 </xmp> 
<h3> Logger.hpp </h3> <xmp>

#ifndef LOGGER_HPP
#define LOGGER_HPP

#include <cstdarg>
#include <set>
#include <vector>
#include <string>
#include <boost/noncopyable.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>

class LogAppender;
class LoggerManager;
class LoggerManagerRegistry;

class Logger: boost::noncopyable
{
public:
    enum level
    {
        L_OFF = 0,
        L_DEBUG = 1,
        L_INFO = 2,
        L_WARNING = 3,
        L_ERROR = 4,
        L_FATAL = 5
    };

public:
    ~Logger();

    LoggerManager const& logging_manager() const;

    void level(enum level level);

    enum level level() const;

    char const* name() const
    {
        return name_.c_str();
    }

    boost::shared_ptr<LoggerManager> manager() const;

    void debug(char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(L_DEBUG, format, ap);
        va_end(ap);
    }

    void info(char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(L_INFO, format, ap);
        va_end(ap);
    }

    void warn(char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(L_WARNING, format, ap);
        va_end(ap);
    }

    void error(char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(L_ERROR, format, ap);
        va_end(ap);
    }

    void fatal(char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(L_FATAL, format, ap);
        va_end(ap);
    }

    void log(enum level lv, char const* format, ...)
    {
        va_list ap;
        va_start(ap, format);
        logv(lv, format, ap);
        va_end(ap);
    }

    void logv(enum level lv, char const* format, va_list ap);

    void flush();

    Logger(LoggerManagerRegistry const& registry, char const* name);

    static Logger& get_logger(char const* name);

    static char const* stringize_error_level(enum level lv);

private:
    void ensure_initialized();

protected:
    LoggerManagerRegistry const& registry_; 
    std::string const name_;
    boost::shared_ptr<LoggerManager> manager_;
    enum level level_;
    std::vector<boost::shared_ptr<LogAppender> > appenders_;
};

class LoggerManager: boost::noncopyable
{
    friend class Logger;

public:
    void level(enum Logger::level level);

    enum Logger::level level() const;

    char const* name() const;

    std::vector<boost::shared_ptr<LogAppender> > const& appenders() const;

    void add_appender(boost::shared_ptr<LogAppender> const& appender);

    LoggerManager(char const* name, enum Logger::level level = Logger::L_INFO);

    static void register_logger_manager(char const* logger_name_pattern,
                                        boost::shared_ptr<LoggerManager> const& manager);

    static boost::shared_ptr<LoggerManager> get_logger_manager(char const* logger_name_patern);

protected:
    void manage(Logger* logger);

protected:
    std::string const name_;
    enum Logger::level level_;
    std::set<Logger*> managed_loggers_;
    std::vector<boost::shared_ptr<LogAppender> > appenders_;
};

class LogAppender
{
public:
    virtual ~LogAppender();

    virtual void flush() = 0;

    virtual void operator()(enum Logger::level lv,
                            boost::posix_time::ptime const& tm,
                            char const* name, char const** chunks) = 0;
};

#define LOG_DEBUG(args) if (log_.level() == Logger::L_DEBUG) log_.debug args

#define LOG_INFO(args) if (enum Logger::level const level = log_.level()) if (level <= Logger::L_INFO) log_.info args

#define LOG_WARNING(args) if (enum Logger::level const level = log_.level()) if (level <= Logger::L_WARNING) log_.warn args

#endif /* LOGGER_HPP */
 </xmp> 
<h3> MatrixSpace.hpp </h3> <xmp>

#ifndef MATRIX_SPACE_HPP
#define MATRIX_SPACE_HPP

#include <cstddef>
#include <algorithm>
#include <iterator>
#include <boost/multi_array.hpp>
#include <boost/mpl/if.hpp>
#include <boost/type_traits/is_const.hpp>
#include <boost/type_traits/add_const.hpp>
#include <boost/preprocessor/repetition/repeat.hpp>
#include <boost/preprocessor/list/at.hpp>
#include <boost/range/size.hpp>
#include <boost/range/difference_type.hpp>
#include "Vector3.hpp"
#include "utils/array_helper.hpp"
#include "utils/get_default_impl.hpp"
#include "utils/range.hpp"

template<typename Tobj_, typename Tkey_,
        template<typename, typename> class MFget_mapper_ =
            get_default_impl::std::template map>
class MatrixSpace
{
public:
    typedef typename Tobj_::length_type length_type;
    typedef Tkey_ key_type;
    typedef Tobj_ mapped_type;
    typedef std::pair<const key_type, mapped_type> value_type;
    typedef Vector3<length_type> position_type;
    typedef typename MFget_mapper_<Tkey_, mapped_type>::type cell_type;
    typedef boost::multi_array<cell_type, 3> matrix_type;
    typedef typename cell_type::size_type size_type;
    typedef boost::array<typename matrix_type::size_type, 3>
            cell_index_type;
    typedef boost::array<typename matrix_type::difference_type, 3>
            cell_offset_type;
    typedef typename cell_type::reference reference;
    typedef typename cell_type::const_reference const_reference;
    typedef typename MFget_mapper_<key_type, cell_type*>::type
            key_to_cell_mapper_type;

    template<typename Thost_, typename Treftype_, typename Tciter_>
    class iterator_base
    {
    private:
        struct reference_is_const:
            public boost::is_const<
                    typename boost::remove_reference<Treftype_>::type> {};
    public:
        typedef typename MatrixSpace::value_type value_type;
        typedef Treftype_ reference;
        typedef const Treftype_ const_reference;
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef typename Tciter_::difference_type difference_type;
        typedef typename boost::mpl::if_<reference_is_const,
                typename boost::add_const<value_type>::type,
                value_type>::type* pointer;

    protected:
        typedef typename boost::mpl::if_<reference_is_const,
                typename boost::add_const<cell_type>::type,
                cell_type>::type* cell_ptr_type;
        typedef std::pair<cell_ptr_type, cell_ptr_type> cell_range_type;

    public:
        bool operator==(const Thost_& rhs) const
        {
            return cell_p_ == rhs.cell_p_ &&
                cell_iter_ == rhs.cell_iter_;
        }

        bool operator!=(const Thost_& rhs) const
        {
            return !operator==(rhs);
        }

        const_reference operator*() const
        {
            return *cell_iter_;
        }

        reference operator*()
        {
            return *cell_iter_;
        }

        Thost_& operator++()
        {
            if (cell_iter_ != cell_p_->end())
            {
                ++cell_iter_;
            }

            while (cell_iter_ == cell_p_->end())
            {
                ++cell_p_;
                if (cell_p_ == cell_r_.second)
                {
                    --cell_p_;
                    cell_iter_ = cell_p_->end();
                    break;
                }
                cell_iter_ = cell_p_->begin();
            }
            return *static_cast<Thost_*>(this);
        }

        Thost_ operator++(int)
        {
            Thost_ retval(static_cast<Thost_ const&>(*this));
            operator++();
            return retval;
        }

        Thost_& operator--()
        {
            while (cell_iter_ == cell_p_->begin() && cell_p_ > cell_r_.first)
            {
                --cell_p_;
                cell_iter_ = cell_p_->end();
            }
            --cell_iter_;
            return *static_cast<Thost_*>(this);
        }

        Thost_ operator--(int)
        {
            Thost_ retval(static_cast<Thost_ const&>(*this));
            operator--();
            return retval;
        }

        Thost_& operator=(const Thost_& rhs)
        {
            cell_p_ = rhs.cell_p_;
            cell_iter_ = rhs.cell_iter_;
            return *static_cast<Thost_*>(this);
        }

        iterator_base(cell_ptr_type cell_p, cell_range_type const& cell_r,
                const Tciter_& cell_iter)
                : cell_p_(cell_p), cell_r_(cell_r), cell_iter_(cell_iter) {}

    public:
        cell_ptr_type cell_p_;
        cell_range_type cell_r_;
        Tciter_ cell_iter_;
    };

    class iterator: public iterator_base<iterator, reference,
            typename cell_type::iterator>
    {
    public:
        typedef iterator_base<iterator, reference,
                typename cell_type::iterator> base_type;

    public:
        iterator(typename base_type::cell_ptr_type cell_p,
                typename base_type::cell_range_type cell_r,
                const typename cell_type::iterator& cell_iter)
                : base_type(cell_p, cell_r, cell_iter) {}
    };

    class const_iterator: public iterator_base<const_iterator,
            const_reference, typename cell_type::const_iterator>
    {
    public:
        typedef iterator_base<const_iterator, const_reference,
                typename cell_type::const_iterator> base_type;

    public:
        const_iterator(typename base_type::cell_ptr_type cell_p,
                typename base_type::cell_range_type const& cell_r,
                const typename cell_type::const_iterator& cell_iter)
                : base_type(cell_p, cell_r, cell_iter) {}

        const_iterator(iterator const& that)
                : base_type(that.cell_p_, that.cell_r_, that.cell_iter_) {}
    };

public:
    MatrixSpace(length_type world_size = 1.0,
            typename matrix_type::size_type size = 1)
        : world_size_(world_size),
          cell_size_(world_size / size),
          matrix_(boost::extents[size][size][size]),
          size_(0)
    {
    }

    inline cell_index_type index(const position_type& pos,
            double t = 1e-10) const
    {
        return array_gen<typename matrix_type::size_type>(
            static_cast<typename matrix_type::size_type>(
                pos[0] / cell_size_ ) % matrix_.shape()[0],
            static_cast<typename matrix_type::size_type>(
                pos[1] / cell_size_ ) % matrix_.shape()[1],
            static_cast<typename matrix_type::size_type>(
                pos[2] / cell_size_ ) % matrix_.shape()[2] );
    }

    inline bool offset_index(
            cell_index_type& i,
            const cell_offset_type& o) const
    {
        if ((o[0] < 0 && static_cast<size_type>(-o[0]) > i[0])
                || (matrix_.shape()[0] - o[0] <= i[0])
                || (o[1] < 0 && static_cast<size_type>(-o[1]) > i[1])
                || (matrix_.shape()[1] - o[1] <= i[1])
                || (o[2] < 0 && static_cast<size_type>(-o[2]) > i[2])
                || (matrix_.shape()[2] - o[2] <= i[2]))
        {
            return false;
        }
        i[0] += o[0];
        i[1] += o[1];
        i[2] += o[2];
        return true;
    }

    inline position_type offset_index_cyclic(cell_index_type& i,
                                             const cell_offset_type& o) const
    {
        position_type retval;

        if (o[0] < 0 &&
            static_cast<typename matrix_type::size_type>(-o[0]) > i[0])
        {
            typename matrix_type::size_type t(
                (i[0] + matrix_.shape()[0] - (-o[0] % matrix_.shape()[0])) %
                matrix_.shape()[0]);
            retval[0] 
                = (o[0] - 
                   static_cast<typename matrix_type::difference_type>
                   (t - i[0])) * cell_size_;
            i[0] = t;
        }
        else if (matrix_.shape()[0] - o[0] <= i[0])
        {
            typename matrix_type::size_type t(
                    (i[0] + (o[0] % matrix_.shape()[0])) % matrix_.shape()[0]);
            retval[0] 
                = (o[0] - 
                   static_cast<typename matrix_type::difference_type>
                   (t - i[0])) * cell_size_;
            i[0] = t;
        }
        else
        {
            i[0] += o[0];
        }

        if (o[1] < 0 &&
                static_cast<typename matrix_type::size_type>(-o[1]) > i[1])
        {
            typename matrix_type::size_type t(
                    (i[1] + matrix_.shape()[1] - (-o[1] % matrix_.shape()[1])) %
                        matrix_.shape()[1]);
            retval[1] = (o[1] - static_cast<typename matrix_type::difference_type>(t - i[1])) * cell_size_;
            i[1] = t;
        }
        else if (matrix_.shape()[1] - o[1] <= i[1])
        {
            typename matrix_type::size_type t(
                    (i[1] + (o[1] % matrix_.shape()[1])) % matrix_.shape()[1]);
            retval[1] = (o[1] - static_cast<typename matrix_type::difference_type>(t - i[1])) * cell_size_;
            i[1] = t;
        }
        else
        {
            i[1] += o[1];
        }

        if (o[2] < 0 &&
                static_cast<typename matrix_type::size_type>(-o[2]) > i[2])
        {
            typename matrix_type::size_type t(
                    (i[2] + matrix_.shape()[2] - (-o[2] % matrix_.shape()[2])) %
                        matrix_.shape()[2]);
            retval[2] = (o[2] - static_cast<typename matrix_type::difference_type>(t - i[2])) * cell_size_;
            i[2] = t;
        }
        else if (matrix_.shape()[2] - o[2] <= i[2])
        {
            typename matrix_type::size_type t(
                    (i[2] + (o[2] % matrix_.shape()[2])) % matrix_.shape()[2]);
            retval[2] = (o[2] - static_cast<typename matrix_type::difference_type>(t - i[2])) * cell_size_;
            i[2] = t;
        }
        else
        {
            i[2] += o[2];
        }

        return retval;
    }

    inline const cell_type& cell(const cell_index_type& i) const
    {
        return matrix_[i[0]][i[1]][i[2]];
    }

    inline cell_type& cell(const cell_index_type& i)
    {
        return matrix_[i[0]][i[1]][i[2]];
    }

    inline length_type world_size() const
    {
        return world_size_;
    }

    inline length_type cell_size() const
    {
        return cell_size_;
    }

    inline typename matrix_type::size_type matrix_size() const
    {
        return matrix_.shape()[0];
    }

    inline size_type size() const
    {
        return size_;
    }

    inline iterator update(iterator const& i, const value_type& v)
    {
        cell_type& c(cell(index(v.second.position())));
        std::pair<typename cell_type::iterator, bool> ir;
        if (&c != i.cell_p_)
        {
            i.cell_p_->erase(v.first);
            rmap_.erase(v.first);
            rmap_.insert(std::make_pair(v.first, &c));
            ir = c.insert(v);
        }
        else
        {
            ir.first = c.find(v.first);
            BOOST_ASSERT(c.end() != ir.first);
            if (v.first == (*ir.first).first) {
                ir.first->second = v.second;
            } else {
                c.erase(ir.first);
                ir.first = c.insert(v).first;
            }
        }
        return iterator(&c, cell_range(), ir.first);
    }

    inline std::pair<iterator, bool> update(const value_type& v)
    {
        cell_type& c(cell(index(v.second.position())));
        typename key_to_cell_mapper_type::iterator kci(rmap_.find(v.first));
        std::pair<typename cell_type::iterator, bool> ir;
        if (rmap_.end() != kci)
        {
            if (&c != (*kci).second)
            {
                (*kci).second->erase(v.first);
                rmap_.erase(v.first);
                rmap_.insert(std::make_pair(v.first, &c));
                ir = c.insert(v);
            }
            else
            {
                ir.first = c.find(v.first);
                BOOST_ASSERT(c.end() != ir.first);
                if (v.first == (*ir.first).first) {
                    ir.first->second = v.second;
                } else {
                    c.erase(ir.first);
                    ir.first = c.insert(v).first;
                }
            }
            return std::make_pair(iterator(&c, cell_range(), ir.first), false);
        }
        else
        {
            ir = c.insert(v);
            rmap_.insert(std::make_pair(v.first, &c));
            ++size_;
            return std::make_pair(iterator(&c, cell_range(), ir.first), true);
        }
    }

    inline bool erase(iterator const& i)
    {
        if (end() == i)
        {
            return false;
        }
        i.cell_p_->erase(i->cell_iter_);
        --size_;
        return true;
    }

    inline bool erase(const key_type& k)
    {
        typename key_to_cell_mapper_type::iterator p(rmap_.find(k));
        if (rmap_.end() == p)
        {
            return false;
        }
        (*p).second->erase(k);
        rmap_.erase(p);
        --size_;
        return true;
    }

    inline void clear()
    {
        for (typename matrix_type::element *p(matrix_.data()),
                                           *e(matrix_.data()
                                              + matrix_.num_elements());
             p != e; ++p)
        {
            (*p).clear();
        }
        rmap_.clear();
        size_ = 0;
    }

    inline iterator begin()
    {
        BOOST_ASSERT(matrix_.num_elements() > 0);
        std::pair<cell_type*, cell_type*> r(cell_range());
        cell_type* cell_p(r.first);

        while (cell_p->begin() == cell_p->end())
        {
            ++cell_p;
            if (cell_p == r.second)
            {
                --cell_p;
                return iterator(cell_p, r, cell_p->end());
            }
        }

        return iterator(cell_p, r, cell_p->begin());
    }

    inline const_iterator begin() const
    {
        BOOST_ASSERT(matrix_.num_elements() > 0);
        std::pair<cell_type const*, cell_type const*> r(cell_range());
        cell_type const* cell_p(r.first);

        while (cell_p->begin() == cell_p->end())
        {
            ++cell_p;
            if (cell_p == r.second)
            {
                --cell_p;
                return const_iterator(cell_p, r, cell_p->end());
            }
        }

        return const_iterator(cell_p, r, cell_p->begin());
    }

    inline iterator end()
    {
        BOOST_ASSERT(matrix_.num_elements() > 0);
        std::pair<cell_type*, cell_type*> r(cell_range());
        return iterator(r.second - 1, r, (r.second - 1)->end());
    }

    inline const_iterator end() const
    {
        BOOST_ASSERT(matrix_.num_elements() > 0);
        std::pair<cell_type const*, cell_type const*> r(cell_range());
        return const_iterator(r.second - 1, r, (r.second - 1)->end());
    }

    inline iterator find(const key_type& k)
    {
        typename key_to_cell_mapper_type::iterator p(rmap_.find(k));
        if (rmap_.end() == p)
        {
            return end();
        }
        typename cell_type::iterator i((*p).second->find(k));
        if ((*p).second->end() == i)
        {
            return end();
        }
        return iterator((*p).second, cell_range(), i);
    }

    inline const_iterator find(const key_type& k) const
    {
        typename key_to_cell_mapper_type::const_iterator p(rmap_.find(k));
        if (rmap_.end() == p)
        {
            return end();
        }
        typename cell_type::const_iterator i((*p).second->find(k));
        if ((*p).second->end() == i)
        {
            return end();
        }
        return const_iterator((*p).second, cell_range(), i);
    }

    template<typename Tcollect_>
    inline void each_neighbor(const cell_index_type& idx, Tcollect_& collector)
    {
        cell_offset_type _off;
        each_neighbor_loops<Tcollect_>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor(const cell_index_type& idx, Tcollect_ const& collector)
    {
        cell_offset_type _off;
        each_neighbor_loops<Tcollect_ const>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor(const cell_index_type& idx, Tcollect_& collector) const
    {
        cell_offset_type _off;
        each_neighbor_loops<Tcollect_>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor(const cell_index_type& idx, Tcollect_ const& collector) const
    {
        cell_offset_type _off;
        each_neighbor_loops<Tcollect_ const>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic(const cell_index_type& idx,
            Tcollect_& collector)
    {
        cell_offset_type _off;
        each_neighbor_cyclic_loops<Tcollect_>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic(const cell_index_type& idx,
            Tcollect_ const& collector)
    {
        cell_offset_type _off;
        each_neighbor_cyclic_loops<Tcollect_ const>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic(const cell_index_type& idx,
            Tcollect_& collector) const
    {
        cell_offset_type _off;
        each_neighbor_cyclic_loops<Tcollect_>(3, _off, idx, collector);
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic(const cell_index_type& idx,
            Tcollect_ const& collector) const
    {
        cell_offset_type _off;
        each_neighbor_cyclic_loops<Tcollect_ const>(3, _off, idx, collector);
    }

private:
    std::pair<cell_type*, cell_type*> cell_range()
    {
        return std::make_pair(
            matrix_.origin(), matrix_.origin() + matrix_.num_elements());
    }

    std::pair<cell_type const*, cell_type const*> cell_range() const
    {
        return std::make_pair(
            matrix_.origin(), matrix_.origin() + matrix_.num_elements());
    }

    template<typename Tcollect_>
    inline void each_neighbor_loops(const std::size_t depth,
            cell_offset_type& off, const cell_index_type& idx,
            Tcollect_& collector) const
    {
        if (depth > 0)
        {
            for (off[depth - 1] = -1; off[depth - 1] <= 1; ++off[depth - 1])
            {
                each_neighbor_loops(depth - 1, off, idx, collector);
            }
        }
        else
        {
            cell_index_type _idx(idx);
            if (!offset_index(_idx, off)) {
                return;
            }
            cell_type const& c(cell(_idx));
            for (typename cell_type::const_iterator i(c.begin()); i != c.end(); ++i) 
            {
                collector(const_iterator(&c, cell_range(), i), position_type());
            }
        }
    }

    template<typename Tcollect_>
    inline void each_neighbor_loops(const std::size_t depth,
            cell_offset_type& off, const cell_index_type& idx,
            Tcollect_& collector)
    {
        if (depth > 0)
        {
            for (off[depth - 1] = -1; off[depth - 1] <= 1; ++off[depth - 1])
            {
                each_neighbor_loops(depth - 1, off, idx, collector);
            }
        }
        else
        {
            cell_index_type _idx(idx);
            if (!offset_index(_idx, off)) {
                return;
            }
            cell_type& c(cell(_idx));
            for (typename cell_type::iterator i(c.begin()); i != c.end(); ++i) 
            {
                collector(iterator(&c, cell_range(), i), position_type());
            }
        }
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic_loops(const std::size_t depth,
            cell_offset_type& off, const cell_index_type& idx,
            Tcollect_& collector) const
    {
        if (depth > 0)
        {
            for (off[depth - 1] = -1; off[depth - 1] <= 1; ++off[depth - 1])
            {
                each_neighbor_cyclic_loops(depth - 1, off, idx, collector);
            }
        }
        else
        {
            cell_index_type _idx(idx);
            const position_type pos_off(offset_index_cyclic(_idx, off));
            cell_type const& c(cell(_idx));
            for (typename cell_type::const_iterator i(c.begin()); i != c.end(); ++i) 
            {
                collector(const_iterator(&c, cell_range(), i), pos_off);
            }
        }
    }

    template<typename Tcollect_>
    inline void each_neighbor_cyclic_loops(const std::size_t depth,
            cell_offset_type& off, const cell_index_type& idx,
            Tcollect_& collector)
    {
        if (depth > 0)
        {
            for (off[depth - 1] = -1; off[depth - 1] <= 1; ++off[depth - 1])
            {
                each_neighbor_cyclic_loops(depth - 1, off, idx, collector);
            }
        }
        else
        {
            cell_index_type _idx(idx);
            const position_type pos_off(offset_index_cyclic(_idx, off));
            cell_type& c(cell(_idx));
            for (typename cell_type::iterator i(c.begin()); i != c.end(); ++i) 
            {
                collector(iterator(&c, cell_range(), i), pos_off);
            }
        }
    }

private:
    const length_type world_size_;
    const length_type cell_size_;
    matrix_type matrix_;
    key_to_cell_mapper_type rmap_;
    size_type size_;
};

template<typename T_, typename Tkey_,
        template<typename, typename> class MFget_mapper_>
static inline typename MatrixSpace<T_, Tkey_, MFget_mapper_>::cell_index_type&
operator+=(
       typename MatrixSpace<T_,
                Tkey_, MFget_mapper_>::cell_index_type& lhs,
       const typename MatrixSpace<T_,
                Tkey_, MFget_mapper_>::cell_offset_type& rhs)
{
    rhs[0] += lhs[0];
    rhs[1] += lhs[1];
    rhs[2] += lhs[2];
    return rhs;
}

template<typename T_, typename Tkey_,
        template<typename, typename> class MFget_mapper_>
struct is_sized<MatrixSpace<T_, Tkey_, MFget_mapper_> >: boost::mpl::true_ {};

template<typename T_, typename Tkey_,
        template<typename, typename> class MFget_mapper_>
struct range_size<MatrixSpace<T_, Tkey_, MFget_mapper_> >
{
    typedef typename MatrixSpace<T_, Tkey_, MFget_mapper_>::size_type type;
};

template<typename T_, typename Tkey_,
        template<typename, typename> class MFget_mapper_>
struct range_size_retriever<MatrixSpace<T_, Tkey_, MFget_mapper_> >
{
    typedef MatrixSpace<T_, Tkey_, MFget_mapper_> argument_type;
    typedef typename range_size<argument_type>::type result_type;

    result_type operator()(argument_type const& range) const
    {
        return range.size();
    }
};

#endif /* MATRIX_SPACE_HPP */
 </xmp> 
<h3> Model.hpp </h3> <xmp>

#ifndef MODEL_HPP
#define MODEL_HPP

#include <boost/shared_ptr.hpp>
#include <boost/scoped_ptr.hpp>
#include <boost/noncopyable.hpp>
#include <boost/iterator/transform_iterator.hpp>
#include <boost/range/iterator_range.hpp>
#include <map>

#include "SerialIDGenerator.hpp"
#include "SpeciesTypeID.hpp"
#include "SpeciesType.hpp"
#include "utils/get_mapper_mf.hpp"
#include "utils/pair.hpp"

class NetworkRules;

class Model: private boost::noncopyable
{
public:
    typedef SpeciesType species_type_type;
    typedef species_type_type::identifier_type species_id_type;

private:
    typedef SerialIDGenerator<species_id_type> species_type_id_generator_type;
    typedef std::map<species_id_type, boost::shared_ptr<species_type_type> > species_type_map_type;
    typedef select_second<species_type_map_type::value_type> species_second_selector_type;

    typedef get_mapper_mf<std::string, std::string>::type string_map_type;

public:
    typedef boost::transform_iterator<species_second_selector_type,
            species_type_map_type::const_iterator> species_type_iterator;
    typedef boost::iterator_range<species_type_iterator> species_type_range;
    typedef NetworkRules network_rules_type;
    typedef string_map_type::const_iterator string_map_iterator;
    typedef boost::iterator_range<string_map_iterator> attributes_range;

public:
    Model();

    virtual ~Model();

    NetworkRules& network_rules() const
    {
        return *network_rules_;
    }

    void add_species_type(boost::shared_ptr<species_type_type> const& species);

    boost::shared_ptr<species_type_type> get_species_type_by_id(species_id_type const& id) const;

    species_type_range get_species_types() const;

    std::string const& operator[](std::string const& name) const;

    std::string& operator[](std::string const& name);

    attributes_range attributes() const
    {
        return attributes_range(attrs_.begin(), attrs_.end());
    }


public:
    species_type_id_generator_type species_type_id_generator_;
    species_type_map_type species_type_map_;
    boost::scoped_ptr<NetworkRules> network_rules_;
    string_map_type attrs_;
};


#endif /* MODEL_HPP */
 </xmp> 
<h3> Multi.hpp </h3> <xmp>

#ifndef MULTI_HPP
#define MULTI_HPP

#include <boost/scoped_ptr.hpp>
#include <boost/algorithm/string/join.hpp>

#include "exceptions.hpp"
#include "Domain.hpp"
#include "ParticleContainer.hpp"
#include "ParticleContainerBase.hpp"
#include "Sphere.hpp"
#include "BDSimulator.hpp"
#include "BDPropagator.hpp"
#include "Logger.hpp"
#include "PairGreensFunction.hpp"
#include "utils/array_helper.hpp"
#include "utils/range.hpp"

template<typename Ttraits_>
class MultiParticleContainer
    : public Ttraits_::world_type::particle_container_type
{
public:
    typedef ParticleContainerUtils<typename Ttraits_::world_type::traits_type> utils;
    typedef typename Ttraits_::world_type world_type;
    typedef typename world_type::traits_type traits_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename particle_type::shape_type particle_shape_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef Transaction<traits_type> transaction_type;
    typedef abstract_limited_generator<particle_id_pair> particle_id_pair_generator;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;
    typedef std::map<particle_id_type, particle_type> particle_map;
    typedef sized_iterator_range<typename particle_map::const_iterator> particle_id_pair_range;

    virtual ~MultiParticleContainer() {}

    virtual size_type num_particles() const
    {
        return particles_.size();
    }

    virtual length_type world_size() const
    {
        return world_.world_size();
    }

    virtual species_type const& get_species(species_id_type const& id) const
    {
        return world_.get_species(id);
    }

    virtual boost::shared_ptr<structure_type> get_structure(structure_id_type const& id) const
    {
        return world_.get_structure(id);
    }

    virtual particle_id_pair new_particle(species_id_type const& sid,
            position_type const& pos)
    {
        particle_id_pair const retval(world_.new_particle(sid, pos));
        particles_.insert(retval);
        return retval;
    }

    virtual bool update_particle(particle_id_pair const& pi_pair)
    {
        bool const retval(world_.update_particle(pi_pair));
        particles_[pi_pair.first] = pi_pair.second;
        return retval;
    }

    virtual bool remove_particle(particle_id_type const& id)
    {
        world_.remove_particle(id);
        return particles_.erase(id);
    }

    virtual particle_id_pair get_particle(particle_id_type const& id) const
    {
        typename particle_map::const_iterator i(particles_.find(id));
        if (particles_.end() == i)
        {
            throw not_found(std::string("No such particle: id=")
                    + boost::lexical_cast<std::string>(id));
        }
        return *i;
    }

    virtual bool has_particle(particle_id_type const& id) const
    {
        return particles_.end() != particles_.find(id);
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s) const
    {
        return check_overlap(s, array_gen<particle_id_type>());
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore) const
    {
        return check_overlap(s, array_gen(ignore));
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore1, particle_id_type const& ignore2) const
    {
        return check_overlap(s, array_gen(ignore1, ignore2));
    }

    template<typename Tsph_, typename Tset_>
    particle_id_pair_and_distance_list* check_overlap(Tsph_ const& s, Tset_ const& ignore) const
    {
        typename utils::template overlap_checker<Tset_> checker(ignore);
        for (typename particle_map::const_iterator i(particles_.begin()),
                                                   e(particles_.end());
             i != e; ++i)
        {
            length_type const dist(world_.distance(shape((*i).second), s.position()));
            if (dist < s.radius())
            {
                checker(i, dist);
            }
        }
        return checker.result();
    }

    virtual particle_id_pair_generator* get_particles() const
    {
        return make_range_generator<particle_id_pair>(particles_);
    }

    virtual transaction_type* create_transaction()
    {
        return new TransactionImpl<MultiParticleContainer>(*this);
    }

    virtual length_type distance(position_type const& lhs,
                                 position_type const& rhs) const
    {
        return world_.distance(lhs, rhs);
    }

    virtual position_type apply_boundary(position_type const& v) const
    {
        return world_.apply_boundary(v);
    }

    virtual length_type apply_boundary(length_type const& v) const
    {
        return world_.apply_boundary(v);
    }

    virtual position_type cyclic_transpose(position_type const& p0, position_type const& p1) const
    {
        return world_.cyclic_transpose(p0, p1);
    }

    virtual length_type cyclic_transpose(length_type const& p0, length_type const& p1) const
    {
        return world_.cyclic_transpose(p0, p1);
    }

    particle_id_pair_range get_particles_range() const
    {
        return particle_id_pair_range(particles_.begin(), particles_.end(),
                                      particles_.size());
    }

    MultiParticleContainer(world_type& world): world_(world) {}

private:
    world_type& world_;
    particle_map particles_;
};

template<typename Tsim_>
class Multi: public Domain<typename Tsim_::traits_type>
{
public:
    typedef Tsim_ simulator_type;
    typedef typename simulator_type::traits_type traits_type;
    typedef Domain<traits_type> base_type;
    typedef typename traits_type::world_type::particle_type particle_type;
    typedef typename particle_type::shape_type particle_shape_type;
    typedef typename traits_type::world_type::species_type species_type;
    typedef typename traits_type::world_type::species_id_type species_id_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_type particle_id_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::size_type size_type;
    typedef typename traits_type::world_type::structure_type structure_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::shell_id_type shell_id_type;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::template shell_generator<
        typename simulator_type::sphere_type>::type spherical_shell_type;
    typedef std::pair<const typename traits_type::shell_id_type, spherical_shell_type> spherical_shell_id_pair;
    typedef typename traits_type::reaction_record_type reaction_record_type;

    typedef std::map<shell_id_type, spherical_shell_type> spherical_shell_map;
    typedef sized_iterator_range<typename spherical_shell_map::const_iterator> spherical_shell_id_pair_range;
    typedef MultiParticleContainer<traits_type> multi_particle_container_type;

    enum event_kind
    {
        NONE,
        ESCAPE,
        REACTION,
        NUM_MULTI_EVENT_KINDS
    };

private:
    struct last_reaction_setter: ReactionRecorder<reaction_record_type>
    {
        virtual ~last_reaction_setter() {}

        virtual void operator()(reaction_record_type const& rec)
        {
            outer_.last_reaction_.swap(const_cast<reaction_record_type&>(rec));
        }

        last_reaction_setter(Multi& outer): outer_(outer) {}

        Multi& outer_;
    };

public:
    virtual ~Multi() {}

    virtual char const* type_name() const
    {
        return "Multi";
    }

    virtual std::string as_string() const
    {
        return (boost::format(
            "%s(id=%s, event=%s, last_time=%g, dt=%g, particles=[%s])") %
            type_name() %
            boost::lexical_cast<std::string>(base_type::id_).c_str() %
            boost::lexical_cast<std::string>(base_type::event_.first).c_str() %
            base_type::last_time_ % base_type::dt_ %
            stringize_and_join(
                make_select_first_range(pc_.get_particles_range()),
                ", ")).str();
    }

    Multi(identifier_type const& id, simulator_type& main, Real dt_factor)
        : base_type(id), main_(main), pc_(*main.world()), dt_factor_(dt_factor),
          shells_(), last_event_(NONE) {}

    event_kind const& last_event() const
    {
        return last_event_;
    }

    reaction_record_type const& last_reaction() const
    {
        return last_reaction_;
    }

    bool has_particle(particle_id_type const& pid) const
    {
        return pc_.has_particle(pid);
    }

    bool add_particle(particle_id_pair const& pp)
    {
        return pc_.update_particle(pp);
    }

    bool add_shell(spherical_shell_id_pair const& sp)
    {
        spherical_shell_id_pair new_sp(sp);
        new_sp.second.did() = base_type::id();
        return shells_.insert(new_sp).second;
    }

    spherical_shell_id_pair_range get_shells() const
    {
        return spherical_shell_id_pair_range(shells_.begin(), shells_.end(), shells_.size());
    }

    virtual typename Domain<traits_type>::size_type num_shells() const
    {
        return shells_.size();
    }

    virtual typename Domain<traits_type>::size_type multiplicity() const
    {
        return pc_.num_particles();
    }

    virtual void accept(ImmutativeDomainVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeDomainVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    bool within_shell(particle_shape_type const& sphere) const
    {
        for (typename spherical_shell_map::const_iterator
                i(shells_.begin()), e(shells_.end()); i != e; ++i)
        {
            spherical_shell_id_pair const& sp(*i);
            position_type ppos(main_.world()->cyclic_transpose(sphere.position(), (sp).second.position()));
            if (distance(ppos, (sp).second.shape().position()) < (sp).second.shape().radius())
            {
                return true;
            }
        }
        return false;
    }

    typename multi_particle_container_type::particle_id_pair_range
    get_particles_range() const
    {
        return pc_.get_particles_range();
    }

    void step()
    {
        boost::scoped_ptr<
            typename multi_particle_container_type::transaction_type>
                tx(pc_.create_transaction());
        typedef typename multi_particle_container_type::transaction_type::particle_id_pair_generator particle_id_pair_generator;
        typedef typename multi_particle_container_type::transaction_type::particle_id_pair_and_distance_list particle_id_pair_and_distance_list;

        last_reaction_setter rs(*this);
        BDPropagator<traits_type> ppg(
            *tx, *main_.network_rules(), main_.rng(),
            dt_factor_ * BDSimulator<traits_type>::determine_dt(*main_.world()),
            1 /* FIXME: dissociation_retry_moves */, &rs,
            make_select_first_range(pc_.get_particles_range()));

        last_event_ = NONE;

        while (ppg())
        {
            if (last_reaction_)
            {
                last_event_ = REACTION;
                break;
            }
        }

        boost::scoped_ptr<particle_id_pair_generator>
            added_particles(tx->get_added_particles()),
            modified_particles(tx->get_modified_particles());
        LOG_DEBUG(("added_particles=%zu, modified_particles=%zu",
            ::count(*added_particles), ::count(*modified_particles)));
        chained_generator<particle_id_pair_generator,
                          particle_id_pair_generator>
            gen(*added_particles, *modified_particles);
        while (::valid(gen))
        {
            particle_id_pair pp(gen());
            boost::scoped_ptr<particle_id_pair_and_distance_list>
                overlapped(main_.world()->check_overlap(
                    pp.second.shape(), pp.first));
            if (overlapped && ::size(*overlapped))
            {
                log_.info("collision occurred between particles of a multi and the outside: %s.  moves will be rolled back.",
                    boost::lexical_cast<std::string>(pp.first).c_str());
                tx->rollback();
                return;
            }

            if (!within_shell(pp.second.shape()))
            {
                last_event_ = ESCAPE;
                main_.clear_volume(pp.second.shape(), base_type::id_);
            }
        }
    }

protected:
    simulator_type& main_;
    multi_particle_container_type pc_;
    Real dt_factor_;
    spherical_shell_map shells_;
    event_kind last_event_;
    reaction_record_type last_reaction_;

    static Logger& log_;
};

template<typename Tsim_>
Logger& Multi<Tsim_>::log_(Logger::get_logger("ecell.Multi"));

#endif /* MULTI_HPP */
 </xmp> 
<h3> NetworkRules.hpp </h3> <xmp>

#ifndef NETWORK_RULES_HPP
#define NETWORK_RULES_HPP

#include <map>
#include <boost/range/iterator_range.hpp>
#include "ReactionRule.hpp"
#include "generator.hpp"

class NetworkRules
{
public:
    typedef ReactionRule reaction_rule_type;
    typedef SpeciesTypeID species_id_type;
    typedef abstract_limited_generator<reaction_rule_type> reaction_rule_generator;

public:
    virtual void add_reaction_rule(ReactionRule const&) = 0;
    virtual void remove_reaction_rule(ReactionRule const&) = 0;

    virtual reaction_rule_generator* query_reaction_rule(species_id_type const& r1) const = 0;

    virtual reaction_rule_generator* query_reaction_rule(species_id_type const& r1, species_id_type const& r2) const = 0;

    virtual ~NetworkRules() = 0;
};

#endif /* NETWORK_RULES_HPP */
 </xmp> 
<h3> NetworkRulesWrapper.hpp </h3> <xmp>

#ifndef NETWORK_RULES_WRAPPER_HPP
#define NETWORK_RULES_WRAPPER_HPP

#include <map>
#include <vector>
#include <boost/scoped_ptr.hpp>
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include "twofold_container.hpp"
#include "utils/range.hpp"
#include "ReactionRuleInfo.hpp"
#include "generator.hpp"

template<typename T_, typename Trri_>
class NetworkRulesWrapper
{
public:
    typedef T_ backend_type;
    typedef Trri_ reaction_rule_type;
    typedef typename reaction_rule_type::species_id_type species_id_type;
    typedef std::vector<reaction_rule_type> reaction_rule_vector;
    typedef reaction_rule_vector reaction_rules;
    typedef std::map<species_id_type, reaction_rule_vector> first_order_reaction_rule_vector_map;
    typedef std::map<std::pair<species_id_type, species_id_type>, reaction_rule_vector> second_order_reaction_rule_vector_map;

public:
    reaction_rule_vector const& query_reaction_rule(species_id_type const& r1) const
    {
        typename first_order_reaction_rule_vector_map::const_iterator i(
            first_order_cache_.find(r1));
        if (i == first_order_cache_.end())
        {
            std::pair<
                typename first_order_reaction_rule_vector_map::iterator,
                bool> x(first_order_cache_.insert(
                    std::make_pair(r1, reaction_rule_vector())));
            boost::scoped_ptr<typename backend_type::reaction_rule_generator>
                gen(backend_.query_reaction_rule(r1));
            if (gen)
            {
                while (::valid(*gen))
                {
                    typename backend_type::reaction_rule_type const r((*gen)());
                    typedef typename reaction_rule_type::rate_type rate_type;
                    rate_type rate;
                    try{
                        rate = boost::lexical_cast<rate_type>(r["k"]);
                    }
                    catch (boost::bad_lexical_cast &) 
                    // There is no standard textual representation of infinity 
                    // in the C++ standard, so boost throws a bad_lexical_cast 
                    // for 'inf', just like for any other non-numerical text. 
                    {
                        if(r["k"].compare("inf") == 0){
                            rate = std::numeric_limits<rate_type>::infinity(); 
                        }
                        else{
                            throw;
                        }
                    }
                    (*x.first).second.push_back(reaction_rule_type(
                        r.id(),
                        rate,
                        r.get_reactants(),
                        r.get_products()));
                }
            }
            return (*x.first).second;
        }
        return (*i).second;
    }

    reaction_rule_vector const& query_reaction_rule(
            species_id_type const& r1, species_id_type const& r2) const
    {
        typename second_order_reaction_rule_vector_map::const_iterator i(
            second_order_cache_.find(std::make_pair(r1, r2)));
        if (i == second_order_cache_.end())
        {
            std::pair<
                typename second_order_reaction_rule_vector_map::iterator,
                bool> x(second_order_cache_.insert(
                    std::make_pair(std::make_pair(r1, r2),
                                   reaction_rule_vector())));
            boost::scoped_ptr<typename backend_type::reaction_rule_generator>
                gen(backend_.query_reaction_rule(r1, r2));
            if (gen)
            {
                while (::valid(*gen))
                {
                    typename backend_type::reaction_rule_type const r((*gen)());
                    typedef typename reaction_rule_type::rate_type rate_type;
                    rate_type rate;
                    try{
                        rate = boost::lexical_cast<rate_type>(r["k"]);
                    }
                    catch (boost::bad_lexical_cast &) 
                    // There is no standard textual representation of infinity 
                    // in the C++ standard, so boost throws a bad_lexical_cast 
                    // for 'inf', just like for any other non-numerical text. 
                    {
                        if(r["k"].compare("inf") == 0){
                            rate = std::numeric_limits<rate_type>::infinity(); 
                        }
                        else{
                            throw;
                        }
                    }
                    (*x.first).second.push_back(reaction_rule_type(
                        r.id(),
                        rate,
                        r.get_reactants(),
                        r.get_products()));
                }
            }
            return (*x.first).second;
        }
        return (*i).second;
    }

    NetworkRulesWrapper(backend_type const& backend): backend_(backend) {}

private:
    mutable first_order_reaction_rule_vector_map first_order_cache_;
    mutable second_order_reaction_rule_vector_map second_order_cache_;
    backend_type const& backend_;
};

#endif /* NETWORK_RULES_WRAPPER_HPP */
 </xmp> 
<h3> OldDefs.hpp </h3> <xmp>

#if !defined( __OLDDEFS_HPP )
#define __OLDDEFS_HPP

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif /* HAVE_CONFIG_H */

#include <vector>
#include <boost/multi_array.hpp>
#include <cmath>

#include "Defs.hpp"

// This file is needed temporarily by   GreensFunction1DAbsAbs.cpp
// and                                  GreensFunction1DRadAbs.cpp
//
// At some point it should be taken out of the new code version.
// This requires some major refurbishment of the above functions, so postponed for later.
//
// All passages conflicting with analogous definitions in the new Defs.hpp are taken out.
//




typedef std::vector< Real > RealVector;
typedef boost::multi_array<Real, 2>
Real2DArray;
typedef boost::multi_array<Real, 3>
Real3DArray;
typedef boost::multi_array<Real, 4>
Real4DArray;


#if !HAVE_SINCOS
inline void sincos( double x, double* s, double* c )
{
    *s = sin( x );
    *c = cos( x );
}
#endif /* !HAVE_SINCOS */

// stringifiers.  see preprocessor manual
#define XSTR( S ) STR( S )
#define STR( S ) #S

#define THROW_UNLESS( CLASS, EXPRESSION )       \
    if( ! ( EXPRESSION ) )\
    {\
        throw CLASS( "Check [" + std::string( STR( EXPRESSION ) ) +\
                     "] failed." );\
    }\


#define IGNORE_RETURN (void)


#endif // __OLDDEFS_HPP
 </xmp> 
<h3> PairGreensFunction.hpp </h3> <xmp>

#if !defined( __PAIRGREENSFUNCTION_HPP )
#define __PAIRGREENSFUNCTION_HPP

#include "Defs.hpp"
#include "GreensFunction.hpp"

class PairGreensFunction: public GreensFunction
{
public:
    PairGreensFunction(Real D, Real kf, Real r0, Real Sigma)
      : GreensFunction(D), kf(kf), r0(r0), Sigma(Sigma) {}
    
    virtual ~PairGreensFunction() {}
    
    Real getD() const
    {
        return this->D;
    }
    
    Real getkf() const
    {
        return this->kf;
    }
    
    Real getSigma() const
    {
        return this->Sigma;
    }

    Real getr0() const
    {
        return this->r0;
    }

    virtual Real drawTime(Real rnd) const = 0;
    
    virtual Real drawR(Real rnd, Real t) const = 0;
    
    virtual Real drawTheta(Real rnd, Real r, Real t) const = 0;

protected:
  const Real kf;
  const Real r0;
  const Real Sigma;
};

#endif /* __PAIRGREENSFUNCTION_HPP */
 </xmp> 
<h3> Pair.hpp </h3> <xmp>

#ifndef PAIR_HPP
#define PAIR_HPP

#include <cmath>
#include <utility>
#include <boost/array.hpp>
#include "ShapedDomain.hpp"

template<typename Ttraits_>
class Pair: public ShapedDomain<Ttraits_>
{
public:
    typedef ShapedDomain<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::particle_id_type particle_id_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef boost::array<particle_id_pair, 2> particle_array_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::traits_type::position_type position_type;

public:
    virtual ~Pair() {}

    Pair(identifier_type const& id,
         particle_id_pair const& p0, particle_id_pair const& p1)
        : base_type(id)
    {
        if (p0.second.D() < p1.second.D())
        {
            new(&particles_[0]) particle_id_pair(p0);
            new(&particles_[1]) particle_id_pair(p1);
        }
        else
        {
            new(&particles_[0]) particle_id_pair(p1);
            new(&particles_[1]) particle_id_pair(p0);
        }
    }

    particle_array_type const& particles() const
    {
        return particles_;
    }

    particle_array_type& particles()
    {
        return particles_;
    }

protected:
    particle_array_type particles_;
};

#endif /* PAIR_HPP */
 </xmp> 
<h3> ParticleContainerBase.hpp </h3> <xmp>

#ifndef PARTICLE_CONTAINER_BASE_HPP
#define PARTICLE_CONTAINER_BASE_HPP
#include "utils/range.hpp"
#include "utils/get_mapper_mf.hpp"
#include "utils/unassignable_adapter.hpp"
#include "MatrixSpace.hpp"
#include "abstract_set.hpp"
#include "generator.hpp"
#include "exceptions.hpp"
#include "ParticleContainer.hpp"
#include "Transaction.hpp"

template<typename Ttraits_>
struct ParticleContainerUtils
{
    typedef Ttraits_ traits_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;

    struct distance_comparator:
            public std::binary_function<
                typename particle_id_pair_and_distance_list::placeholder,
                typename particle_id_pair_and_distance_list::placeholder,
                bool>
    {
        typedef typename particle_id_pair_and_distance_list::placeholder
                first_argument_type;
        typedef typename particle_id_pair_and_distance_list::const_caster const_caster;
        bool operator()(first_argument_type const& lhs,
                        first_argument_type const& rhs) const
        {
            return c_(lhs).second < c_(rhs).second;
        }

        const_caster c_;
    };

    template<typename Tset_>
    struct overlap_checker
    {
        overlap_checker(Tset_ const& ignore = Tset_()): ignore_(ignore), result_(0), compare_(0) {}

        template<typename Titer_>
        void operator()(Titer_ const& i, length_type const& dist)
        {
            if (!contains(ignore_, (*i).first))
            {
                if (!result_)
                {
                    result_ = new particle_id_pair_and_distance_list();
                }
                result_->push_back(std::make_pair(*i, dist));
            }
        }

        particle_id_pair_and_distance_list* result() const
        {
            if (result_)
            {
                std::sort(result_->pbegin(), result_->pend(), *compare_);
            }
            return result_;
        }

    private:
        Tset_ const& ignore_;
        particle_id_pair_and_distance_list* result_;
        distance_comparator* compare_;
    };
};

template<typename Tderived_, typename Ttraits_ = typename Tderived_::traits_type>
class ParticleContainerBase
    : public ParticleContainer<Ttraits_>
{
public:
    typedef ParticleContainerUtils<Ttraits_> utils;
    typedef ParticleContainer<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::particle_id_generator particle_id_generator;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::particle_type::shape_type particle_shape_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef Transaction<traits_type> transaction_type;

    typedef MatrixSpace<particle_type, particle_id_type, get_mapper_mf> particle_matrix_type;
    typedef abstract_limited_generator<particle_id_pair> particle_id_pair_generator;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef sized_iterator_range<typename particle_matrix_type::const_iterator> particle_id_pair_range;

    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;

protected:
public:
    ParticleContainerBase(length_type world_size, size_type size)
        : pmat_(world_size, size) {}

    virtual size_type num_particles() const
    {
        return pmat_.size();
    }

    virtual length_type world_size() const
    {
        return pmat_.world_size();
    }

    length_type cell_size() const
    {
        return pmat_.cell_size();
    }

    size_type matrix_size() const
    {
        return pmat_.matrix_size();
    }

    template<typename T_>
    length_type distance(T_ const& lhs, position_type const& rhs) const
    {
        return traits_type::distance(lhs, rhs, world_size());
    }

    virtual length_type distance(position_type const& lhs,
                                 position_type const& rhs) const
    {
        return traits_type::distance(lhs, rhs, world_size());
    }

    virtual position_type apply_boundary(position_type const& v) const
    {
        return traits_type::apply_boundary(v, world_size());
    }

    virtual length_type apply_boundary(length_type const& v) const
    {
        return traits_type::apply_boundary(v, world_size());
    }

    virtual position_type cyclic_transpose(position_type const& p0, position_type const& p1) const
    {
        return traits_type::cyclic_transpose(p0, p1, world_size());
    }

    virtual length_type cyclic_transpose(length_type const& p0, length_type const& p1) const
    {
        return traits_type::cyclic_transpose(p0, p1, world_size());
    }

    template<typename T1_>
    T1_ calculate_pair_CoM(
        T1_ const& p1, T1_ const& p2, 
        typename element_type_of<T1_>::type const& D1,
        typename element_type_of<T1_>::type const& D2)
    {
        typedef typename element_type_of< T1_ >::type element_type;   

        T1_ retval;

        const T1_ p2t(cyclic_transpose(p2, p1));

        return modulo(
            divide(
                add(multiply(p1, D2), multiply(p2t, D1)),
                add(D1, D2)),
            world_size());
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s) const
    {
        return check_overlap<particle_shape_type>(s);
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore) const
    {
        return check_overlap(s, array_gen(ignore));
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore1, particle_id_type const& ignore2) const
    {
        return check_overlap(s, array_gen(ignore1, ignore2));
    }

    template<typename Tsph_, typename Tset_>
    particle_id_pair_and_distance_list* check_overlap(Tsph_ const& s, Tset_ const& ignore,
        typename boost::disable_if<boost::is_same<Tsph_, particle_id_pair> >::type* =0) const
    {
        typename utils::template overlap_checker<Tset_> oc(ignore);
        traits_type::take_neighbor(pmat_, oc, s);
        return oc.result();
    }

    template<typename Tsph_>
    particle_id_pair_and_distance_list* check_overlap(Tsph_ const& s,
        typename boost::disable_if<boost::is_same<Tsph_, particle_id_pair> >::type* =0) const
    {
        typename utils::template overlap_checker<boost::array<particle_id_type, 0> > oc;
        traits_type::take_neighbor(pmat_, oc, s);
        return oc.result();
    }

    particle_id_pair get_particle(particle_id_type const& id, bool& found) const
    {
        typename particle_matrix_type::const_iterator i(pmat_.find(id));
        if (pmat_.end() == i) {
            found = false;
            return particle_id_pair();
        }
        found = true;
        return *i;
    }

    virtual particle_id_pair get_particle(particle_id_type const& id) const
    {
        typename particle_matrix_type::const_iterator i(pmat_.find(id));
        if (pmat_.end() == i) {
            throw not_found(std::string("No such particle: id=")
                    + boost::lexical_cast<std::string>(id));
        }
        return *i;
    }

    virtual bool has_particle(particle_id_type const& id) const
    {
        return pmat_.end() != pmat_.find(id);
    }

    virtual transaction_type* create_transaction();

    virtual particle_id_pair_generator* get_particles() const
    {
        return make_range_generator<particle_id_pair>(pmat_);
    }

    particle_id_pair_range get_particles_range() const
    {
        return particle_id_pair_range(pmat_.begin(), pmat_.end(), pmat_.size());
    }

    virtual bool update_particle(particle_id_pair const& pi_pair)
    {
        return pmat_.update(pi_pair).second;
    }

    virtual bool remove_particle(particle_id_type const& id)
    {
        return pmat_.erase(id);
    }

protected:
    particle_matrix_type pmat_;
};

template<typename Tderived_, typename Ttraits_>
inline Transaction<Ttraits_>*
ParticleContainerBase<Tderived_, Ttraits_>::create_transaction()
{
    return new TransactionImpl<ParticleContainerBase>(*this);
}

#endif /* PARTICLE_CONTAINER_BASE_HPP */
 </xmp> 
<h3> ParticleContainer.hpp </h3> <xmp>

#ifndef PARTICLE_CONTAINER_HPP
#define PARTICLE_CONTAINER_HPP

#include <utility>
#include <boost/shared_ptr.hpp>
#include "generator.hpp"
#include "utils/get_default_impl.hpp"
#include "utils/unassignable_adapter.hpp"

template<typename Ttraits_>
class Transaction;

template<typename Ttraits_>
class ParticleContainer
{
public:
    typedef Ttraits_ traits_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename particle_type::shape_type particle_shape_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef Transaction<traits_type> transaction_type;
    typedef abstract_limited_generator<particle_id_pair> particle_id_pair_generator;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;

    virtual ~ParticleContainer() {};

    virtual size_type num_particles() const = 0;

    virtual length_type world_size() const = 0;

    virtual species_type const& get_species(species_id_type const& id) const = 0;

    virtual boost::shared_ptr<structure_type> get_structure(structure_id_type const& id) const = 0;

    virtual particle_id_pair new_particle(species_id_type const& sid,
            position_type const& pos) = 0;

    virtual bool update_particle(particle_id_pair const& pi_pair) = 0;

    virtual bool remove_particle(particle_id_type const& id) = 0;

    virtual particle_id_pair get_particle(particle_id_type const& id) const = 0;

    virtual bool has_particle(particle_id_type const& id) const = 0;

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s) const = 0;

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore) const = 0;

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore1, particle_id_type const& ignore2) const = 0;

    virtual particle_id_pair_generator* get_particles() const = 0;

    virtual transaction_type* create_transaction() = 0;

    virtual length_type distance(position_type const& lhs,
                                 position_type const& rhs) const = 0;

    virtual position_type apply_boundary(position_type const& v) const = 0;

    virtual length_type apply_boundary(length_type const& v) const = 0;

    virtual position_type cyclic_transpose(position_type const& p0, position_type const& p1) const = 0;

    virtual length_type cyclic_transpose(length_type const& p0, length_type const& p1) const = 0;

};


#endif /* PARTICLE_CONTAINER_HPP */
 </xmp> 
<h3> Particle.hpp </h3> <xmp>

#ifndef PARTICLE_HPP
#define PARTICLE_HPP

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

#include "Sphere.hpp"
#include "Shape.hpp"

template<typename T_, typename Td_, typename Tsid_>
struct Particle
{
    typedef Sphere<T_> shape_type;
    typedef Td_ D_type;
    typedef Td_ v_type;	// the drift v has the same type as diffusion constant D for now, may be generalized at a later stage
    typedef Tsid_ species_id_type;
    typedef typename shape_type::position_type position_type;
    typedef typename shape_type::length_type length_type;

    Particle(): shape_(), species_id_(), D_(0.), v_(0.) {}

    Particle(species_id_type const& species_id, shape_type const& shape,
             D_type const& D)
        : shape_(shape), species_id_(species_id), D_(D), v_(0.){}

    Particle(species_id_type const& species_id, shape_type const& shape,
             D_type const& D, v_type const& v)
        : shape_(shape), species_id_(species_id), D_(D), v_(v) {}

    position_type& position()
    {
        return shape_.position();
    }

    position_type const& position() const
    {
        return shape_.position();
    }

    length_type& radius()
    {
        return shape_.radius();
    }

    length_type const& radius() const
    {
        return shape_.radius();
    }

    D_type& D()
    {
        return D_;
    }

    D_type const& D() const
    {
        return D_;
    }
    
    v_type& v()
    {
        return v_;
    }

    v_type const& v() const
    {
        return v_;
    }

    shape_type& shape()
    {
        return shape_;
    }

    shape_type const& shape() const
    {
        return shape_;
    }

    species_id_type const& sid() const
    {
        return species_id_;
    }

    species_id_type& sid()
    {
        return species_id_;
    }

    bool operator==(Particle const& rhs) const
    {
        return species_id_ == rhs.sid() && shape_ == rhs.shape();
    }

    bool operator!=(Particle const& rhs) const
    {
        return !operator==(rhs);
    }

    std::string show(int precision)
    {
        std::ostringstream strm;
        strm.precision(precision);
        strm << *this;
        return strm.str();
    }

private:
    shape_type shape_;
    species_id_type species_id_;
    D_type D_;
    v_type v_;
};

template<typename Tstrm_, typename Ttraits_, typename T_, typename Td_, typename Tsid_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm, const Particle<T_, Td_, Tsid_>& p)
{
    strm << "Particle(" << p.shape() << ", D=" << p.D() << ", v=" << p.v() << ", " << p.sid() << ")";
    return strm;
}

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_, typename Td_, typename Tsid_>
struct hash<Particle<T_, Td_, Tsid_> >
{
    typedef Particle<T_, Td_, Tsid_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::position_type>()(val.position()) ^
            hash<typename argument_type::length_type>()(val.radius()) ^
            hash<typename argument_type::D_type>()(val.D()) ^
            hash<typename argument_type::species_id_type>()(val.sid());
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* PARTICLE_HPP */
 </xmp> 
<h3> ParticleID.hpp </h3> <xmp>

#ifndef PARTICLE_ID_HPP
#define PARTICLE_ID_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif
#include "Identifier.hpp"

struct ParticleID: public Identifier<ParticleID, unsigned long long, int>
{
    typedef Identifier<ParticleID, unsigned long long, int> base_type;

    ParticleID(value_type const& value = value_type(0, 0))
        : base_type(value) {}
};

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<>
struct hash<ParticleID>
{
    std::size_t operator()(ParticleID const& val) const
    {
        return static_cast<std::size_t>(val().first ^ val().second);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

template<typename Tstrm_, typename Ttraits_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm,
        const ParticleID& v)
{
    strm << "PID(" << v().first << ":" << v().second << ")";
    return strm;
}

#endif /* PARTICLE_ID_HPP */
 </xmp> 
<h3> ParticleModel.hpp </h3> <xmp>

#ifndef PARTICLE_MODEL_HPP
#define PARTICLE_MODEL_HPP

#include "Defs.hpp"
#include "Model.hpp"
#include "StructureType.hpp"

class ParticleModel: public Model
{
public:
    typedef Model base_type;
    typedef StructureType structure_type_type;
    typedef structure_type_type::identifier_type structure_id_type;

    typedef std::map<structure_id_type, boost::shared_ptr<structure_type_type> > structure_type_map_type;

    typedef select_second<structure_type_map_type::value_type> structure_second_selector_type;

public:
    typedef boost::transform_iterator<structure_second_selector_type,
            structure_type_map_type::const_iterator> structure_type_iterator;
    typedef boost::iterator_range<structure_type_iterator> structure_type_range;

public:
    ParticleModel();

    virtual ~ParticleModel();

    boost::shared_ptr<structure_type_type> get_structure_type_by_id(structure_id_type const& id) const;

    void add_structure_type(boost::shared_ptr<structure_type_type> const& structure);

    structure_type_range get_structure_types() const;

public:
    structure_type_map_type structure_type_map_;
};


#endif /* MODEL_HPP */
 </xmp> 
<h3> ParticleSimulationStructure.hpp </h3> <xmp>

#ifndef PARTICLE_SIMULATION_STRUCTURE_HPP
#define PARTICLE_SIMULATION_STRUCTURE_HPP

#include "Structure.hpp"

template<typename Ttraits_>
struct ImmutativeStructureVisitor;

template<typename Ttraits_>
struct MutativeStructureVisitor;

template<typename Ttraits_>
struct ParticleSimulationStructure: public Structure<typename Ttraits_::world_type::traits_type>
{
    typedef Ttraits_ traits_type;
    typedef Structure<typename traits_type::world_type::traits_type> base_type;
    typedef typename base_type::identifier_type identifier_type;

    virtual ~ParticleSimulationStructure() {}

    virtual void accept(ImmutativeStructureVisitor<traits_type> const&) const = 0;

    virtual void accept(MutativeStructureVisitor<traits_type> const&) = 0;

    ParticleSimulationStructure(identifier_type const& id): base_type(id) {}
};

#endif /* PARTICLE_SIMULATION_STRUCTURE_HPP */
 </xmp> 
<h3> ParticleSimulatorFactory.hpp </h3> <xmp>

#ifndef PARTICLE_SIMULATOR_FACTORY_HPP
#define PARTICLE_SIMULATOR_FACTORY_HPP

#include <boost/noncopyable.hpp>
#include "ParticleSimulator.hpp"
#include "ParticleModel.hpp"

template<typename Ttraits_>
class ParticleSimulatorFactory
{
public:
    typedef Ttraits_ traits_type;

public:
    ParticleSimulatorFactory() {}

    virtual ~ParticleSimulatorFactory() {}

    virtual ParticleSimulator<traits_type>* operator()(ParticleModel const& model) const = 0;
};

#endif /* PARTICLE_SIMULATION_HPP */
 </xmp> 
<h3> ParticleSimulator.hpp </h3> <xmp>

#ifndef PARTICLE_SIMULATOR_HPP
#define PARTICLE_SIMULATOR_HPP

#include <boost/bind.hpp>
#include <boost/shared_ptr.hpp>
#include "Sphere.hpp"
#include "Cylinder.hpp"
#include "Box.hpp"
#include "ParticleSimulationStructure.hpp"
#include "CuboidalRegion.hpp"
#include "PlanarSurface.hpp"
#include "CylindricalSurface.hpp"
#include "SphericalSurface.hpp"
#include "NetworkRules.hpp"
#include "NetworkRulesWrapper.hpp"
#include "ReactionRuleInfo.hpp"
#include "ReactionRecorder.hpp"
#include "ReactionRecord.hpp"

template<typename Tworld_>
struct ParticleSimulatorTraitsBase
{
    typedef Tworld_ world_type;
    typedef Real rate_type;
    typedef Real time_type;
    typedef int reaction_rule_id_type;
    typedef ReactionRuleInfo<
            reaction_rule_id_type,
            typename world_type::traits_type::species_id_type,
            rate_type> reaction_rule_type;
    typedef NetworkRulesWrapper<NetworkRules,
                                reaction_rule_type> network_rules_type;
    typedef ReactionRecord<typename world_type::particle_id_type,
                           reaction_rule_id_type> reaction_record_type;
    typedef ReactionRecorder<reaction_record_type> reaction_recorder_type;

    static const Real MINIMAL_SEPARATION_FACTOR = (1.0 + 1e-7);
};

template<typename Ttraits_>
class ParticleSimulator;

template<typename Ttraits_>
struct ImmutativeStructureVisitor
{
    typedef Ttraits_ traits_type;
    typedef typename ParticleSimulator<traits_type>::spherical_surface_type spherical_surface_type;
    typedef typename ParticleSimulator<traits_type>::cylindrical_surface_type cylindrical_surface_type;
    typedef typename ParticleSimulator<traits_type>::planar_surface_type planar_surface_type;
    typedef typename ParticleSimulator<traits_type>::cuboidal_region_type cuboidal_region_type;

    virtual ~ImmutativeStructureVisitor() {}

    virtual void operator()(spherical_surface_type const&) const = 0;

    virtual void operator()(cylindrical_surface_type const&) const = 0;

    virtual void operator()(planar_surface_type const&) const = 0;

    virtual void operator()(cuboidal_region_type const&) const = 0;
};

template<typename Ttraits_>
struct MutativeStructureVisitor
{
    typedef Ttraits_ traits_type;
    typedef typename ParticleSimulator<traits_type>::spherical_surface_type spherical_surface_type;
    typedef typename ParticleSimulator<traits_type>::cylindrical_surface_type cylindrical_surface_type;
    typedef typename ParticleSimulator<traits_type>::planar_surface_type planar_surface_type;
    typedef typename ParticleSimulator<traits_type>::cuboidal_region_type cuboidal_region_type;

    virtual ~MutativeStructureVisitor() {}

    virtual void operator()(spherical_surface_type&) const = 0;

    virtual void operator()(cylindrical_surface_type&) const = 0;

    virtual void operator()(planar_surface_type&) const = 0;

    virtual void operator()(cuboidal_region_type&) const = 0;
};

template<typename Ttraits_>
class ParticleSimulator
{
public:
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type world_type;
    typedef Sphere<typename world_type::length_type> sphere_type;
    typedef Cylinder<typename world_type::length_type> cylinder_type;
    typedef Box<typename world_type::length_type> box_type;
    typedef Plane<typename world_type::length_type> plane_type;
    typedef ParticleSimulationStructure<traits_type> particle_simulation_structure_type;
    typedef Surface<traits_type> surface_type;
    typedef Region<traits_type> region_type;
    typedef SphericalSurface<traits_type> spherical_surface_type;
    typedef CylindricalSurface<traits_type> cylindrical_surface_type;
    typedef PlanarSurface<traits_type> planar_surface_type;
    typedef CuboidalRegion<traits_type> cuboidal_region_type;
    typedef typename traits_type::network_rules_type network_rules_type;
    typedef typename world_type::traits_type::rng_type rng_type;
    typedef typename traits_type::time_type time_type;
    typedef typename traits_type::reaction_record_type reaction_record_type;
    typedef typename traits_type::reaction_recorder_type reaction_recorder_type;

public:
    virtual ~ParticleSimulator() {}

    ParticleSimulator(boost::shared_ptr<world_type> world,
                      boost::shared_ptr<network_rules_type const> network_rules,
                      rng_type& rng)
        : world_(world), network_rules_(network_rules), rrec_(), rng_(rng),
          t_(0.), dt_(0.), num_steps_(0), paranoiac_(false) {}

    boost::shared_ptr<world_type> const& world() const
    {
        return world_;
    }

    boost::shared_ptr<network_rules_type const> const& network_rules() const
    {
        return network_rules_;
    }

    boost::shared_ptr<reaction_recorder_type> const& reaction_recorder() const
    {
        return rrec_;
    }

    boost::shared_ptr<reaction_recorder_type>& reaction_recorder()
    {
        return rrec_;
    }

    rng_type& rng() const
    {
        return rng_;
    }

    time_type t() const
    {
        return t_;
    }

    time_type dt() const
    {
        return dt_;
    }

    bool const& paranoiac() const
    {
        return paranoiac_;
    }

    bool& paranoiac()
    {
        return paranoiac_;
    }

    int num_steps() const
    {
        return num_steps_;
    }

    virtual void step() = 0;

    virtual bool step(time_type upto) = 0;

protected:
    boost::shared_ptr<world_type> world_;
    boost::shared_ptr<network_rules_type const> network_rules_;
    boost::shared_ptr<reaction_recorder_type> rrec_;
    rng_type& rng_;
    time_type t_;
    time_type dt_;
    int num_steps_;
    bool paranoiac_;
};

#endif /* PARTICLE_SIMULATOR_HPP */
 </xmp> 
<h3> PlanarSurface.hpp </h3> <xmp>

#ifndef PLANAR_SURFACE_HPP
#define PLANAR_SURFACE_HPP

#include <boost/bind.hpp>
#include "Surface.hpp"
#include "Plane.hpp"

template<typename Ttraits_>
class PlanarSurface
    : public BasicSurfaceImpl<Ttraits_, Plane<typename Ttraits_::world_type::traits_type::length_type> >
{
public:
    typedef BasicSurfaceImpl<Ttraits_, Plane<typename Ttraits_::world_type::traits_type::length_type> > base_type;
    typedef typename base_type::traits_type traits_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::shape_type shape_type;
    typedef typename base_type::rng_type rng_type;
    typedef typename base_type::position_type position_type;
    typedef typename base_type::length_type length_type;

    virtual position_type random_position(rng_type& rng) const
    {
        return ::random_position(base_type::shape(), boost::bind(&rng_type::uniform, rng, -1., 1.));
    }

    virtual position_type random_vector(length_type const& r, rng_type& rng) const
    {
        return multiply(
            normalize(
                add(
                    multiply(
                        base_type::shape().units()[0], rng.uniform(-1., 1.)),
                    multiply(
                        base_type::shape().units()[1], rng.uniform(-1., 1.)))), r);
    }

    virtual position_type bd_displacement(length_type const& r, rng_type& rng) const
    {
        length_type const x(rng.normal(0., r)), y(rng.normal(0., r));
        return add(
            multiply(base_type::shape().unit_x(), x),
            multiply(base_type::shape().unit_y(), y));
    }

    virtual length_type minimal_distance(length_type const& radius) const
    {
        // PlanarSurface has thickness of 0.
        return radius * traits_type::MINIMAL_SEPARATION_FACTOR;
    }

    virtual void accept(ImmutativeStructureVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeStructureVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    PlanarSurface(identifier_type const& id, shape_type const& shape)
        : base_type(id, shape) {}
};


#endif /* PLANAR_SURFACE_HPP */
 </xmp> 
<h3> Plane.hpp </h3> <xmp>

#ifndef PLANE_HPP
#define PLANE_HPP

#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/array.hpp>
#include <boost/multi_array.hpp>
#include <utility>
#include <algorithm>
#include "utils/array_helper.hpp"
#include "Shape.hpp"
#include "linear_algebra.hpp"

template<typename T_>
class Plane
{
public:
    typedef T_ value_type;
    typedef Vector3<T_> position_type;
    typedef T_ length_type;

public:
    Plane(position_type const& position = position_type())
        : position_(position),
          units_(array_gen(
            create_vector<position_type>(1., 0., 0.),
            create_vector<position_type>(0., 1., 0.),
            create_vector<position_type>(0., 0., 1.))),
          half_extent_(array_gen<length_type>(0.5, 0.5)) {}

    template<typename Tarray_>
    Plane(position_type const& position, Tarray_ const& half_extent)
        : position_(position),
          units_(array_gen(
            create_vector<position_type>(1., 0., 0.),
            create_vector<position_type>(0., 1., 0.),
            create_vector<position_type>(0., 0., 1.)))
    {
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    template<typename Tarray1, typename Tarray2>
    Plane(position_type const& position,
        Tarray1 const& units, Tarray2 const& half_extent)
        : position_(position)
    {
        std::copy(boost::begin(units), boost::end(units),
                  boost::begin(units_));
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    template<typename Tarray_>
    Plane(position_type const& position,
        position_type const& vx,
        position_type const& vy,
        Tarray_ const& half_extent = array_gen<length_type>(0.5, 0.5))
        : position_(position), units_(array_gen(vx, vy, cross_product(vx, vy)))
    {
        std::copy(boost::begin(half_extent), boost::end(half_extent),
                  boost::begin(half_extent_));
    }

    Plane(position_type const& position,
        position_type const& vx,
        position_type const& vy,
        length_type const& half_lx,
        length_type const& half_ly)
        : position_(position), units_(array_gen(vx, vy, cross_product(vx, vy))),
          half_extent_(array_gen<length_type>(half_lx, half_ly)) {}

    position_type const& position() const
    {
        return position_;
    }

    position_type& position()
    {
        return position_;
    }

    position_type const& unit_x() const
    {
        return units_[0];
    }

    position_type& unit_x()
    {
        return units_[0];
    }

    position_type const& unit_y() const
    {
        return units_[1];
    }

    position_type& unit_y()
    {
        return units_[1];
    }

    position_type const& unit_z() const
    {
        return units_[2];
    }

    position_type& unit_z()
    {
        return units_[2];
    }

    boost::array<position_type, 3> const& units() const
    {
        return units_;
    }

    boost::array<position_type, 3>& units()
    {
        return units_;
    }

    length_type const Lx() const
    { 
        return 2 * half_extent_[0];
    }

    length_type Lx()
    {
        return 2 * half_extent_[0];
    }

    length_type const Ly() const
    {
        return 2 * half_extent_[1];
    }

    length_type Ly()
    {
        return 2 * half_extent_[1];
    }

    boost::array<length_type, 2> const& half_extent() const
    {
        return half_extent_;
    }

    boost::array<length_type, 2>& half_extent()
    {
        return half_extent_;
    }

    bool operator==(const Plane& rhs) const
    {
        return position_ == rhs.position_ && units_ == rhs.units_ &&
               half_extent_ == rhs.half_extent_;
    }

    bool operator!=(const Plane& rhs) const
    {
        return !operator==(rhs);
    }

    std::string show(int precision)
    {
        std::ostringstream strm;
        strm.precision(precision);
        strm << *this;
        return strm.str();
    }

protected:
    position_type position_;
    boost::array<position_type, 3> units_;
    boost::array<length_type, 2> half_extent_;
};

template<typename T_>
inline boost::array<typename Plane<T_>::length_type, 3>
to_internal(Plane<T_> const& obj, typename Plane<T_>::position_type const& pos)
{
    typedef typename Plane<T_>::position_type position_type;
    position_type pos_vector(subtract(pos, obj.position()));

    return array_gen<typename Plane<T_>::length_type>(
        dot_product(pos_vector, obj.unit_x()),
        dot_product(pos_vector, obj.unit_y()),
        dot_product(pos_vector, obj.unit_z()));
}

template<typename T_>
inline std::pair<typename Plane<T_>::position_type,
                 typename Plane<T_>::length_type>
projected_point(Plane<T_> const& obj, typename Plane<T_>::position_type const& pos)
{
    boost::array<typename Plane<T_>::length_type, 3> x_y_z(to_internal(obj, pos));
    return std::make_pair(
        add(add(obj.position(), multiply(obj.unit_x(), x_y_z[0])),
            multiply(obj.unit_y(), x_y_z[1])),
        x_y_z[2]);
}

template<typename T_>
inline typename Plane<T_>::length_type
distance(Plane<T_> const& obj, typename Plane<T_>::position_type const& pos)
{
    typedef typename Plane<T_>::length_type length_type;
    boost::array<length_type, 3> const x_y_z(to_internal(obj, pos));

    length_type const dx(subtract(abs(x_y_z[0]), obj.half_extent()[0]));
    length_type const dy(subtract(abs(x_y_z[1]), obj.half_extent()[1]));

    if (dx < 0 && dy < 0) {
        // Projected point of pos is on the plane.
        // Probably an infinite plane anyway.
        return x_y_z[2];
    }

    if (dx > 0)
    {
        if (dy > 0)
        {
            // Far away from plane.
            return std::sqrt(gsl_pow_2(dx) + gsl_pow_2(dy) +
                             gsl_pow_2(x_y_z[2]));
        }
        else
        {
            return std::sqrt(gsl_pow_2(dx) + gsl_pow_2(x_y_z[2]));
        }
    }
    else
    {
        if (dy > 0)
        {
            return std::sqrt(gsl_pow_2(dy) + gsl_pow_2(x_y_z[2]));
        }
        else
        {
            // Already tested above.
            return x_y_z[2];
        }
    }
}

template<typename T, typename Trng>
inline typename Plane<T>::position_type
random_position(Plane<T> const& shape, Trng& rng)
{
    typedef typename Plane<T>::length_type length_type;

    // -1 < rng() < 1. See for example PlanarSurface.hpp.
    return add(
        shape.position(),
        add(multiply(shape.units()[0], shape.half_extent()[0] * rng()),
            multiply(shape.units()[1], shape.half_extent()[1] * rng())));
}

template<typename T>
inline Plane<T> const& shape(Plane<T> const& shape)
{
    return shape;
}

template<typename T>
inline Plane<T>& shape(Plane<T>& shape)
{
    return shape;
}

template<typename T_>
struct is_shape<Plane<T_> >: public boost::mpl::true_ {};

template<typename T_>
struct shape_position_type<Plane<T_> >
{
    typedef typename Plane<T_>::position_type type;
};

template<typename Tstrm_, typename Ttraits_, typename T_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm,
        const Plane<T_>& v)
{
    strm << "{" << v.position() <<  ", " << v.unit_x() << ", " << v.unit_y() << "," << v.Lx() << ", " << v.Ly() << "}";
    return strm;
}


#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_>
struct hash<Plane<T_> >
{
    typedef Plane<T_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::position_type>()(val.position()) ^
            hash<typename argument_type::position_type>()(val.unit_x()) ^
            hash<typename argument_type::position_type>()(val.unit_y()) ^
            hash<typename argument_type::length_type>()(val.half_extent()[0]) ^
            hash<typename argument_type::length_type>()(val.half_extent()[1]);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* PLANE_HPP */
 </xmp> 
<h3> Point.hpp </h3> <xmp>

#ifndef POINT_HPP
#define POINT_HPP

#include "Shape.hpp"
#include "Vector3.hpp"

template<typename T_>
struct shape_position_type<Vector3<T_> >
{
    typedef Vector3<T_> type;
};

template<typename T_>
struct shape_length_type<Vector3<T_> >
{
    typedef T_ type;
};

template<typename T_>
inline Vector3<T_> shape_position(Vector3<T_> const& v)
{
    return v;
}

#endif /* POINT_HPP */
 </xmp> 
<h3> PyEventScheduler.hpp </h3> <xmp>

#ifndef PY_EVENT_SCHEDULER_HPP
#define PY_EVENT_SCHEDULER_HPP

#include <boost/python.hpp>

#endif /* PY_EVENT_SCHEDULER_HPP */
 </xmp> 
<h3> ReactionRecorder.hpp </h3> <xmp>

#ifndef REACTION_RECORDER_HPP
#define REACTION_RECORDER_HPP

template<typename Trr_>
class ReactionRecorder
{
public:
    typedef Trr_ reaction_record_type;

public:
    virtual ~ReactionRecorder() {}

    virtual void operator()(reaction_record_type const& rec) = 0;
};

#endif /* REACTION_RECORDER_HPP */
 </xmp> 
<h3> ReactionRecord.hpp </h3> <xmp>

#ifndef REACTION_RECORD_HPP
#define REACTION_RECORD_HPP

#include <vector>
#include "twofold_container.hpp"
#include "utils/memberwise_compare.hpp"

template<typename Tpid_, typename Trid_>
class ReactionRecord
{
public:
    typedef Tpid_ particle_id_type;
    typedef Trid_ reaction_rule_id_type;
    typedef std::vector<particle_id_type> products_type;
    typedef twofold_container<particle_id_type> reactants_type;

public:
    ReactionRecord()
        : reaction_rule_id_(), reactants_(), products_() {}

    template<typename Tset>
    ReactionRecord(reaction_rule_id_type const& rid,
                   Tset const& products, 
                   particle_id_type const& p1)
        : reaction_rule_id_(rid), reactants_(p1),
          products_(boost::begin(products), boost::end(products)) {}

    template<typename Tset>
    ReactionRecord(reaction_rule_id_type const& rid,
                   Tset const& products,
                   particle_id_type const& p1, particle_id_type const& p2)
        : reaction_rule_id_(rid), reactants_(p1, p2),
          products_(boost::begin(products), boost::end(products)) {}

    // HEADS UP: move constructor!
    ReactionRecord(ReactionRecord const& that)
    {
        swap(const_cast<ReactionRecord&>(that));
    }

    reaction_rule_id_type const& reaction_rule_id() const
    {
        return reaction_rule_id_;
    }

    reactants_type const& reactants() const
    {
        return reactants_;
    }

    products_type const& products() const
    {
        return products_;
    }

    operator bool() const
    {
        return reactants_.size() != 0;
    }

    bool operator==(ReactionRecord const& rhs) const
    {
        return reaction_rule_id_ == rhs.reaction_rule_id() &&
               memberwise_compare(reactants_, rhs.reactants_) == 0 &&
               memberwise_compare(products_, rhs.products_) == 0;
    }

    bool operator!=(ReactionRecord const& rhs) const
    {
        return !operator==(rhs);
    }

    void swap(ReactionRecord& that)
    {
        std::swap(reaction_rule_id_, that.reaction_rule_id_);
        reactants_.swap(that.reactants_);
        products_.swap(that.products_);
    }

protected:
    reaction_rule_id_type reaction_rule_id_;
    reactants_type reactants_;
    products_type products_;
};

template<typename Tchar, typename Ttraits, typename Tpid, typename Trid>
inline std::basic_ostream<Tchar, Ttraits>&
operator<<(std::basic_ostream<Tchar, Ttraits>& out,
           ReactionRecord<Tpid, Trid> const& r)
{
    bool first;
    out << "ReactionRecord(reaction_rule_id=" << r.reaction_rule_id() << ", ";
    out << "reactants={";
    typedef typename ReactionRecord<Tpid, Trid>::reactants_type reactants_type;
    typedef typename ReactionRecord<Tpid, Trid>::products_type products_type;
    reactants_type const& reactants(r.reactants());
    for (typename boost::range_const_iterator<reactants_type>::type
            i(boost::begin(reactants)), e(boost::end(reactants));
         i != e; ++i)
    {
        if (!first)
        {
            out << ", ";
        }
        out << *i;
        first = false;
    }
    out << "}, products={";
    first = true;
    products_type const& products(r.products());
    for (typename boost::range_const_iterator<products_type>::type
                i(boost::begin(products)), e(boost::end(products));
         i != e; ++i)
    {
        if (!first)
        {
            out << ", ";
        }
        out << *i;
        first = false;
    }
    out << "})";
    return out;
}

#endif /* REACTION_RECORD_HPP */
 </xmp> 
<h3> ReactionRule.hpp </h3> <xmp>

#ifndef REACTION_RULE_HPP
#define REACTION_RULE_HPP

#include <vector>
#include <ostream>
#include <algorithm>

#include <boost/format.hpp>
#include <boost/bind.hpp>
#include <boost/range/size.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/range/iterator_range.hpp>

#include "Defs.hpp"
#include "utils/get_mapper_mf.hpp"
#include "utils/range_support.hpp"
#include "exceptions.hpp"
#include "utils.hpp"
#include "SpeciesTypeID.hpp"
#include "twofold_container.hpp"
#include "utils/memberwise_compare.hpp"

class NetworkRules;

class ReactionRule
{
public:
    typedef SpeciesTypeID species_type_id_type;

private:
    typedef std::vector<species_type_id_type> species_type_id_vector;
    typedef get_mapper_mf<std::string, std::string>::type string_map_type;

public:
    typedef int identifier_type; 
    typedef string_map_type::const_iterator string_map_iterator;
    typedef boost::iterator_range<string_map_iterator> attributes_range;

    typedef species_type_id_vector::const_iterator species_type_id_iterator;
    typedef boost::iterator_range<species_type_id_iterator> species_type_id_range;
    typedef twofold_container<SpeciesTypeID> Reactants;

public:
    Reactants const& get_reactants() const
    {
        return reactants_;
    }

    void add_product(SpeciesTypeID const& s)
    {
        products_.insert(
            std::lower_bound(products_.begin(), products_.end(), s),
            s);
    }

    species_type_id_range get_products() const
    {
        return products_;
    }

    identifier_type const& id() const
    {
        return id_;
    }

    // package-private
    identifier_type const& set_id(identifier_type const& val) const
    {
        id_ = val;
        return id_;
    }

    std::string const& operator[](std::string const& name) const
    {
        string_map_type::const_iterator i(attrs_.find(name));
        if (i == attrs_.end())
            throw not_found((boost::format("key %s not found") % name).str());
        return (*i).second;
    }

    std::string& operator[](std::string const& name)
    {
        return attrs_[name];
    }

    attributes_range attributes() const
    {
        return attributes_range(attrs_.begin(), attrs_.end());
    }

    ReactionRule()
        : id_(), reactants_() {}

    explicit ReactionRule(Reactants const& _reactants)
        : id_(), reactants_(_reactants) {}

    template<typename Trange_>
    ReactionRule(Reactants const& _reactants, Trange_ const& products)
        : id_(), reactants_(_reactants)
    {
        BOOST_ASSERT(reactants_.size() > 0);
        std::for_each(boost::begin(products), boost::end(products),
                boost::bind(&ReactionRule::add_product, this, _1));
        std::stable_sort(products_.begin(), products_.end());
    }

private:
    mutable identifier_type id_;
    Reactants reactants_;
    species_type_id_vector products_;
    Real k_;
    string_map_type attrs_;
};

inline bool operator<(ReactionRule const& lhs, ReactionRule const& rhs)
{
    int tmp = memberwise_compare(lhs.get_reactants(), rhs.get_reactants());
    if (tmp > 0)
    {
        return false;
    }
    else if (tmp < 0)
    {
        return true;
    }
    return memberwise_compare(lhs.get_products(), rhs.get_products()) < 0;
}

inline bool operator==(ReactionRule const& lhs, ReactionRule const& rhs)
{
    return lhs.get_reactants() == rhs.get_reactants() &&
            memberwise_compare(lhs.get_products(), rhs.get_products()) == 0;
}

inline bool operator!=(ReactionRule const& lhs, ReactionRule const& rhs)
{
    return !(lhs == rhs);
}

template<typename T2_>
inline ReactionRule new_reaction_rule(SpeciesTypeID const& r1, T2_ const& products, Real k)
{
    ReactionRule retval((ReactionRule::Reactants(r1)));
    retval["k"] = boost::lexical_cast<std::string>(k);
    std::for_each(boost::begin(products), boost::end(products),
            boost::bind(&ReactionRule::add_product, &retval, _1));
    return retval;
}

template<typename T2_>
inline ReactionRule new_reaction_rule(SpeciesTypeID const& r1, SpeciesTypeID const& r2, T2_ const& products, Real k)
{
    ReactionRule retval(ReactionRule::Reactants(r1, r2));
    retval["k"] = boost::lexical_cast<std::string>(k);
    std::for_each(boost::begin(products), boost::end(products),
            boost::bind(&ReactionRule::add_product, &retval, _1));
    return retval;
}

inline bool valid(ReactionRule const& r)
{
    return r.get_reactants().size() != 0;
}

template<typename Tchar_, typename Ttraits_>
inline std::basic_ostream<Tchar_, Ttraits_>&
operator<<(std::basic_ostream<Tchar_, Ttraits_>& out, ReactionRule const& r)
{
    bool first;
    out << "ReactionRule(id=" << r.id() << ", reactants={";
    first = true;
    ReactionRule::Reactants const& reactants(r.get_reactants());
    ReactionRule::species_type_id_range products(r.get_products());
    for (typename boost::range_const_iterator<ReactionRule::Reactants>::type
            i(boost::begin(reactants)), e(boost::end(reactants));
         i != e; ++i)
    {
        if (!first)
        {
            out << ", ";
        }
        out << *i;
        first = false;
    }
    out << "}, products={";
    first = true;
    for (typename boost::range_const_iterator<
            ReactionRule::species_type_id_range>::type
                i(boost::begin(products)), e(boost::end(products));
         i != e; ++i)
    {
        if (!first)
        {
            out << ", ";
        }
        out << *i;
        first = false;
    }
    out << "})";
    return out;
}

#endif /* REACTION_RULE_HPP */
 </xmp> 
<h3> ReactionRuleInfo.hpp </h3> <xmp>

#ifndef REACTION_RULE_INFO_HPP
#define REACTION_RULE_INFO_HPP

#include <vector>
#include <algorithm>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include "twofold_container.hpp"

template<typename Tid_, typename Tsid_, typename Trate_>
class ReactionRuleInfo
{
public:
    typedef Tsid_ species_id_type;

private:
    typedef std::vector<species_id_type> species_id_vector;

public:
    typedef species_id_vector species_id_range;
    typedef Tid_ identifier_type;
    typedef Trate_ rate_type;

    identifier_type const& id() const
    {
        return id_;
    }

    species_id_range const& get_products() const
    {
        return products_;
    }

    twofold_container<species_id_type> const& get_reactants() const
    {
        return reactants_;
    }

    rate_type k() const
    {
        return k_;
    }

    template<typename Tr1_, typename Tr2_>
    ReactionRuleInfo(identifier_type const& id, rate_type const& k,
            Tr1_ const& reactants, Tr2_ const& products)
        : id_(id), k_(k)
    {
        std::copy(boost::begin(reactants),
                boost::end(reactants),
                std::back_inserter(reactants_));
        std::copy(boost::begin(products),
                boost::end(products),
                std::back_inserter(products_));
    }

    ReactionRuleInfo(): id_(), k_(), reactants_(), products_() {}

    bool operator==(ReactionRuleInfo const& rhs) const
    {
        return id_ == rhs.id();
    }

private:
    identifier_type id_;
    rate_type k_;
    twofold_container<species_id_type> reactants_;
    species_id_vector products_;
};

template<typename Tid, typename Tsid, typename Trate>
inline bool valid(ReactionRuleInfo<Tid, Tsid, Trate> const& r)
{
    return r.get_reactants().size() != 0;
}

#endif /* REACTION_RULE_INFO_HPP */
 </xmp> 
<h3> Region.hpp </h3> <xmp>

#ifndef REGION_HPP
#define REGION_HPP

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

#include <sstream>
#include "ParticleSimulationStructure.hpp"
#include "Box.hpp"

template<typename Ttraits_>
class Region: public ParticleSimulationStructure<Ttraits_>
{
public:
    typedef ParticleSimulationStructure<Ttraits_> base_type;
    typedef typename base_type::identifier_type identifier_type;

public:
    virtual ~Region() {}

    Region(identifier_type const& id): base_type(id) {}
};

template<typename Ttraits_, typename Tshape_>
class BasicRegionImpl: public Region<Ttraits_>
{
public:
    typedef Region<Ttraits_> base_type;
    typedef Tshape_ shape_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::length_type length_type;
    typedef typename base_type::position_type position_type;

public:
    virtual ~BasicRegionImpl() {}

    shape_type& shape()
    {
        return shape_;
    }

    shape_type const& shape() const
    {
        return shape_;
    }

    virtual bool operator==(Structure<typename Ttraits_::world_type::traits_type> const& rhs) const
    {
        BasicRegionImpl const* _rhs(dynamic_cast<BasicRegionImpl const*>(&rhs));
        return _rhs && base_type::id_ == rhs.id() && shape_ == _rhs->shape();
    }

    virtual std::size_t hash() const
    {
#if defined(HAVE_TR1_FUNCTIONAL)
        using std::tr1::hash;
#elif defined(HAVE_STD_HASH)
        using std::hash;
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
        using boost::hash;
#endif
        return hash<identifier_type>()(base_type::id_) ^ hash<shape_type>()(shape());
    }

    virtual std::string as_string() const
    {
        std::ostringstream out;
        out << "Region(" << base_type::id_ << ":" << shape() << ")";
        return out.str();
    }

    std::pair<position_type, length_type>
    projected_point(position_type const& pos) const
    {
        return ::projected_point(shape(), pos);
    }

    BasicRegionImpl(identifier_type const& id, shape_type const& shape)
        : base_type(id), shape_(shape) {}

protected:
    shape_type shape_;
};

#endif /* REGION_HPP */
 </xmp> 
<h3> SerialIDGenerator.hpp </h3> <xmp>

#ifndef SERIAL_ID_GENERATOR_HPP
#define SERIAL_ID_GENERATOR_HPP

#include <functional>
#include <boost/type_traits/is_integral.hpp>

namespace detail {

template<bool Vis_integral, typename Tid_>
struct identifier_lot_helper
{
    typedef typename Tid_::lot_type type;
};

template<typename Tid_>
struct identifier_lot_helper<true, Tid_>
{
    typedef Tid_ type;
};

template<bool Vis_integral, typename Tid_>
struct identifier_lot_adder_helper: public std::binary_function<
        Tid_, typename Tid_::lot_type, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, typename Tid_::lot_type rhs)
    {
        return lhs.lot_add(rhs);
    }
};

template<typename Tid_>
struct identifier_lot_adder_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs + rhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_lot_subtractor_helper: public std::binary_function<
        Tid_, typename Tid_::lot_type, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs.lot_subtract(rhs);
    }
};

template<typename Tid_>
struct identifier_lot_subtractor_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs - rhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_lot_advancer_helper: public std::binary_function<
        Tid_&, typename Tid_::lot_type, Tid_&>
{
    Tid_& operator()(Tid_& lhs, typename Tid_::lot_type const& rhs)
    {
        lhs.lot_advance(rhs);
        return lhs;
    }
};

template<typename Tid_>
struct identifier_lot_advancer_helper<true, Tid_>: public std::binary_function<
        Tid_&, Tid_, Tid_&>
{
    Tid_& operator()(Tid_& lhs, Tid_ const& rhs)
    {
        lhs += rhs;
        return lhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_lot_retracer_helper: public std::binary_function<
        Tid_&, typename Tid_::lot_type, Tid_&>
{
    Tid_& operator()(Tid_& lhs, typename Tid_::lot_type const& rhs)
    {
        lhs.lot_retrace(rhs);
        return lhs;
    }
};

template<typename Tid_>
struct identifier_lot_retracer_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_& operator()(Tid_& lhs, Tid_ const& rhs)
    {
        lhs -= rhs;
        return lhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_lot_retriever_helper: public std::binary_function<
        Tid_&, typename Tid_::lot_type, Tid_&>
{
    typename identifier_lot_helper<Vis_integral, Tid_>::type const& operator()(Tid_ const& lhs)
    {
        return lhs.lot();
    }
};

template<typename Tid_>
struct identifier_lot_retriever_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    typename identifier_lot_helper<true, Tid_>::type& operator()(Tid_& lhs)
    {
        return lhs & ((1 << (8 * sizeof(Tid_) / 2)) - 1);
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_helper
{
    typedef typename Tid_::serial_type type;
};

template<typename Tid_>
struct identifier_serial_helper<true, Tid_>
{
    typedef Tid_ type;
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_adder_helper: public std::binary_function<
        Tid_, typename Tid_::serial_type, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, typename Tid_::serial_type rhs)
    {
        return lhs.serial_add(rhs);
    }
};

template<typename Tid_>
struct identifier_serial_adder_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs + (rhs << (8 * sizeof(Tid_) / 2));
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_subtractor_helper: public std::binary_function<
        Tid_, typename Tid_::serial_type, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs.serial_subtract(rhs);
    }
};

template<typename Tid_>
struct identifier_serial_subtractor_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_ operator()(Tid_ const& lhs, Tid_ const& rhs)
    {
        return lhs - (rhs << (8 * sizeof(Tid_) / 2));
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_advancer_helper: public std::binary_function<
        Tid_&, typename Tid_::serial_type, Tid_&>
{
    Tid_& operator()(Tid_& lhs, typename Tid_::serial_type const& rhs)
    {
        lhs.serial_advance(rhs);
        return lhs;
    }
};

template<typename Tid_>
struct identifier_serial_advancer_helper<true, Tid_>: public std::binary_function<
        Tid_&, Tid_, Tid_&>
{
    Tid_& operator()(Tid_& lhs, Tid_ const& rhs)
    {
        lhs += rhs << (8 * sizeof(Tid_) / 2);
        return lhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_retracer_helper: public std::binary_function<
        Tid_&, typename Tid_::serial_type, Tid_&>
{
    Tid_& operator()(Tid_& lhs, typename Tid_::serial_type const& rhs)
    {
        lhs.serial_retrace(rhs);
        return lhs;
    }
};

template<typename Tid_>
struct identifier_serial_retracer_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    Tid_& operator()(Tid_& lhs, Tid_ const& rhs)
    {
        lhs -= rhs << (8 * sizeof(Tid_) / 2);
        return lhs;
    }
};

template<bool Vis_integral, typename Tid_>
struct identifier_serial_retriever_helper: public std::binary_function<
        Tid_&, typename Tid_::serial_type, Tid_&>
{
    typename identifier_serial_helper<Vis_integral, Tid_>::type const& operator()(Tid_ const& lhs)
    {
        return lhs.serial();
    }
};

template<typename Tid_>
struct identifier_serial_retriever_helper<true, Tid_>: public std::binary_function<
        Tid_, Tid_, Tid_>
{
    typename identifier_serial_helper<true, Tid_>::type& operator()(Tid_& lhs)
    {
        return lhs & ((1 << (8 * sizeof(Tid_) / 2)) - 1);
    }
};

} // namespace detail

template<typename Tid_>
struct identifier_lot: public detail::identifier_lot_helper<
        boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_lot_adder
        : public detail::identifier_lot_adder_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_lot_subtractor
        : public detail::identifier_lot_subtractor_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_lot_advancer
        : public detail::identifier_lot_advancer_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_lot_retracer
        : public detail::identifier_lot_retracer_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_lot_retriever
        : public detail::identifier_lot_retriever_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial: public detail::identifier_serial_helper<
        boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial_adder
        : public detail::identifier_serial_adder_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial_subtractor
        : public detail::identifier_serial_subtractor_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial_advancer
        : public detail::identifier_serial_advancer_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial_retracer
        : public detail::identifier_serial_retracer_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
struct identifier_serial_retriever
        : public detail::identifier_serial_retriever_helper<
            boost::is_integral<Tid_>::value, Tid_>
{
};

template<typename Tid_>
Tid_ lot_add(Tid_ const& lhs, typename identifier_lot<Tid_>::type const& rhs)
{
    return identifier_lot_adder<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_ lot_subtract(Tid_ const& lhs, typename identifier_lot<Tid_>::type const& rhs)
{
    return identifier_lot_subtractor<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_& lot_advance(Tid_& lhs, typename identifier_lot<Tid_>::type const& rhs)

{
    return identifier_lot_advancer<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_& lot_retrace(Tid_& lhs, typename identifier_lot<Tid_>::type const& rhs)
{
    return identifier_lot_retracer<Tid_>()(lhs, rhs);
}

template<typename Tid_>
typename identifier_lot<Tid_>::type lot(Tid_& lhs)
{
    return identifier_lot_retriever<Tid_>()(lhs);
}

template<typename Tid_>
Tid_ serial_add(Tid_ const& lhs, typename identifier_serial<Tid_>::type const& rhs)
{
    return identifier_serial_adder<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_ serial_subtract(Tid_ const& lhs, typename identifier_serial<Tid_>::type const& rhs)
{
    return identifier_serial_subtractor<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_& serial_advance(Tid_& lhs, typename identifier_serial<Tid_>::type const& rhs)
{
    return identifier_serial_advancer<Tid_>()(lhs, rhs);
}

template<typename Tid_>
Tid_& serial_retrace(Tid_& lhs, typename identifier_serial<Tid_>::type const& rhs)
{
    return identifier_serial_retracer<Tid_>()(lhs, rhs);
}

template<typename Tid_>
typename identifier_serial<Tid_>::type serial(Tid_& lhs)
{
    return identifier_serial_retriever<Tid_>()(lhs);
}

template<typename Tid_>
struct SerialIDGenerator
{
    typedef Tid_ identifier_type;
    typedef typename identifier_lot<identifier_type>::type lot_type;

    SerialIDGenerator(lot_type const& lot = lot_type())
        : next_(lot_add(identifier_type(), lot))
    {
    }

    identifier_type operator()()
    {
        return serial_advance(next_, 1);
    }

private:
    identifier_type next_;
};

#endif /* SERIAL_ID_GENERATOR_HPP */
 </xmp> 
<h3> ShapedDomain.hpp </h3> <xmp>

#ifndef SHAPED_DOMAIN_HPP
#define SHAPED_DOMAIN_HPP

#include "Domain.hpp"

template<typename Ttraits_>
class ShapedDomain: public Domain<Ttraits_>
{
public:
    typedef Ttraits_ traits_type;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::traits_type::position_type position_type;
    typedef Domain<Ttraits_> base_type;

public:
    virtual ~ShapedDomain() {}

    virtual position_type const& position() const = 0;

    virtual position_type& position() = 0;

    virtual length_type const& size() const = 0;

    virtual length_type& size() = 0;

    ShapedDomain(identifier_type const& id)
        : base_type(id) {}
};

#endif /* SHAPED_DOMAIN_HPP */
 </xmp> 
<h3> Shape.hpp </h3> <xmp>

#ifndef SHAPE_HPP
#define SHAPE_HPP

#include <boost/type_traits/remove_cv.hpp>
#include "Vector3.hpp"

template<typename Tobj_>
inline typename Tobj_::shape_type const& shape(Tobj_ const& obj)
{
    return obj.shape();
}

template<typename Tobj_>
inline typename Tobj_::shape_type& shape(Tobj_& obj)
{
    return obj.shape();
}

template<typename Tshape_>
inline Tshape_ offset(Tshape_ const& shape, typename Tshape_::position_type off)
{
    Tshape_ retval(shape);
    retval.position() += off;
    return retval;
}

template<typename Tshape_>
struct is_shape: public boost::mpl::false_ {};

template<typename T_>
struct shape_position_type
{
    struct argument_is_not_a_shape;
    static const std::size_t x = sizeof(argument_is_not_a_shape);
};

template<typename T_>
struct shape_length_type
{
    typedef typename element_type_of<typename shape_position_type<typename boost::remove_cv<T_>::type >::type>::type type;
};

template<typename T_>
inline typename shape_position_type<T_>::type const& shape_position(T_ const& shape)
{
    return shape.position();
}

template<typename T_>
inline typename shape_position_type<T_>::type& shape_position(T_& shape)
{
    return shape.position();
}

template<typename T_>
inline typename shape_length_type<T_>::type const& shape_size(T_ const& shape)
{
}

template<typename T_>
inline typename shape_length_type<T_>::type& shape_size(T_& shape)
{
}

template< typename T1_, typename T2_ >
inline typename shape_length_type<T1_>::type
distance_cyclic(
        T1_ const& p1, T2_ const& p2,
        typename shape_length_type<T1_>::type const& world_size,
        typename boost::enable_if<is_shape<T1_> >::type* = 0)
{
    return distance(p1, cyclic_transpose(p2, shape_position(p1), world_size));
}

template<typename T, typename Trng>
inline typename shape_position_type<T>::type
random_position(T const& shape, Trng const& rng)
{
    return random_position(shape, const_cast<Trng&>(rng));
}

#endif /* SHAPE_HPP */
 </xmp> 
<h3> Shell.hpp </h3> <xmp>

#ifndef SHELL_HPP
#define SHELL_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

template<typename Tshape_, typename Tdid_>
struct Shell
{
    typedef Tshape_ shape_type;
    typedef Tdid_ domain_id_type;
    typedef typename shape_type::position_type position_type;
    typedef typename shape_type::length_type length_type;

    Shell(): domain_id_(), shape_() {}

    Shell(domain_id_type const& domain_id, shape_type const& shape)
        : domain_id_(domain_id), shape_(shape) {}

    position_type& position()
    {
        return shape_.position();
    }

    position_type const& position() const
    {
        return shape_.position();
    }

    shape_type& shape()
    {
        return shape_;
    }

    shape_type const& shape() const
    {
        return shape_;
    }

    domain_id_type const& did() const
    {
        return domain_id_;
    }

    domain_id_type& did()
    {
        return domain_id_;
    }

    bool operator==(Shell const& rhs) const
    {
        return domain_id_ == rhs.did() && shape_ == rhs.shape();
    }

    bool operator!=(Shell const& rhs) const
    {
        return !operator==(rhs);
    }

private:
    domain_id_type domain_id_;
    shape_type shape_;
};

template<typename Tstrm_, typename Ttraits_, typename Tshape_, typename Tdid_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm, const Shell<Tshape_, Tdid_>& v)
{
    strm << "Shell(" << v.shape() << ", " << v.did() << ")";
    return strm;
}

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename Tshape_, typename Tdid_>
struct hash<Shell<Tshape_, Tdid_> >
{
    typedef Shell<Tshape_, Tdid_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::shape_type>()(val.shape()) ^
            hash<typename argument_type::domain_id_type>()(val.did());
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* SHELL_HPP */
 </xmp> 
<h3> ShellID.hpp </h3> <xmp>

#ifndef SHELL_ID_HPP
#define SHELL_ID_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif
#include "Identifier.hpp"

struct ShellID: public Identifier<ShellID, unsigned long long, int>
{
    typedef Identifier<ShellID, unsigned long long, int> base_type;

    ShellID(value_type const& value = value_type(0, 0))
        : base_type(value) {}
};

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<>
struct hash<ShellID>
{
    std::size_t operator()(ShellID const& val) const
    {
        return static_cast<std::size_t>(val().first ^ val().second);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

template<typename Tstrm_>
inline std::basic_ostream<Tstrm_>& operator<<(std::basic_ostream<Tstrm_>& strm,
        const ShellID& v)
{
    strm << "ShellID(" << v().first << ":" << v().second << ")";
    return strm;
}

#endif /* SHELL_ID_HPP */
 </xmp> 
<h3> Single.hpp </h3> <xmp>

#ifndef SINGLE_HPP
#define SINGLE_HPP

#include <utility>
#include "ShapedDomain.hpp"

template<typename Ttraits_>
class Single: public ShapedDomain<Ttraits_>
{
public:
    typedef ShapedDomain<Ttraits_> base_type;
    typedef Ttraits_ traits_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::traits_type::position_type position_type;
    typedef typename traits_type::world_type::particle_id_pair particle_id_pair;
    typedef typename traits_type::domain_id_type identifier_type;
    typedef typename traits_type::world_type::traits_type::D_type D_type;

public:
    virtual ~Single() {}

    Single(identifier_type const& id,
           particle_id_pair const& particle)
        : base_type(id), particle_(particle) {}

    particle_id_pair const& particle() const
    {
        return particle_;
    }

    particle_id_pair& particle()
    {
        return particle_;
    }

    D_type const& D() const
    {
        return particle_.second.D();
    }

protected:
    particle_id_pair particle_;
};

#endif /* SINGLE_HPP */
 </xmp> 
<h3> sorted_list.hpp </h3> <xmp>

#ifndef _SORTED_LIST
#define _SORTED_LIST

#include <algorithm>
#include <functional>
#include <boost/call_traits.hpp>
#include <boost/range/size.hpp>
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/range/rbegin.hpp>
#include <boost/range/rend.hpp>
#include <boost/range/value_type.hpp>
#include <boost/range/size_type.hpp>
#include <boost/range/difference_type.hpp>
#include <boost/range/iterator.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/reverse_iterator.hpp>
#include <boost/range/const_reverse_iterator.hpp>
#include "utils/fun_composition.hpp"

template<typename Tcntnr_, typename TweakOrdering_ = std::less<typename boost::range_value<Tcntnr_>::type>, typename Tholder_ = Tcntnr_>
class sorted_list
{
public:
    typedef Tcntnr_ container_type;
	typedef Tholder_ holder_type;
    typedef typename boost::range_value<container_type>::type value_type;
    typedef typename boost::range_size<container_type>::type size_type;
    typedef typename boost::range_difference<container_type>::type difference_type;
    typedef typename boost::range_iterator<container_type>::type iterator;
    typedef typename boost::range_const_iterator<container_type>::type const_iterator;
    typedef typename boost::range_reverse_iterator<container_type>::type reverse_iterator;
    typedef typename boost::range_const_reverse_iterator<container_type>::type const_reverse_iterator;

    typedef value_type* pointer;
    typedef value_type const* const_pointer;
    typedef value_type& reference;
    typedef value_type const& const_reference;

    size_type size() const
    {
        return boost::size(static_cast<container_type const&>(cntnr_));
    }

    iterator begin()
    {
        return boost::begin(static_cast<container_type&>(cntnr_));
    }

    const_iterator begin() const
    {
        return boost::begin(static_cast<container_type const&>(cntnr_));
    }

    iterator end()
    {
        return boost::end(static_cast<container_type&>(cntnr_));
    }

    const_iterator end() const
    {
        return boost::end(static_cast<container_type const&>(cntnr_));
    }

    reverse_iterator rbegin()
    {
        return boost::rbegin(static_cast<container_type&>(cntnr_));
    }

    const_reverse_iterator rbegin() const
    {
        return boost::rbegin(static_cast<container_type const&>(cntnr_));
    }

    reverse_iterator rend()
    {
        return boost::rend(static_cast<container_type&>(cntnr_));
    }

    const_reverse_iterator rend() const
    {
        return boost::end(static_cast<container_type const&>(cntnr_));
    }

    void push(value_type const& v)
    {
        iterator i(std::upper_bound(begin(), end(), v,
                static_cast<TweakOrdering_ const&>(ord_)));
        static_cast<container_type&>(cntnr_).insert(i, v);
    }

    bool push_no_duplicate(value_type const& v)
    {
        iterator i(std::upper_bound(begin(), end(), v,
                static_cast<TweakOrdering_ const&>(ord_)));
        if (i != begin())
        {
            if (*--i == v)
                return false;
            ++i;
        }
        static_cast<container_type&>(cntnr_).insert(i, v);
        return true;
    }

    bool update(value_type const& v)
    {
        iterator i(std::upper_bound(begin(), end(), v,
                static_cast<TweakOrdering_ const&>(ord_)));
        if (i != begin())
        {
            if (*--i == v)
            {
                value_type _v(v);
                std::swap(*i, _v);
                return false;
            }
            ++i;
        }
        static_cast<container_type&>(cntnr_).insert(i, v);
        return true;
    }


    void erase(iterator const& i)
    {
        static_cast<container_type&>(cntnr_).erase(i);
    }

    iterator find(value_type const& v)
    {
        iterator i(std::lower_bound(begin(), end(), v,
                static_cast<TweakOrdering_ const&>(ord_)));
        return i != end() && *i == v ? i: end();
    }

    const_iterator find(value_type const& v) const
    {
        const_iterator i(std::lower_bound(begin(), end(), v,
                static_cast<TweakOrdering_ const&>(ord_)));
        return i != end() && *i == v ? i: end();
    }

    reverse_iterator rfind(value_type const& v)
    {
        reverse_iterator i(std::upper_bound(rbegin(), rend(), v,
                compose_binary(std::logical_not<bool>(),
                    static_cast<TweakOrdering_ const&>(ord_))));
        return i != rend() && *i == v ? i: rend();
    }

    const_reverse_iterator rfind(value_type const& v) const
    {
        const_reverse_iterator i(std::upper_bound(rbegin(), rend(), v,
                compose_binary(std::logical_not<bool>(),
                    static_cast<TweakOrdering_ const&>(ord_))));
        return i != rend() && *i == v ? i: rend();
    }

    size_type erase(value_type const& v)
    {
        iterator e(end());
        std::pair<iterator, iterator> i(std::equal_range(begin(), e, v,
                static_cast<TweakOrdering_ const&>(ord_)));
        const size_type retval(i.second - i.first);
        static_cast<container_type&>(cntnr_).erase(i.first, i.second);
        return retval;
    }

    void clear()
    {
        static_cast<container_type&>(cntnr_).clear();
    }

	holder_type& container()
	{
		return cntnr_;
	}

	holder_type const& container() const
	{
		return cntnr_;
	}

    sorted_list(typename boost::call_traits<TweakOrdering_>::param_type ord,
			    typename boost::call_traits<holder_type>::param_type holder)
		: ord_(ord), cntnr_(holder) {}

    explicit sorted_list(typename boost::call_traits<holder_type>::param_type const& holder)
		: ord_(), cntnr_(holder) {}

    explicit sorted_list(typename boost::call_traits<TweakOrdering_>::param_type ord): ord_(ord) {}

    sorted_list(): ord_() {}

private:
    TweakOrdering_ ord_;
    holder_type cntnr_;
};

#endif /* SORTED_LIST */
 </xmp> 
<h3> SpeciesInfo.hpp </h3> <xmp>

#ifndef SPECIES_INFO_HPP
#define SPECIES_INFO_HPP

#include <set>
#include <string>
#include <ostream>
#include "Defs.hpp"

template<typename Tid_, typename TD_, typename Tlen_, typename Tstructure_id_>
struct SpeciesInfo
{
    typedef Tid_ identifier_type;
    typedef TD_ D_type;
    typedef TD_ v_type;
    typedef Tlen_ length_type;
    typedef Tstructure_id_ structure_id_type;

    identifier_type const& id() const
    {
        return id_;
    }

    length_type const& radius() const
    {
        return radius_;
    }

    length_type& radius()
    {
        return radius_;
    }

    structure_id_type const& structure_id() const
    {
        return structure_id_;
    }

    structure_id_type& structure_id()
    {
        return structure_id_;
    }

    D_type const& D() const
    {
        return diffusion_coef_;
    }

    D_type& D()
    {
        return diffusion_coef_;
    }
    
    v_type const& v() const
    {
        return drift_velocity_;
    }

    v_type& v()
    {
        return drift_velocity_;
    }

    bool operator==(SpeciesInfo const& rhs) const
    {
        return id_ == rhs.id() && diffusion_coef_ == rhs.D() && drift_velocity_ == rhs.v() &&
                radius_ == rhs.radius() && structure_id_ == rhs.structure_id();
    }

    bool operator!=(SpeciesInfo const& rhs) const
    {
        return !operator==(rhs);
    }

    SpeciesInfo() {}

    SpeciesInfo(identifier_type const& id, D_type const& D = 0., 
                length_type const& r = 0., structure_id_type const& s = "", v_type const& v = 0.) 
        : id_(id), diffusion_coef_(D), drift_velocity_(v), radius_(r), structure_id_(s) {}
  

private:
    identifier_type id_;
    D_type diffusion_coef_;
    v_type drift_velocity_;
    length_type radius_;
    structure_id_type structure_id_;
};

template<typename Tchar_, typename Ttraits_, typename Tid_, typename TD_, typename Tlen_, typename Tstructure_id_>
inline std::basic_ostream<Tchar_, Ttraits_>&
operator<<(std::basic_ostream<Tchar_, Ttraits_>& strm, const SpeciesInfo<Tid_, TD_, Tlen_, Tstructure_id_>& s)
{
    strm << "SpeciesInfo(id=" << s.id() << ", D=" << s.D() << ", v=" << s.v() << ", radius=" << s.radius() << ", surface=" << s.structure_id() << ")";
    return strm;
}

#endif /* SPECIES_INFO_HPP */
 </xmp> 
<h3> SpeciesType.hpp </h3> <xmp>

#ifndef SPECIES_TYPE_HPP
#define SPECIES_TYPE_HPP

#include <ostream>
#include <string>
#include <boost/format.hpp>
#include <boost/range/value_type.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/iterator_range.hpp>

#include "SpeciesTypeID.hpp"

#include "exceptions.hpp"
#include "utils/get_mapper_mf.hpp"

class Model;

class SpeciesType
{
    friend class Model;
private:
    typedef get_mapper_mf<std::string, std::string>::type string_map_type;

public:
    typedef SpeciesTypeID identifier_type;
    typedef string_map_type::const_iterator string_map_iterator;
    typedef boost::iterator_range<string_map_iterator> attributes_range;

public:
    identifier_type const& id() const;

    std::string const& operator[](std::string const& name) const;

    std::string& operator[](std::string const& name);

    attributes_range attributes() const;

    Model* model() const
    {
        return model_;
    }

    SpeciesType(): model_(0) {}
 
protected:
    void bind_to_model(Model* model, identifier_type const& id)
    {
        model_ = model; 
        id_ = id;
    }

private:
    Model* model_;
    identifier_type id_;
    string_map_type attrs_;
};

template<typename Tchar_, typename Ttraits_>
inline std::basic_ostream<Tchar_, Ttraits_>&
operator<<(std::basic_ostream<Tchar_, Ttraits_>& out, const SpeciesType& v)
{
    bool first = true;
    out << "SpeciesType(id=" << v.id() << ", attributes={";

    typename SpeciesType::attributes_range attributes(v.attributes());
    for (typename boost::range_const_iterator<
        typename SpeciesType::attributes_range>::type
            i(attributes.begin()), e(attributes.end()); i != e; ++i)
    {
        typename boost::range_value<typename SpeciesType::attributes_range>::type
                const& pair(*i);
        if (!first)
            out << ", ";
        out << pair.first << ":" << pair.second;
        first = false;
    }
    out << "})";
    return out;
}

#endif /* SPECIES_TYPE_HPP */
 </xmp> 
<h3> SpeciesTypeID.hpp </h3> <xmp>

#ifndef SPECIES_TYPE_ID_HPP
#define SPECIES_TYPE_ID_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif
#include "Identifier.hpp"

struct SpeciesTypeID: public Identifier<SpeciesTypeID, unsigned long long, int>
{
    typedef Identifier<SpeciesTypeID, unsigned long long, int> base_type;

    SpeciesTypeID(value_type const& value = value_type(0, 0))
        : base_type(value) {}
};

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<>
struct hash<SpeciesTypeID>
{
    std::size_t operator()(SpeciesTypeID const& val) const
    {
        return static_cast<std::size_t>(val().first ^ val().second);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

template<typename Tstrm_, typename Ttraits_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm,
        const SpeciesTypeID& v)
{
    strm << "SID(" << v().first << ":" << v().second << ")";
    return strm;
}

#endif /* SPECIES_TYPE_ID_HPP */
 </xmp> 
<h3> Sphere.hpp </h3> <xmp>

#ifndef SPHERE_HPP
#define SPHERE_HPP

#include <ostream>
#include "Vector3.hpp"
#include "Shape.hpp"

template<typename T_>
class Sphere
{
public:
    typedef T_ value_type;
    typedef Vector3<T_> position_type;
    typedef T_ length_type;

public:
    Sphere()
        : position_(), radius_(0) {}

    Sphere(const position_type& position, const length_type& radius)
        : position_(position), radius_(radius) {}

    bool operator==(const Sphere& rhs) const
    {
        return position_ == rhs.position_ && radius_ == rhs.radius_;
    }

    bool operator!=(const Sphere& rhs) const
    {
        return !operator==(rhs);
    }

    position_type const& position() const
    {
        return position_;
    }

    position_type& position()
    {
        return position_;
    }

    length_type const& radius() const
    {
        return radius_;
    }

    length_type& radius()
    {
        return radius_;
    }

    std::string show(int precision)
    {
        std::ostringstream strm;
        strm.precision(precision);
        strm << *this;
        return strm.str();
    }

private:
    position_type position_;
    length_type radius_;
};

template<typename Tstrm_, typename Ttraits_, typename T_>
inline std::basic_ostream<Tstrm_, Ttraits_>& operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm,
        const Sphere<T_>& v)
{
    strm << "{" << v.position() <<  ", " << v.radius() << "}";
    return strm;
}

template<typename T_>
inline std::pair<typename Sphere<T_>::position_type,
                 typename Sphere<T_>::length_type>
projected_point(Sphere<T_> const& obj,
                typename Sphere<T_>::position_type const& pos)
{
    // Todo. If we ever need it.
    // The projection of a point on a sphere.
    return std::make_pair(typename Sphere<T_>::position_type(),
                          typename Sphere<T_>::length_type());
}

template<typename T_>
inline typename Sphere<T_>::length_type
distance(Sphere<T_> const& obj, typename Sphere<T_>::position_type const& pos)
{
    return distance(pos, obj.position()) - obj.radius();
}

template<typename T_>
inline Sphere<T_> const& shape(Sphere<T_> const& shape)
{
    return shape;
}

template<typename T_>
inline Sphere<T_>& shape(Sphere<T_>& shape)
{
    return shape;
}

template<typename T, typename Trng>
inline typename Sphere<T>::position_type
random_position(Sphere<T> const& shape, Trng& rng)
{
    return add(shape.position(),
                create_vector<typename Sphere<T>::position_type>(
                    shape.radius() * rng(),
                    shape.radius() * rng(),
                    shape.radius() * rng())); 
}

template<typename T_>
struct is_shape<Sphere<T_> >: public boost::mpl::true_ {};

template<typename T_>
struct shape_position_type<Sphere<T_> > {
    typedef typename Sphere<T_>::position_type type;
};

template<typename T_>
struct shape_length_type<Sphere<T_> > {
    typedef typename Sphere<T_>::length_type type;
};

template<typename T>
inline typename shape_length_type<Sphere<T> >::type const& shape_size(Sphere<T> const& shape)
{
    return shape.radius();
} 

template<typename T>
inline typename shape_length_type<Sphere<T> >::type& shape_size(Sphere<T>& shape)
{
    return shape.radius();
} 

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_>
struct hash<Sphere<T_> >
{
    typedef Sphere<T_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::position_type>()(val.position()) ^
            hash<typename argument_type::length_type>()(val.radius());
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* SPHERE_HPP */
 </xmp> 
<h3> SphericalBesselGenerator.hpp </h3> <xmp>

#ifndef __SPHERICALBESSELGENERATOR_HPP
#define __SPHERICALBESSELGENERATOR_HPP

#include <cmath>

#include <gsl/gsl_errno.h>
#include <gsl/gsl_spline.h>
#include <gsl/gsl_sf_bessel.h>

#include "Defs.hpp"


class SphericalBesselGenerator
{

    typedef UnsignedInteger Index;

public:

    SphericalBesselGenerator()
    {
        ; // do nothing
    }

    ~SphericalBesselGenerator()
    {
        ; // do nothing
    }

    Real j(UnsignedInteger n, Real z) const;

    Real y(UnsignedInteger n, Real z) const;

    static UnsignedInteger getMinNJ();
    static UnsignedInteger getMinNY();
    static UnsignedInteger getMaxNJ();
    static UnsignedInteger getMaxNY();

    static SphericalBesselGenerator const& instance();
};




#endif /* __SPHERICALBESSELGENERATOR_HPP */
 </xmp> 
<h3> SphericalSurface.hpp </h3> <xmp>

#ifndef SPHERICAL_SURFACE_HPP
#define SPHERICAL_SURFACE_HPP

#include "Surface.hpp"
#include "Sphere.hpp"

template<typename Ttraits_>
class SphericalSurface
    : public BasicSurfaceImpl<Ttraits_, Sphere<typename Ttraits_::world_type::traits_type::length_type> >
{
public:
    typedef BasicSurfaceImpl<Ttraits_, Sphere<typename Ttraits_::world_type::traits_type::length_type> > base_type;
    typedef typename base_type::traits_type traits_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::shape_type shape_type;
    typedef typename base_type::rng_type rng_type;
    typedef typename base_type::position_type position_type;
    typedef typename base_type::length_type length_type;

    virtual position_type random_position(rng_type& rng) const
    {
        return position_type(); // TODO
    }

    virtual position_type random_vector(length_type const& r, rng_type& rng) const
    {
        return position_type(); // TODO
    }

    virtual position_type bd_displacement(length_type const& r, rng_type& rng) const
    {
        return position_type(); // TODO
    }

    virtual length_type minimal_distance(length_type const& radius) const
    {
        return 0.; // TODO
    }

    virtual void accept(ImmutativeStructureVisitor<traits_type> const& visitor) const
    {
        visitor(*this);
    }

    virtual void accept(MutativeStructureVisitor<traits_type> const& visitor)
    {
        visitor(*this);
    }

    SphericalSurface(identifier_type const& id, shape_type const& shape)
        : base_type(id, shape) {}
};

#endif /* SPHERICAL_SURFACE_HPP */
 </xmp> 
<h3> Structure.hpp </h3> <xmp>

#ifndef STRUCTURE_HPP
#define STRUCTURE_HPP

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

#include <sstream>
#include "Vector3.hpp"

template<typename Ttraits_>
class Structure
{
public:
    typedef Ttraits_ traits_type;
    typedef typename traits_type::rng_type rng_type;
    typedef typename traits_type::structure_id_type identifier_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::position_type position_type;
    typedef std::pair<position_type, length_type> projected_type;

public:
    virtual ~Structure() {}

    identifier_type const& id() const
    {
        return id_;
    }

    virtual bool operator==(Structure const& rhs) const
    {
        return id_ == rhs.id();
    }

    bool operator!=(Structure const& rhs) const
    {
        return !operator==(rhs);
    }

    virtual position_type random_position(rng_type& rng) const = 0;

    virtual position_type random_vector(length_type const& r, rng_type& rng) const = 0;

    virtual position_type bd_displacement(length_type const& r, rng_type& rng) const = 0;

    virtual projected_type projected_point(position_type const& pos) const = 0;

    virtual std::size_t hash() const
    {
#if defined(HAVE_TR1_FUNCTIONAL)
        using std::tr1::hash;
#elif defined(HAVE_STD_HASH)
        using std::hash;
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
        using boost::hash;
#endif
        return hash<identifier_type>()(id_);
    }

    virtual std::string as_string() const
    {
        std::ostringstream out;
        out << "Structure(" << id() << ")";
        return out.str();
    }

    Structure(identifier_type const& id)
        : id_(id) {}

protected:
    identifier_type id_;
};

template<typename Tstrm, typename Ttraits, typename T_traits>
inline std::basic_ostream<Tstrm, Ttraits>& operator<<(std::basic_ostream<Tstrm, Ttraits>& strm, const Structure<T_traits>& v)
{
    strm << v.as_string(); 
    return strm;
}

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename Ttraits>
struct hash<Structure<Ttraits> >
{
    typedef Structure<Ttraits> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return val.hash();
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* STRUCTURE_HPP */
 </xmp> 
<h3> StructureType.hpp </h3> <xmp>

#ifndef STRUCTURE_TYPE_HPP
#define STRUCTURE_TYPE_HPP

#include <ostream>
#include <string>
#include <boost/format.hpp>
#include <boost/range/value_type.hpp>
#include <boost/range/const_iterator.hpp>
#include <boost/range/iterator_range.hpp>

#include "exceptions.hpp"
#include "utils/get_mapper_mf.hpp"

class ParticleModel;

class StructureType
{
    friend class ParticleModel;
private:
    typedef get_mapper_mf<std::string, std::string>::type string_map_type;

public:
    typedef std::string identifier_type;
    typedef string_map_type::const_iterator string_map_iterator;
    typedef boost::iterator_range<string_map_iterator> attributes_range;

public:
    identifier_type const& id() const;

    std::string const& operator[](std::string const& name) const;

    std::string& operator[](std::string const& name);

    attributes_range attributes() const;

    ParticleModel* model() const
    {
        return model_;
    }

    StructureType(): model_(0) {}
 
protected:
    void bind_to_model(ParticleModel* model, identifier_type const& id)
    {
        model_ = model; 
        id_ = id;
    }

private:
    ParticleModel* model_;
    identifier_type id_;
    string_map_type attrs_;
};

template<typename Tchar_, typename Ttraits_>
inline std::basic_ostream<Tchar_, Ttraits_>&
operator<<(std::basic_ostream<Tchar_, Ttraits_>& out, const StructureType& v)
{
    bool first = true;
    out << "StructureType(id=" << v.id() << ", attributes={";

    typename StructureType::attributes_range attributes(v.attributes());
    for (typename boost::range_const_iterator<
        typename StructureType::attributes_range>::type
            i(attributes.begin()), e(attributes.end()); i != e; ++i)
    {
        typename boost::range_value<typename StructureType::attributes_range>::type
                const& pair(*i);
        if (!first)
            out << ", ";
        out << pair.first << ":" << pair.second;
        first = false;
    }
    out << "})";
    return out;
}

#endif /* STRUCTURE_TYPE_HPP */
 </xmp> 
<h3> StructureUtils.hpp </h3> <xmp>

#ifndef STRUCTURE_UTILS_HPP
#define STRUCTURE_UTILS_HPP

#include <string>
#include <typeinfo>
#include "linear_algebra.hpp"
#include "geometry.hpp"
#include "exceptions.hpp"
#include "Surface.hpp"
#include "Region.hpp"

template<typename Tsim_>
struct StructureUtils
{
    typedef Tsim_ simulator_type;
    typedef typename simulator_type::traits_type traits_type;
    typedef typename traits_type::world_type::position_type position_type;
    typedef typename traits_type::world_type::length_type length_type;
    typedef typename traits_type::world_type::structure_id_type structure_id_type;
    typedef typename traits_type::world_type::structure_type structure_type;
    typedef typename simulator_type::surface_type surface_type;
    typedef typename simulator_type::region_type region_type;
    typedef typename simulator_type::sphere_type sphere_type;
    typedef typename simulator_type::cylinder_type cylinder_type;
    typedef typename simulator_type::box_type box_type;
    typedef typename simulator_type::plane_type plane_type;
    typedef typename simulator_type::spherical_surface_type spherical_surface_type;
    typedef typename simulator_type::cylindrical_surface_type cylindrical_surface_type;
    typedef typename simulator_type::planar_surface_type planar_surface_type;
    typedef typename simulator_type::cuboidal_region_type cuboidal_region_type;
    typedef typename simulator_type::world_type::traits_type::rng_type rng_type;
 
    static planar_surface_type* create_planar_surface(
            structure_id_type const& id,
            position_type const& corner,
            position_type const& unit_x,
            position_type const& unit_y,
            length_type const& lx,
            length_type const& ly)
    {
        BOOST_ASSERT(is_cartesian_versor(unit_x));
        BOOST_ASSERT(is_cartesian_versor(unit_y));
        BOOST_ASSERT(is_cartesian_versor(cross_product(unit_x, unit_y)));

        const length_type half_lx(lx / 2);
        const length_type half_ly(ly / 2);

        const position_type pos(add(add(corner, multiply(unit_x, half_lx)),
                                    multiply(unit_y, half_ly)));

        return new planar_surface_type(id,
                                       plane_type(pos, unit_x, unit_y,
                                                  half_lx, half_ly));
    }

    static spherical_surface_type* create_spherical_surface(
            structure_id_type const& id,
            position_type const& pos,
            length_type const& radius)
    {
        return new spherical_surface_type(id, sphere_type(pos, radius));
    }

    static cylindrical_surface_type* create_cylindrical_surface(
            structure_id_type const& id,
            position_type const& corner,
            length_type const& radius,
            position_type const& unit_z,
            length_type const& length)
    {
        BOOST_ASSERT(is_cartesian_versor(unit_z));

        const length_type half_length(length / 2);
        const position_type pos(add(corner, multiply(unit_z, half_length)));

        return new cylindrical_surface_type(id,
                cylinder_type(pos, radius, unit_z, half_length));
    }

    static cuboidal_region_type* create_cuboidal_region(
            structure_id_type const& id,
            position_type const& corner,
            boost::array<length_type, 3> const& extent)
    {
        const boost::array<length_type, 3> half_extent(divide(extent, 2));
        return new cuboidal_region_type(id,
                box_type(add(corner, half_extent),
                         create_vector<position_type>(1, 0, 0),
                         create_vector<position_type>(0, 1, 0),
                         create_vector<position_type>(0, 0, 1),
                         half_extent));
    }

    static position_type random_vector(structure_type const& structure,
            length_type const& r, rng_type& rng)
    {
        return structure.random_vector(r, rng);
    }

    static position_type random_position(structure_type const& structure, rng_type& rng)
    {
        return structure.random_position(rng);
    }

    static length_type minimal_distance_from_surface(surface_type const& surface, length_type const& radius)
    {
        return surface.minimal_distance(radius);
    }
};

#endif /* STRUCTURE_UTILS_HPP */
 </xmp> 
<h3> Surface.hpp </h3> <xmp>

#ifndef SURFACE_HPP
#define SURFACE_HPP

#include <ostream>
#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

#include <sstream>
#include "ParticleSimulationStructure.hpp"
#include "Cylinder.hpp"
#include "Sphere.hpp"
#include "Plane.hpp"

template<typename Ttraits_>
class Surface: public ParticleSimulationStructure<Ttraits_>
{
public:
    typedef ParticleSimulationStructure<Ttraits_> base_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::length_type length_type;

public:
    virtual ~Surface() {}

    Surface(identifier_type const& id): base_type(id) {}

    virtual length_type minimal_distance(length_type const& radius) const = 0;
};

template<typename Ttraits_, typename Tshape_>
class BasicSurfaceImpl: public Surface<Ttraits_>
{
public:
    typedef Surface<Ttraits_> base_type;
    typedef Tshape_ shape_type;
    typedef typename base_type::identifier_type identifier_type;
    typedef typename base_type::length_type length_type;
    typedef typename base_type::position_type position_type;
    typedef std::pair<position_type, length_type> projected_type;

public:
    virtual ~BasicSurfaceImpl() {}

    shape_type& shape()
    {
        return shape_;
    }

    shape_type const& shape() const
    {
        return shape_;
    }

    virtual bool operator==(Structure<typename Ttraits_::world_type::traits_type> const& rhs) const
    {
        BasicSurfaceImpl const* _rhs(dynamic_cast<BasicSurfaceImpl const*>(&rhs));
        return _rhs && base_type::id_ == rhs.id() && shape_ == _rhs->shape();
    }
    
    virtual std::size_t hash() const
    {
#if defined(HAVE_TR1_FUNCTIONAL)
        using std::tr1::hash;
#elif defined(HAVE_STD_HASH)
        using std::hash;
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
        using boost::hash;
#endif
        return hash<identifier_type>()(base_type::id_) ^ hash<shape_type>()(shape());
    }

    virtual std::string as_string() const
    {
        std::ostringstream out;
        out << "Surface(" << base_type::id_ << ":" << shape() << ")";
        return out.str();
    }

    projected_type
    projected_point(position_type const& pos) const
    {
        return ::projected_point(shape(), pos);
    }

    BasicSurfaceImpl(identifier_type const& id, shape_type const& shape)
        : base_type(id), shape_(shape) {}

protected:
    shape_type shape_;
};

#endif /* SURFACE_HPP */
 </xmp> 
<h3> Transaction.hpp </h3> <xmp>

#ifndef TRANSACTION_HPP
#define TRANSACTION_HPP

#include <vector>
#include <map>
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include "utils.hpp"
#include "ParticleContainer.hpp"
#include "sorted_list.hpp"
#include "generator.hpp"
#include "utils/unassignable_adapter.hpp"
#include "utils/stringizer.hpp"

template<typename Ttraits_>
class Transaction: public ParticleContainer<Ttraits_>
{
public:
    typedef Ttraits_ traits_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename particle_type::shape_type particle_shape_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef abstract_limited_generator<particle_id_pair> particle_id_pair_generator;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;

    virtual ~Transaction() {}

    virtual particle_id_pair_generator* get_added_particles() const = 0;

    virtual particle_id_pair_generator* get_removed_particles() const = 0;

    virtual particle_id_pair_generator* get_modified_particles() const = 0;

    virtual void rollback() = 0;
};

template<typename Tpc_>
class TransactionImpl: public Transaction<typename Tpc_::traits_type>
{
public:
    typedef Tpc_ particle_container_type;
    typedef typename particle_container_type::traits_type traits_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename particle_type::shape_type particle_shape_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;
    typedef abstract_limited_generator<particle_id_pair> particle_id_pair_generator;
    typedef std::pair<particle_id_pair, length_type> particle_id_pair_and_distance;
    typedef unassignable_adapter<particle_id_pair_and_distance, get_default_impl::std::vector> particle_id_pair_and_distance_list;

private:
    typedef std::map<typename particle_id_pair::first_type,
            typename particle_id_pair::second_type> particle_id_pair_set_type;
    typedef sorted_list<std::vector<particle_id_type> > particle_id_list_type;

public:
    virtual particle_id_pair new_particle(species_id_type const& sid,
            position_type const& pos)
    {
        particle_id_pair retval(pc_.new_particle(sid, pos));
        const bool result(added_particles_.push_no_duplicate(retval.first));
        BOOST_ASSERT(result);
        return retval;
    }

    virtual bool update_particle(particle_id_pair const& pi_pair)
    {
        BOOST_ASSERT(removed_particles_.end() ==
                removed_particles_.find(pi_pair.first));
        std::pair<typename particle_id_pair_set_type::iterator, bool> r(
                orig_particles_.insert(particle_id_pair(
                    pi_pair.first, particle_type())));
        if (r.second &&
            added_particles_.end() == added_particles_.find(pi_pair.first))
        {
            modified_particles_.push_no_duplicate(pi_pair.first);
            particle_type _v(pc_.get_particle(pi_pair.first).second);
            std::swap((*r.first).second, _v);
        }
        return pc_.update_particle(pi_pair);
    }

    virtual bool remove_particle(particle_id_type const& id)
    {
        std::pair<typename particle_id_pair_set_type::iterator, bool> r(
                orig_particles_.insert(particle_id_pair(
                    id, particle_type())));
        if (r.second)
        {
            particle_type _v(pc_.get_particle(id).second);
            std::swap((*r.first).second, _v);
        }

        if (added_particles_.erase(id) == 0)
        {
            modified_particles_.erase(id);
            const bool result(removed_particles_.push_no_duplicate(id));
            BOOST_ASSERT(result);
        }
        else
        {
            orig_particles_.erase(id);
        }
        return pc_.remove_particle(id);
    }

    virtual particle_id_pair get_particle(particle_id_type const& id) const
    {
        return pc_.get_particle(id);
    }

    virtual bool has_particle(particle_id_type const& id) const
    {
        return pc_.has_particle(id);
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s) const
    {
        return pc_.check_overlap(s);
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore) const
    {
        return pc_.check_overlap(s, ignore);
    }

    virtual particle_id_pair_and_distance_list* check_overlap(particle_shape_type const& s, particle_id_type const& ignore1, particle_id_type const& ignore2) const
    {
        return pc_.check_overlap(s, ignore1, ignore2);
    }

    virtual Transaction<traits_type>* create_transaction()
    {
        return new TransactionImpl<particle_container_type>(*this);
    }

    virtual boost::shared_ptr<structure_type> get_structure(structure_id_type const& id) const
    {
        return pc_.get_structure(id);
    }

    virtual species_type const& get_species(species_id_type const& id) const
    {
        return pc_.get_species(id);
    }

    virtual size_type num_particles() const
    {
        return pc_.num_particles();
    }

    virtual length_type world_size() const
    {
        return pc_.world_size();
    }

    virtual particle_id_pair_generator* get_particles() const
    {
        return pc_.get_particles();
    }

    virtual particle_id_pair_generator* get_added_particles() const
    {
        return make_range_generator<true>(
            make_transform_iterator_range(added_particles_,
                boost::bind(&TransactionImpl::get_particle, this, _1)));
            
    }

    virtual particle_id_pair_generator* get_removed_particles() const
    {
        return make_range_generator<true>(
            make_transform_iterator_range(removed_particles_,
                boost::bind(&TransactionImpl::get_original_particle, this, _1)));
    }

    virtual particle_id_pair_generator* get_modified_particles() const
    {
        return make_range_generator<true>(
            make_transform_iterator_range(modified_particles_,
                boost::bind(&TransactionImpl::get_particle, this, _1)));
    }

    virtual void rollback()
    {
        for (typename particle_id_pair_set_type::iterator
                i(orig_particles_.begin()), e(orig_particles_.end());
                i != e; ++i)
        {
            pc_.update_particle(*i);
        }

        for (typename particle_id_list_type::iterator
                i(added_particles_.begin()), e(added_particles_.end());
                i != e; ++i)
        {
            pc_.remove_particle(*i);
        }
        added_particles_.clear();
        modified_particles_.clear();
        removed_particles_.clear();
        orig_particles_.clear();
    }

    virtual length_type distance(position_type const& lhs,
                                 position_type const& rhs) const
    {
        return pc_.distance(lhs, rhs);
    }

    virtual position_type apply_boundary(position_type const& v) const
    {
        return pc_.apply_boundary(v);
    }

    virtual length_type apply_boundary(length_type const& v) const
    {
        return pc_.apply_boundary(v);
    }

    virtual position_type cyclic_transpose(position_type const& p0, position_type const& p1) const
    {
        return pc_.cyclic_transpose(p0, p1);
    }

    virtual length_type cyclic_transpose(length_type const& p0, length_type const& p1) const
    {
        return pc_.cyclic_transpose(p0, p1);
    }

    virtual ~TransactionImpl() {}

    TransactionImpl(particle_container_type& pc): pc_(pc) {}

private:
    particle_id_pair get_original_particle(particle_id_type const& id) const
    {
        typename particle_id_pair_set_type::const_iterator i(orig_particles_.find(id));
        if (orig_particles_.end() == i)
        {
            throw not_found(std::string("No such particle: id=")
                    + boost::lexical_cast<std::string>(id));
        }
        return *i;
    }

private:
    particle_container_type& pc_;
    particle_id_list_type added_particles_;
    particle_id_list_type modified_particles_;
    particle_id_pair_set_type orig_particles_;
    particle_id_list_type removed_particles_;
};

#endif /* TRANSACTION_HPP */
 </xmp> 
<h3> twofold_container.hpp </h3> <xmp>

#ifndef TWOFOLD_CONTAINER_HPP
#define TWOFOLD_CONTAINER_HPP

#include <algorithm>
#include <boost/array.hpp>
#include <boost/iterator/iterator_facade.hpp>
#include <boost/iterator/iterator_categories.hpp>
#include "utils/memberwise_compare.hpp"

template<typename T_>
class twofold_container
{
public:
    typedef T_ value_type;
private:
    typedef boost::array<value_type, 2> containing_type;
public:
    typedef typename containing_type::reference reference;
    typedef typename containing_type::const_reference const_reference;
    typedef typename containing_type::size_type size_type;
    typedef typename containing_type::difference_type difference_type;

    class const_iterator;
    class iterator
        : public boost::iterator_facade<
            iterator, value_type, boost::forward_traversal_tag>
    {
        friend class const_iterator;
        friend class twofold_container;
        friend class boost::iterator_core_access;

        std::ptrdiff_t distance_to(iterator const& that) const
        {
            return that.idx_ - idx_;
        }

        bool equal(iterator const& that) const
        {
            return &cntnr_ == &that.cntnr_ && idx_ == that.idx_;
        }

        void increment()
        {
            ++idx_;
        }

        value_type& dereference() const
        {
            return cntnr_[idx_];
        }

    public:
        iterator(twofold_container& cntnr, size_type idx)
            : cntnr_(cntnr), idx_(idx) {}

        iterator(const_iterator const&);

    private:
        twofold_container& cntnr_;
        size_type idx_;
    };

    class const_iterator
        : public boost::iterator_facade<
            const_iterator, const value_type, boost::forward_traversal_tag>
    {
        friend class iterator;
        friend class twofold_container;
        friend class boost::iterator_core_access;

        std::ptrdiff_t distance_to(const_iterator const& that) const
        {
            return that.idx_ - idx_;
        }

        bool equal(const_iterator const& that) const
        {
            return &cntnr_ == &that.cntnr_ && idx_ == that.idx_;
        }

        void increment()
        {
            ++idx_;
        }

        value_type const& dereference() const
        {
            return cntnr_[idx_];
        }

    public:
        const_iterator(twofold_container const& cntnr, size_type idx)
            : cntnr_(cntnr), idx_(idx) {}

        const_iterator(iterator const& that)
            : cntnr_(that.cntnr_), idx_(that.idx_) {}

    private:
        twofold_container const& cntnr_;
        size_type idx_;
    };

public:
    twofold_container()
    {
        items_[0] = value_type();
        items_[1] = value_type();
    }

    twofold_container(value_type const& one)
    {
        BOOST_ASSERT(one);
        items_[0] = one;
        items_[1] = value_type();
    }

    twofold_container(value_type const& one, value_type const& two)
    {
        BOOST_ASSERT(one);
        BOOST_ASSERT(two);
        if (one <= two)
        {
            items_[0] = one;
            items_[1] = two;
        }
        else
        {
            items_[0] = two;
            items_[1] = one;
        }
    }

    size_type size() const
    {
        return items_[0] ? items_[1] ? 2: 1: 0;
    }

    iterator begin()
    {
        return iterator(*this, 0);
    }

    iterator end()
    {
        return iterator(*this, size());
    }

    const_iterator begin() const
    {
        return const_iterator(*this, 0);
    }

    const_iterator end() const
    {
        return const_iterator(*this, size());
    }

    void push_back(value_type const& item)
    {
        if (!items_[0])
        {
            items_[0] = item;
        }
        else if (!items_[1])
        {
            items_[1] = item;
        }
        else
        {
            BOOST_ASSERT(false);
        }
    }

    iterator insert(iterator pos, value_type const& item)
    {
        switch (pos.idx_)
        {
        case 0:
            switch (size())
            {
            case 0:
                items_[0] = item;
                return pos;
            case 1:
                items_[1] = items_[0];
                items_[0] = item;
                return pos;
            default:
                break;
            }
        case 1:
            switch (size())
            {
            case 1:
                items_[1] = item;
                return pos;
            default:
                break;
            }
        }
        BOOST_ASSERT(0);
    }

    value_type& operator[](std::size_t idx)
    {
        return items_[idx];
    }

    value_type const& operator[](std::size_t idx) const
    {
        return items_[idx];
    }

    bool operator<(twofold_container const& rhs) const
    {
        return memberwise_compare(*this, rhs) < 0;
    }

    bool operator>=(twofold_container const& rhs) const
    {
        return !operator<(rhs);
    }

    bool operator>(twofold_container const& rhs) const
    {
        return memberwise_compare(*this, rhs) > 0;
    }

    bool operator<=(twofold_container const& rhs) const
    {
        return !operator>(rhs);
    }

    bool operator==(twofold_container const& rhs) const
    {
        if (rhs.size() != size())
            return false;
        switch (size())
        {
        case 0:
            return true;
        case 1:
            return items_[0] == rhs[0];
        case 2:
            return items_[0] == rhs[0] && items_[1] == rhs[1];
        }
        /* never get here */
        return false;
    }

    bool operator!=(twofold_container const& rhs) const
    {
        return !operator==(rhs);
    }

    void swap(twofold_container& rhs)
    {
        std::swap(items_, rhs.items_);
    }

protected:
    containing_type items_;
};

template<typename T_>
inline twofold_container<T_>::iterator::iterator(
        typename twofold_container<T_>::const_iterator const& that)
    : cntnr_(const_cast<twofold_container&>(that.cntnr_)), idx_(that.idx_)
{
}

#endif /* TWOFOLD_CONTAINER_HPP */
 </xmp> 
<h3> utils.hpp </h3> <xmp>

#ifndef UTILS_HPP
#define UTILS_HPP

void gsl_error_handler( char const* reason, char const* file, int line, int gsl_errno );

#endif /* UTILS_HPP */
 </xmp> 
<h3> Vector3.hpp </h3> <xmp>

#ifndef VECTOR3_HPP
#define VECTOR3_HPP

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* HAVE_CONFIG_H */

#include <ostream>
#include <iomanip>
#include <functional>
#include <algorithm>

#if defined(HAVE_TR1_FUNCTIONAL)
#include <tr1/functional>
#elif defined(HAVE_STD_HASH)
#include <functional>
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
#include <boost/functional/hash.hpp>
#endif

#include <boost/array.hpp>
#include "utils/array_traits.hpp"
#include "linear_algebra.hpp"

template<typename T_>
struct Vector3: public boost::array<T_, 3>
{
    typedef boost::array<T_, 3> base_type;
    typedef typename base_type::value_type value_type;
    typedef typename base_type::size_type size_type;

    Vector3& operator+=(Vector3 const& rhs)
    {
        *this = add(*this, rhs);
        return *this;
    }

    Vector3& operator-=(Vector3 const& rhs)
    {
        *this = subtract(*this, rhs);
        return *this;
    }

    template<typename TT_>
    Vector3& operator*=(TT_ const& rhs)
    {
        *this = multiply(*this, rhs);
        return *this;
    }

    template<typename TT_>
    Vector3& operator/=(TT_ const& rhs)
    {
        *this = divide(*this, rhs);
        return *this;
    }

    Vector3()
    {
        (*this)[0] = 0;
        (*this)[1] = 0;
        (*this)[2] = 0;
    }

    Vector3(const T_ (&a)[3]): base_type(
            *reinterpret_cast<const base_type*>(&a)) {}

    Vector3(const T_ a[3]): base_type(
            *reinterpret_cast<const base_type*>(a)) {}

    Vector3(const base_type& a): base_type(a) {}

    Vector3(value_type p0, value_type p1, value_type p2)
    {
        (*this)[0] = p0;
        (*this)[1] = p1;
        (*this)[2] = p2;
    }
};

template< typename T_ >
inline Vector3< T_ > operator+(Vector3< T_ > const& lhs, Vector3< T_ > const& rhs)
{
    return add( lhs, rhs );
}

template< typename T_ >
inline Vector3< T_ > operator-(Vector3< T_ > const& lhs, Vector3< T_ > const& rhs)
{
    return subtract( lhs, rhs );
}

template<typename T_>
inline Vector3<T_> operator/(Vector3<T_> const& lhs, T_ const& rhs)
{
    return divide(lhs, rhs);
}

template<typename T_>
inline Vector3<T_> operator*(Vector3<T_> const& lhs, T_ const& rhs)
{
    return multiply(lhs, rhs);
}

template<typename Tstrm_, typename Ttraits_, typename T_>
inline std::basic_ostream<Tstrm_, Ttraits_>&
operator<<(std::basic_ostream<Tstrm_, Ttraits_>& strm, const Vector3<T_>& v)
{
    strm << std::setprecision(12) << "(" << v[0] <<  ", " << v[1] <<  ", " << v[2] << ")";
    return strm;
}

template<typename T_>
struct is_vector<Vector3<T_>, 3>: public boost::mpl::true_ {};

template< typename T_ >
struct element_type_of< Vector3< T_ > >
{
    typedef T_ type;
};

#if defined(HAVE_TR1_FUNCTIONAL)
namespace std { namespace tr1 {
#elif defined(HAVE_STD_HASH)
namespace std {
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
namespace boost {
#endif

template<typename T_>
struct hash<Vector3<T_> >
{
    typedef Vector3<T_> argument_type;

    std::size_t operator()(argument_type const& val)
    {
        return hash<typename argument_type::value_type>()(val[0]) ^
            hash<typename argument_type::value_type>()(val[1]) ^
            hash<typename argument_type::value_type>()(val[2]);
    }
};

#if defined(HAVE_TR1_FUNCTIONAL)
} } // namespace std::tr1
#elif defined(HAVE_STD_HASH)
} // namespace std
#elif defined(HAVE_BOOST_FUNCTIONAL_HASH_HPP)
} // namespace boost
#endif

#endif /* VECTOR3_HPP */
 </xmp> 
<h3> World.hpp </h3> <xmp>

#ifndef WORLD_HPP
#define WORLD_HPP

#include "ParticleContainerBase.hpp"

#include <map>
#include <boost/lexical_cast.hpp>
#include <boost/array.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits/is_same.hpp>
#include "exceptions.hpp"
#include "generator.hpp"
#include "filters.hpp"
#include "Particle.hpp"
#include "ParticleID.hpp"
#include "SpeciesTypeID.hpp"
#include "SpeciesInfo.hpp"
#include "SerialIDGenerator.hpp"
#include "Transaction.hpp"
#include "Structure.hpp"
#include "Surface.hpp"
#include "Region.hpp"
#include "geometry.hpp"
#include "GSLRandomNumberGenerator.hpp"
#include "Point.hpp" // XXX: workaround. should be removed later.
#include "utils/pair.hpp"

template<typename Tderived_, typename Tlen_, typename TD_>
struct WorldTraitsBase
{
    typedef std::size_t size_type;
    typedef Tlen_ length_type;
    typedef TD_ D_type;
    typedef TD_ v_type;
    typedef ParticleID particle_id_type;
    typedef SerialIDGenerator<particle_id_type> particle_id_generator;
    typedef SpeciesTypeID species_id_type;
    typedef Particle<length_type, D_type, species_id_type> particle_type;
    typedef std::string structure_id_type;
    typedef SpeciesInfo<species_id_type, D_type, length_type, structure_id_type> species_type;
    typedef Vector3<length_type> point_type;
    typedef typename particle_type::shape_type::position_type position_type;
    typedef GSLRandomNumberGenerator rng_type;
    typedef Structure<Tderived_> structure_type;

    static const Real TOLERANCE = 1e-7;
};

template<typename Tlen_, typename TD_>
struct WorldTraits: public WorldTraitsBase<WorldTraits<Tlen_, TD_>, Tlen_, TD_>
{
public:
    typedef WorldTraitsBase<WorldTraits<Tlen_, TD_>, Tlen_, TD_> base_type;
    typedef typename base_type::length_type length_type;
    typedef typename base_type::position_type position_type;

    template<typename Tval_>
    static Tval_ apply_boundary(Tval_ const& v, length_type const& world_size)
    {
        return v;
    }

    template<typename Tval_>
    static Tval_ cyclic_transpose(Tval_ const& p0, Tval_ const& p1, length_type const& world_size)
    {
        return p0;
    }

    template<typename T1_, typename T2_>
    static length_type distance(T1_ const& p0, T2_ const& p1, length_type const& world_size)
    {
        return ::distance(p0, p1);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void each_neighbor(Toc_& oc, Tfun_& fun, Tsphere_ const& pos)
    {
        oc.each_neighbor(oc.index(pos), fun);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void each_neighbor(Toc_ const& oc, Tfun_& fun, Tsphere_ const& pos)
    {
        oc.each_neighbor(oc.index(pos), fun);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void take_neighbor(Toc_& oc, Tfun_& fun, const Tsphere_& cmp)
    {
        take_neighbor(oc, fun, cmp);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void take_neighbor(Toc_ const& oc, Tfun_& fun, const Tsphere_& cmp)
    {
        take_neighbor(oc, fun, cmp);
    }
};

template<typename Tlen_, typename TD_>
struct CyclicWorldTraits: public WorldTraitsBase<CyclicWorldTraits<Tlen_, TD_>, Tlen_, TD_>
{
public:
    typedef WorldTraitsBase<CyclicWorldTraits<Tlen_, TD_>, Tlen_, TD_> base_type;
    typedef typename base_type::length_type length_type;
    typedef typename base_type::position_type position_type;

    template<typename Tval_>
    static Tval_ apply_boundary(Tval_ const& v, length_type const& world_size)
    {
        return ::apply_boundary(v, world_size);
    }

    static length_type cyclic_transpose(length_type const& p0, length_type const& p1, length_type const& world_size)
    {
        return ::cyclic_transpose(p0, p1, world_size);
    }

    static position_type cyclic_transpose(position_type const& p0, position_type const& p1, length_type const& world_size)
    {
        return ::cyclic_transpose(p0, p1, world_size);
    }

    template<typename T1_, typename T2_>
    static length_type distance(T1_ const& p0, T2_ const& p1, length_type const& world_size)
    {
        return distance_cyclic(p0, p1, world_size);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void each_neighbor(Toc_& oc, Tfun_& fun, Tsphere_ const& pos)
    {
        oc.each_neighbor_cyclic(oc.index(pos), fun);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void each_neighbor(Toc_ const& oc, Tfun_& fun, Tsphere_ const& pos)
    {
        oc.each_neighbor_cyclic(oc.index(pos), fun);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void take_neighbor(Toc_& oc, Tfun_& fun, const Tsphere_& cmp)
    {
        take_neighbor_cyclic(oc, fun, cmp);
    }

    template<typename Toc_, typename Tfun_, typename Tsphere_>
    static void take_neighbor(Toc_ const& oc, Tfun_& fun, const Tsphere_& cmp)
    {
        take_neighbor_cyclic(oc, fun, cmp);
    }
};

template<typename Ttraits_>
class World: public ParticleContainerBase<World<Ttraits_>, Ttraits_>
{
public:
    typedef Ttraits_ traits_type;
    typedef ParticleContainerBase<World> base_type;
    typedef ParticleContainer<traits_type> particle_container_type;
    typedef typename traits_type::length_type length_type;
    typedef typename traits_type::species_type species_type;
    typedef typename traits_type::position_type position_type;
    typedef typename traits_type::particle_type particle_type;
    typedef typename traits_type::particle_id_type particle_id_type;
    typedef typename traits_type::particle_id_generator particle_id_generator;
    typedef typename traits_type::species_id_type species_id_type;
    typedef typename traits_type::particle_type::shape_type particle_shape_type;
    typedef typename traits_type::size_type size_type;
    typedef typename traits_type::structure_id_type structure_id_type;
    typedef typename traits_type::structure_type structure_type;
    typedef std::pair<const particle_id_type, particle_type> particle_id_pair;

protected:
    typedef std::map<species_id_type, species_type> species_map;
    typedef std::map<structure_id_type, boost::shared_ptr<structure_type> > structure_map;
    typedef std::set<particle_id_type> particle_id_set;
    typedef std::map<species_id_type, particle_id_set> per_species_particle_id_set;
    typedef select_second<typename species_map::value_type> species_second_selector_type;
    typedef select_second<typename structure_map::value_type> surface_second_selector_type;

public:
    typedef boost::transform_iterator<species_second_selector_type,
            typename species_map::const_iterator> species_iterator;
    typedef boost::transform_iterator<surface_second_selector_type,
            typename structure_map::const_iterator> surface_iterator;
    typedef sized_iterator_range<species_iterator> species_range;
    typedef sized_iterator_range<surface_iterator> structures_range;

public:
    World(length_type world_size = 1., size_type size = 1)
        : base_type(world_size, size) {}

    virtual particle_id_pair new_particle(species_id_type const& sid,
            position_type const& pos)
    {
        species_type const& species(get_species(sid));
        particle_id_pair retval(pidgen_(),
            particle_type(sid, particle_shape_type(pos, species.radius()),
                          species.D(), species.v() ));
        update_particle(retval);
        return retval;
    }

    virtual bool update_particle(particle_id_pair const& pi_pair)
    {
        typename base_type::particle_matrix_type::iterator i(
                base_type::pmat_.find(pi_pair.first));
        if (i != base_type::pmat_.end())
        {
            if ((*i).second.sid() != pi_pair.second.sid())
            {
                particle_pool_[(*i).second.sid()].erase((*i).first);
                particle_pool_[pi_pair.second.sid()].insert(pi_pair.first);
            }
            base_type::pmat_.update(i, pi_pair);
            return false;
        }
        BOOST_ASSERT(base_type::update_particle(pi_pair));
        particle_pool_[pi_pair.second.sid()].insert(pi_pair.first);
        return true;
    }

    virtual bool remove_particle(particle_id_type const& id)
    {
        bool found(false);
        particle_id_pair pp(get_particle(id, found));
        if (!found)
        {
            return false;
        }
        particle_pool_[pp.second.sid()].erase(id);
        base_type::remove_particle(id);
        return true;
    }

    void add_species(species_type const& species)
    {
        species_map_[species.id()] = species;
        particle_pool_[species.id()] = particle_id_set();
    }

    virtual species_type const& get_species(species_id_type const& id) const
    {
        typename species_map::const_iterator i(species_map_.find(id));
        if (species_map_.end() == i)
        {
            throw not_found(std::string("Unknown species (id=") + boost::lexical_cast<std::string>(id) + ")");
        }
        return (*i).second;
    }

    species_range get_species() const
    {
        return species_range(
            species_iterator(species_map_.begin(), species_second_selector_type()),
            species_iterator(species_map_.end(), species_second_selector_type()),
            species_map_.size());
    }

    bool add_structure(boost::shared_ptr<structure_type> surface)
    {
        return structure_map_.insert(std::make_pair(surface->id(), surface)).second;
    }

    virtual boost::shared_ptr<structure_type> get_structure(structure_id_type const& id) const
    {
        typename structure_map::const_iterator i(structure_map_.find(id));
        if (structure_map_.end() == i)
        {
            throw not_found(std::string("Unknown surface (id=") + boost::lexical_cast<std::string>(id) + ")");
        }
        return (*i).second;
    }

    structures_range get_structures() const
    {
        return structures_range(
            surface_iterator(structure_map_.begin(), surface_second_selector_type()),
            surface_iterator(structure_map_.end(), surface_second_selector_type()),
            structure_map_.size());
    }

    particle_id_set get_particle_ids(species_id_type const& sid) const
    {
        typename per_species_particle_id_set::const_iterator i(
            particle_pool_.find(sid));
        if (i == particle_pool_.end())
        {
            throw not_found(std::string("Unknown species (id=") + boost::lexical_cast<std::string>(sid) + ")");
        }
        return (*i).second;
    }

private:
    particle_id_generator pidgen_;
    species_map species_map_;
    structure_map structure_map_;
    per_species_particle_id_set particle_pool_;
};

#endif /* WORLD_HPP */
 </xmp>